Mesa Documentation
Release .1

Project Mesa Team

May 10, 2025

CONTENTS

1

Features

3

2

Using Mesa
2.1 Installation Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Development and Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4 Citing Mesa . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1
Getting started . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.1 Tutorials . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.2 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3 Further resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.1
Best practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.2
API documentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.3
Repository of models built using MESA . . . . . . . . . . . . . . . . . .
2.4.1.3.4
Migration guide . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.5
Source Ccode and development . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6
Community and support . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.1
Overview of the MESA library . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.2
Modeling modules . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.3
Spaces in Mesa . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.4
Discrete Spaces . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.5
Property Layers . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.6
Continuous Space . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.7
Time Advancement and Agent Activation . . . . . . . . . . . . .
2.4.1.3.6.8
Basic Time Steps . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.9
Agent Activation Patterns . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.10 Event-Based Scheduling . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.11 AgentSet and model.agents . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.12 model.agents . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.13 AgentSet Functionality . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.14 Analysis modules . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.15 Visualization . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.16 Creating Your First Model . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.17 The Boltzmann Wealth Model . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.18 Tutorial Description . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.19 Model Description . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.20 Tutorial Setup . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.21 IN COLAB? - Run the next cell . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.22 Building the Sample Model . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.23 Import Dependencies . . . . . . . . . . . . . . . . . . . . . . . .

5
5
5
5
6
6
6
6
6
7
7
7
7
7
7
7
7
8
8
9
9
9
9
9
9
10
10
10
11
12
13
13
13
13
13
14
14
14
i

2.4.1.3.6.24
2.4.1.3.6.25
2.4.1.3.6.26
2.4.1.3.6.27
2.4.1.3.6.28
2.4.1.3.6.29
2.4.1.3.6.30
2.4.1.3.6.31
2.4.1.3.6.32
2.4.1.3.6.33
2.4.1.3.6.34
2.4.1.3.6.35
2.4.1.3.6.36
2.4.1.3.6.37
2.4.1.3.6.38
2.4.1.3.6.39
2.4.1.3.6.40
2.4.1.3.6.41
2.4.1.3.6.42
2.4.1.3.6.43
2.4.1.3.6.44
2.4.1.3.6.45
2.4.1.3.6.46
2.4.1.3.6.47
2.4.1.3.6.48
2.4.1.3.6.49
2.4.1.3.6.50
2.4.1.3.6.51
2.4.1.3.6.52
2.4.1.3.6.53
2.4.1.3.6.54
2.4.1.3.6.55
2.4.1.3.6.56
2.4.1.3.6.57
2.4.1.3.6.58
2.4.1.3.6.59
2.4.1.3.6.60
2.4.1.3.6.61
2.4.1.3.6.62
2.4.1.3.6.63
2.4.1.3.6.64
2.4.1.3.6.65
2.4.1.3.6.66
2.4.1.3.6.67
2.4.1.3.6.68
2.4.1.3.6.69
2.4.1.3.6.70
2.4.1.3.6.71
2.4.1.3.6.72
2.4.1.3.6.73
2.4.1.3.6.74
2.4.1.3.6.75
2.4.1.3.6.76
2.4.1.3.6.77
ii

Create Agent . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Create Model . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Making the Agents do . . . . . . . . . . . . . . . . . . . . . . . .
Running the Model . . . . . . . . . . . . . . . . . . . . . . . . .
Exercise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Agents Exchange . . . . . . . . . . . . . . . . . . . . . . . . . .
Running your first model . . . . . . . . . . . . . . . . . . . . . .
Exercise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Next Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
More Mesa . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Happy Modeling! . . . . . . . . . . . . . . . . . . . . . . . . . .
Adding Space . . . . . . . . . . . . . . . . . . . . . . . . . . . .
The Boltzmann Wealth Model . . . . . . . . . . . . . . . . . . .
Tutorial Description . . . . . . . . . . . . . . . . . . . . . . . . .
IN COLAB? - Run the next cell . . . . . . . . . . . . . . . . . . .
Import Dependencies . . . . . . . . . . . . . . . . . . . . . . . .
Base Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Adding space . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Code Implementation . . . . . . . . . . . . . . . . . . . . . . . .
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Next Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Collecting Data . . . . . . . . . . . . . . . . . . . . . . . . . . .
The Boltzmann Wealth Model . . . . . . . . . . . . . . . . . . .
Tutorial Description . . . . . . . . . . . . . . . . . . . . . . . . .
IN COLAB? - Run the next cell . . . . . . . . . . . . . . . . . . .
Import Dependencies . . . . . . . . . . . . . . . . . . . . . . . .
Base Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Collecting Data . . . . . . . . . . . . . . . . . . . . . . . . . . .
Analyzing MoneyModel Data . . . . . . . . . . . . . . . . . . . .
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Analyzing an MoneyAgent Data . . . . . . . . . . . . . . . . . .
Next Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Agent Management Through AgentSet . . . . . . . . . . . . . . .
The Boltzmann Wealth Model . . . . . . . . . . . . . . . . . . .
Tutorial Description . . . . . . . . . . . . . . . . . . . . . . . . .
IN COLAB? - Run the next cell . . . . . . . . . . . . . . . . . . .
Import Dependencies . . . . . . . . . . . . . . . . . . . . . . . .
Agent Management Through AgentSet . . . . . . . . . . . . . . .
Selecting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Group By . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Next Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Visualization - Basic Dashboard . . . . . . . . . . . . . . . . . .
The Boltzmann Wealth Model . . . . . . . . . . . . . . . . . . .
Tutorial Description . . . . . . . . . . . . . . . . . . . . . . . . .
Import Dependencies . . . . . . . . . . . . . . . . . . . . . . . .
Basic Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Adding visualization . . . . . . . . . . . . . . . . . . . . . . . .
Grid Visualization . . . . . . . . . . . . . . . . . . . . . . . . . .
Next Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Visualization - Dynamic Agents . . . . . . . . . . . . . . . . . .
The Boltzmann Wealth Model . . . . . . . . . . . . . . . . . . .
Tutorial Description . . . . . . . . . . . . . . . . . . . . . . . . .
Import Dependencies . . . . . . . . . . . . . . . . . . . . . . . .

14
15
15
16
17
17
18
21
21
21
21
21
21
21
21
21
22
23
24
27
27
27
27
28
28
28
28
29
31
32
32
37
38
38
38
38
38
38
39
40
42
43
43
43
43
43
43
46
46
48
48
48
48
48

2.4.1.3.6.78
2.4.1.3.6.79
2.4.1.3.6.80
2.4.1.3.6.81
2.4.1.3.6.82
2.4.1.3.6.83
2.4.1.3.6.84
2.4.1.3.6.85
2.4.1.3.6.86
2.4.1.3.6.87
2.4.1.3.6.88
2.4.1.3.6.89
2.4.1.3.6.90
2.4.1.3.6.91
2.4.1.3.6.92
2.4.1.3.6.93
2.4.1.3.6.94
2.4.1.3.6.95
2.4.1.3.6.96
2.4.1.3.6.97
2.4.1.3.6.98
2.4.1.3.6.99
2.4.1.3.6.100
2.4.1.3.6.101
2.4.1.3.6.102
2.4.1.3.6.103
2.4.1.3.6.104
2.4.1.3.6.105
2.4.1.3.6.106
2.4.1.3.6.107
2.4.1.3.6.108
2.4.1.3.6.109
2.4.1.3.6.110
2.4.1.3.6.111
2.4.1.3.6.112
2.4.1.3.6.113

Basic Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Adding visualization . . . . . . . . . . . . . . . . . . . . . . . .
Dynamic Agent Representation . . . . . . . . . . . . . . . . . . .
Exercise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Next Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Visualization - Custom Components . . . . . . . . . . . . . . . .
The Boltzmann Wealth Model . . . . . . . . . . . . . . . . . . .
Tutorial Description . . . . . . . . . . . . . . . . . . . . . . . . .
Import Dependencies . . . . . . . . . . . . . . . . . . . . . . . .
Basic Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Adding visualization . . . . . . . . . . . . . . . . . . . . . . . .
Building Custom Components . . . . . . . . . . . . . . . . . . .
Exercise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Next Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
BatchRunner . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
The Boltzmann Wealth Model . . . . . . . . . . . . . . . . . . .
Tutorial Description . . . . . . . . . . . . . . . . . . . . . . . . .
IN COLAB? - Run the next cell . . . . . . . . . . . . . . . . . . .
Import Dependencies . . . . . . . . . . . . . . . . . . . . . . . .
Base Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Batch Run . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Batch run parameters . . . . . . . . . . . . . . . . . . . . . . . .
Batch Run Analysis and Visualization . . . . . . . . . . . . . . .
Next Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Comparing Scenarios . . . . . . . . . . . . . . . . . . . . . . . .
The Boltzmann Wealth Model . . . . . . . . . . . . . . . . . . .
Tutorial Description . . . . . . . . . . . . . . . . . . . . . . . . .
IN COLAB? - Run the next cell . . . . . . . . . . . . . . . . . . .
Import Dependencies . . . . . . . . . . . . . . . . . . . . . . . .
Base Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Analyzing model reporters: Comparing 5 scenarios . . . . . . . .
Exercise: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Analyzing agent reporters: Comparing 5 scenarios . . . . . . . . .
General steps for analyzing results . . . . . . . . . . . . . . . . .
Exercise: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
That is it you have successfully completed Mesa’s Introductory Tutorial! . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.114 More Mesa . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.115 Happy Modeling! . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.116 Best Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.117 Model Layout . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.1.3.6.118 Randomization . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2
Mesa Core Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.1 Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.2 Basic Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.2.1
Boltzmann Wealth Model . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.2.2
Boids Flockers Model . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.2.3
Conway’s Game of Life . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.2.4
Schelling Segregation Model . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.2.5
Virus on a Network Model . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3 Advanced Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.1
Epstein Civil Violence Model . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.2
Demographic Prisoner’s Dilemma on a Grid . . . . . . . . . . . . . . . .
2.4.2.3.3
Sugarscape Model with Traders . . . . . . . . . . . . . . . . . . . . . . .

49
51
51
53
53
53
53
53
53
54
56
56
58
58
58
58
58
59
59
59
61
61
62
65
65
65
65
66
66
66
68
70
70
71
71
72
72
72
72
72
73
73
74
74
74
74
74
74
74
74
74
74
75
iii

2.4.2.3.4
Wolf-Sheep Predation Model . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.1
Schelling Segregation Model . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.2
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.3
How to Run . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.4
Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.5
Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.6
Agents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.7
Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.8
App . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.9
Boids Flockers . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.10 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.11 How to Run . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.12 Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.13 Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.14 Agents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.15 Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.16 App . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.17 Virus on a Network . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.18 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.19 Installation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.20 How to Run . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.21 Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.22 Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.23 Agents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.24 Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.25 App . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.26 Boltzmann Wealth Model (Tutorial) . . . . . . . . . . . . . . . .
2.4.2.3.4.27 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.28 How to Run . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.29 Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.30 Optional . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.31 Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.32 Agents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.33 Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.34 App . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.35 Conway’s Game Of “Life” . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.36 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.37 How to Run . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.38 Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.39 Optional . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.40 Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.41 Agents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.42 Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.43 App . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.44 Epstein Civil Violence Model . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.45 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.46 How to Run . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.47 Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.48 Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.49 Agents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.50 Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.51 App . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.52 Alliance Formation Model (Meta-Agent Example) . . . . . . . . .
2.4.2.3.4.53 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
iv

75
75
75
75
75
75
76
76
78
79
79
79
79
79
80
81
84
85
85
86
86
86
86
86
87
89
92
92
92
92
92
92
93
93
95
97
97
97
97
97
97
97
98
99
101
101
101
101
101
101
105
107
109
109

2.4.2.3.4.54 Installation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.55 How to Run . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.56 Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.57 Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.58 Agents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.59 Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.60 App . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.61 Demographic Prisoner’s Dilemma on a Grid . . . . . . . . . . . .
2.4.2.3.4.62 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.63 How to Run . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.64 Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.65 Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.66 Agents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.67 Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.68 App . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.69 Wolf-Sheep Predation Model . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.70 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.71 How to Run . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.72 Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.73 Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.74 Agents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.75 Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.76 App . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.77 Sugarscape Constant Growback Model with Traders . . . . . . . .
2.4.2.3.4.78 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.79 Agents: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.80 How to Run . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.81 Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.82 Further Reading . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.83 Agents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.84 Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.2.3.4.85 App . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3
Mesa Migration guide . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1 Mesa 3.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.1
Upgrade strategy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.2
Reserved and private variables . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.2.1
Reserved variables . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.2.2
Private variables . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.3
Removal of mesa.flat namespace . . . . . . . . . . . . . . . . . . . .
2.4.3.1.4
Mandatory Model initialization with super().__init__() . . . . . . .
2.4.3.1.5
Automatic assignment of unique_id to Agents . . . . . . . . . . . . . .
2.4.3.1.6
AgentSet and Model.agents . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.6.1
Model.agents . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.7
Time and schedulers . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.7.1
Automatic increase of the steps counter . . . . . . . . . . . . . .
2.4.3.1.7.2
Removal of Model._time and rename ._steps . . . . . . . . .
2.4.3.1.7.3
Removal of Model._advance_time() . . . . . . . . . . . . . .
2.4.3.1.7.4
Replacing Schedulers with AgentSet functionality . . . . . . . . .
2.4.3.1.7.5
BaseScheduler . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.7.6
RandomActivation . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.7.7
SimultaneousActivation . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.7.8
StagedActivation . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.7.9
RandomActivationByType . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.7.10 Replacing step_type . . . . . . . . . . . . . . . . . . . . . . .

109
109
109
110
110
110
114
115
115
116
116
116
116
117
119
120
120
120
120
121
121
124
127
129
129
129
130
130
130
130
136
139
140
141
141
141
141
141
141
141
142
142
143
143
143
143
143
143
143
144
144
144
144
145
v

2.4.3.1.7.11 General Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.8
Visualisation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.8.1
Model Initialization . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.9
Model Initialization with Keyword Arguments . . . . . . . . . . . . . . .
2.4.3.1.9.1
Default space visualization . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.9.2
Plotting “measures” . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.9.3
Plotting text . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.10 Other changes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.3.1.10.1 Removal of Model.initialize_data_collector . . . . . . . . . . . .
2.4.4
APIs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.4.1 Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.4.2 Agent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.4.3 Spaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.4.3.1
Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.4.4 Discrete Space . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.4.5 Data collection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.4.6 Batchrunner . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.4.7 Visualization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.4.7.1
Jupyter Visualization . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.4.7.2
User Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.4.7.3
Matplotlib-based visualizations . . . . . . . . . . . . . . . . . . . . . . .
2.4.4.7.4
Altair-based visualizations . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.4.7.5
Command Console . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.4.8 Experimental . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.4.8.1
Devs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.4.8.2
Continuous Space . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4.4.8.3
Continuous Space . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3

145
145
146
146
146
146
147
147
147
147
147
149
157
157
178
198
200
201
201
203
204
208
208
211
211
217
219

Indices and tables

223

Python Module Index

225

Index

227

vi

Mesa Documentation, Release .1

Mesa is an Apache2 licensed agent-based modeling (or ABM) framework in Python.
Mesa allows users to quickly create agent-based models using built-in core components (such as spatial grids and agent
schedulers) or customized implementations; visualize them using a browser-based interface; and analyze their results
using Python’s data analysis tools. Mesa’s goal is to make simulations accessible to everyone, so humanity can more
effectively understand and solve complex problems.

A visualisation of the Wolf Sheep model build with Mesa.

CONTENTS

1

Mesa Documentation, Release .1

2

CONTENTS

CHAPTER

ONE

FEATURES

• Built-in core modeling components
• Flexible agent and model management through AgentSet
• Browser-based Solara visualization
• Built-in tools for data collection and analysis
• Example model library

3

Mesa Documentation, Release .1

4

Chapter 1. Features

CHAPTER

TWO

USING MESA

2.1 Installation Options
To install our latest stable release, run:
pip install -U mesa
To also install our recommended dependencies:
pip install -U mesa[rec]
The [rec] option installs additional recommended dependencies needed for visualization, plotting, and network modeling capabilities.
On a Mac, this command might cause an error stating zsh:
the command to pip install -U "mesa[rec]".

no matches found:

mesa[all]. In that case, change

2.2 Resources
For help getting started with Mesa, check out these resources:
• Getting started - Learn about Mesa’s core concepts and components
• Migration Guide - Upgrade to Mesa 3.0
• Mesa Examples - Browse user-contributed models and implementations
• Mesa Extensions - Overview of mesa’s Extensions
• GitHub Discussions - Ask questions and discuss Mesa
• Matrix Chat Room - Real-time chat with the Mesa community

2.3 Development and Support
Mesa is an open source project and welcomes contributions:
• GitHub Repository - Access the source code
• Issue Tracker - Report bugs or suggest features
• Contributors Guide - Learn how to contribute

5

Mesa Documentation, Release .1

2.4 Citing Mesa
To cite Mesa in your publication, you can refer to our peer-reviewed article in the Journal of Open Source Software
(JOSS):
• ter Hoeven, E., Kwakkel, J., Hess, V., Pike, T., Wang, B., rht, & Kazil, J. (2025). Mesa 3: Agent-based modeling
with Python in 2025. Journal of Open Source Software, 10(107), 7668. https://doi.org/10.21105/joss.07668
Our CITATION.cff can be used to generate APA, BibTeX and other citation formats.
The original Mesa conference paper from 2015 is available here.

2.4.1 Getting started
Mesa is a modular framework for building, analyzing and visualizing agent-based models.
Agent-based models are computer simulations involving multiple entities (the agents) acting and interacting with
one another based on their programmed behavior. Agents can be used to represent living cells, animals, individual
humans, even entire organizations or abstract entities. Sometimes, we may have an understanding of how the individual
components of a system behave, and want to see what system-level behaviors and effects emerge from their interaction.
Other times, we may have a good idea of how the system overall behaves, and want to figure out what individual
behaviors explain it. Or we may want to see how to get agents to cooperate or compete most effectively. Or we may
just want to build a cool toy with colorful little dots moving around.
2.4.1.1 Tutorials
If you want to get a quick start on how to build agent based models with MESA, check the overview and tutorials:
• Overview of the MESA library: Learn about the core concepts and components of Mesa.
• Creating Your First Model: Learn how to create your first Mesa model.
• Adding Space: Learn how to add space to your Mesa model and understand Mesa’s space architecture.
• Collecting Data: Learn how to collect model level and agent level data with Mesa’ DataCollector.
• AgentSet: Learn how to more effectively manage agents with Mesa’s AgentSet.
• Basic Visualization: Learn how to build an interactive dashboard with Mesa’s visualization module.
• Dynamic Agent Visualization: Learn how to dynamically represent your agents in your interactive dashboard.
• Custom Visualization Components: Learn how to add custom visual components to your interactive dashboard.
• Parameter Sweeps: Learn how to conduct parameter sweeps on multiple processors with Mesa’s BatchRunner.
• Comparing Scenarios: Think through how to analyze your parameter sweep results to find insight in your Mesa
simulations.
2.4.1.2 Examples
Mesa ships with a collection of example models. These are classic ABMs, so if you are familiar with ABMs and want
to get a quick sense of how MESA works, these examples are great place to start. You can find them here.
2.4.1.3 Further resources
To further explore Mesa and its features, we have the following resources available:

6

Chapter 2. Using Mesa

Mesa Documentation, Release .1

2.4.1.3.1 Best practices
• Mesa best practices: an overview of tips and guidelines for using MESA.
2.4.1.3.2 API documentation
• Mesa API reference: Detailed documentation of Mesa’s classes and functions.
2.4.1.3.3 Repository of models built using MESA
• Mesa Examples repository: A collection of example models demonstrating various Mesa features and modeling
techniques.
2.4.1.3.4 Migration guide
• Mesa 3.0 Migration guide: If you’re upgrading from an earlier version of Mesa, this guide will help you navigate
the changes in Mesa 3.0.
2.4.1.3.5 Source Ccode and development
• Mesa GitHub repository: Access the full source code of Mesa, contribute to its development, or report issues.
• Mesa release notes: View the detailed changelog of Mesa, including all past releases and their features.
2.4.1.3.6 Community and support
• Mesa GitHub Discussions: Join discussions, ask questions, and connect with other Mesa users.
• Matrix Chat: Real-time chat for quick questions and community interaction.
Enjoy modelling with Mesa, and feel free to reach out!
2.4.1.3.6.1 Overview of the MESA library
Mesa is modular, meaning that its modeling, analysis and visualization components are kept separate but intended to
work together. The modules are grouped into three categories:
1. Modeling: Classes used to build the models themselves: a model and agent classes, space for them to move
around in, and built-in functionality for managing agents.
2. Analysis: Tools to collect data generated from your model, or to run it multiple times with different parameter
values.
3. Visualization: Classes to create and launch an interactive model visualization, using a browser-based interface.
2.4.1.3.6.2 Modeling modules
Most models consist of one class to represent the model itself and one or more classes for agents. Mesa provides built-in
functionality for managing agents and their interactions. These are implemented in Mesa’s modeling modules:
• mesa.model
• mesa.agent
• mesa.space
The skeleton of a model might look like this:

2.4. Citing Mesa

7

Mesa Documentation, Release .1

import mesa
class MyAgent(mesa.Agent):
def __init__(self, model, age):
super().__init__(model)
self.age = age
def step(self):
self.age += 1
print(f"Agent {self.unique_id} now is {self.age} years old")
# Whatever else the agent does when activated
class MyModel(mesa.Model):
def __init__(self, n_agents):
super().__init__()
self.grid = mesa.space.MultiGrid(10, 10, torus=True)
for _ in range(n_agents):
initial_age = self.random.randint(0, 80)
a = MyAgent(self, initial_age)
coords = (self.random.randrange(0, 10), self.random.randrange(0, 10))
self.grid.place_agent(a, coords)
def step(self):
self.agents.shuffle_do("step")
2.4.1.3.6.3 Spaces in Mesa
Mesa provides several types of spaces where agents can exist and interact:
2.4.1.3.6.4 Discrete Spaces
Mesa implements discrete spaces using a doubly-linked structure where each cell maintains connections to its neighbors. Available variants include:
1. Grid-based Spaces:
# Create a Von Neumann grid (4 neighbors per cell)
grid = mesa.space.OrthogonalVonNeumannGrid((width, height), torus=False)
# Create a Moore grid (8 neighbors per cell)
grid = mesa.space.OrthogonalMooreGrid((width, height), torus=True)
# Create a hexagonal grid
grid = mesa.space.HexGrid((width, height), torus=False)
2. Network Space:
# Create a network-based space
network = mesa.space.NetworkGrid(network)
3. Voronoi Space:
# Create an irregular tessellation
mesh = mesa.space.VoronoiMesh(points)

8

Chapter 2. Using Mesa

Mesa Documentation, Release .1

2.4.1.3.6.5 Property Layers
Discrete spaces support PropertyLayers - efficient numpy-based arrays for storing cell-level properties:
# Create and use a property layer
grid.create_property_layer("elevation", default_value=10)
high_ground = grid.elevation.select_cells(lambda x: x > 50)
2.4.1.3.6.6 Continuous Space
For models requiring continuous movement:
# Create a continuous space
space = mesa.space.ContinuousSpace(x_max, y_max, torus=True)
# Move an agent to specific coordinates
space.move_agent(agent, (new_x, new_y))
2.4.1.3.6.7 Time Advancement and Agent Activation
Mesa supports multiple approaches to advancing time and activating agents:
2.4.1.3.6.8 Basic Time Steps
The simplest approach runs the model for a specified number of steps:
model = MyModel(seed=42)
for _ in range(100):
model.step()
2.4.1.3.6.9 Agent Activation Patterns
Mesa 3.0 provides flexible agent activation through the AgentSet API:
# Sequential activation
model.agents.do("step")
# Random activation
model.agents.shuffle_do("step")
# Multi-stage activation
for stage in ["move", "eat", "reproduce"]:
model.agents.do(stage)
# Activation by agent type
for klass in model.agent_types:
model.agents_by_type[klass].do("step")
2.4.1.3.6.10 Event-Based Scheduling
Mesa also supports event-based time progression (experimental):

2.4. Citing Mesa

9

Mesa Documentation, Release .1

# Pure event-based
simulator = mesa.experimental.DiscreteEventSimulator()
model = MyModel(seed=42, simulator=simulator)
simulator.schedule_event_relative(some_function, 3.1415)
# Hybrid time-step and event scheduling
model = MyModel(seed=42, simulator=mesa.experimental.ABMSimulator())
model.simulator.schedule_event_next_tick(some_function)
2.4.1.3.6.11 AgentSet and model.agents
Mesa 3.0 makes model.agents and the AgentSet class central in managing and activating agents.
2.4.1.3.6.12 model.agents
model.agents is an AgentSet containing all agents in the model. It’s automatically updated when agents are added
or removed:
# Get total number of agents
num_agents = len(model.agents)
# Iterate over all agents
for agent in model.agents:
print(agent.unique_id)
2.4.1.3.6.13 AgentSet Functionality
AgentSet offers several methods for efficient agent management:
1. Selecting: Filter agents based on criteria.
high_energy_agents = model.agents.select(lambda a: a.energy > 50)
2. Shuffling and Sorting: Randomize or order agents.
shuffled_agents = model.agents.shuffle()
sorted_agents = model.agents.sort(key="energy", ascending=False)
3. Applying methods: Execute methods on all agents.
model.agents.do("step")
model.agents.shuffle_do("move")

# Shuffle then apply method

4. Aggregating: Compute aggregate values across agents.
avg_energy = model.agents.agg("energy", func=np.mean)
5. Grouping: Group agents by attributes.
grouped_agents = model.agents.groupby("species")
for _, agent_group in grouped_agents:
agent_group.shuffle_do()
(continues on next page)

10

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

species_counts = grouped_agents.count()
mean_age_by_group = grouped_agents.agg("age", np.mean)
model.agents can also be accessed within a model instance using self.agents.
These are just some examples of using the AgentSet, there are many more possibilities, see the AgentSet API docs.
2.4.1.3.6.14 Analysis modules
If you’re using modeling for research, you’ll want a way to collect the data each model run generates. You’ll probably
also want to run the model multiple times, to see how some output changes with different parameters. Data collection
and batch running are implemented in the appropriately-named analysis modules:
• mesa.datacollection
• mesa.batchrunner
You’d add a data collector to the model like this:
import mesa
import numpy as np
# ...
class MyModel(mesa.Model):
def __init__(self, n_agents):
super().__init__()
# ... (model initialization code)
self.datacollector = mesa.DataCollector(
model_reporters={"mean_age": lambda m: m.agents.agg("age", np.mean)},
agent_reporters={"age": "age"}
)
def step(self):
self.agents.shuffle_do("step")
self.datacollector.collect(self)
The data collector will collect the specified model- and agent-level data at each step of the model. After you’re done
running it, you can extract the data as a pandas DataFrame:
model = MyModel(5)
for t in range(10):
model.step()
model_df = model.datacollector.get_model_vars_dataframe()
agent_df = model.datacollector.get_agent_vars_dataframe()
To batch-run the model while varying, for example, the n_agents parameter, you’d use the batch_run function:
import mesa
parameters = {"n_agents": range(1, 6)}
results = mesa.batch_run(
MyModel,
parameters,
iterations=5,
(continues on next page)

2.4. Citing Mesa

11

Mesa Documentation, Release .1

(continued from previous page)

max_steps=100,
data_collection_period=1,
number_processes=1 # Change to use multiple CPU cores for parallel execution
)
The results are returned as a list of dictionaries, which can be easily converted to a pandas DataFrame for further
analysis.
2.4.1.3.6.15 Visualization
Mesa now uses a new browser-based visualization system called SolaraViz. This allows for interactive, customizable
visualizations of your models.
Note: SolaraViz is experimental and still in active development in Mesa 3.x. While we attempt to minimize them, there
might be API breaking changes in minor releases.
Note: SolaraViz instantiates new models using **model_parameters.value, so all model inputs must
be keyword arguments.
Ensure your model’s __init__ method accepts keyword arguments matching the model_params keys.
class MyModel(Model):
def __init__(self, n_agents=10, seed=None):
super().__init__(seed=seed)
# Initialize the model with N agents
The core functionality for building your own visualizations resides in the mesa.visualization namespace.
Here’s a basic example of how to set up a visualization:
from mesa.visualization import SolaraViz, make_space_component, make_plot_component

def agent_portrayal(agent):
return {"color": "blue", "size": 50}

model_params = {
"N": {
"type": "SliderInt",
"value": 50,
"label": "Number of agents:",
"min": 10,
"max": 100,
"step": 1,
}
}
page = SolaraViz(
MyModel,
[
make_space_component(agent_portrayal),
make_plot_component("mean_age")
],
(continues on next page)

12

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

model_params=model_params
)
page
This will create an interactive visualization of your model, including:
• A grid visualization of agents
• A plot of a model metric over time
• A slider to adjust the number of agents
2.4.1.3.6.16 Creating Your First Model
2.4.1.3.6.17 The Boltzmann Wealth Model
Important:
• If you are just exploring Mesa and want the fastest way to execute the code we recommend executing this tutorial
online in a Colab notebook. or if you do not have a Google account you can use 0_first_model.ipynb) (This can
take 30 seconds to 5 minutes to load)
• If you are running locally, please ensure you have the latest Mesa version installed.
2.4.1.3.6.18 Tutorial Description
Mesa is a Python framework for agent-based modeling. This tutorial is the first in a series of introductory tutorials that
will assist you in getting started and discover some of the core features of Mesa. The tutorial starts with the key pieces
of a model and then progressively adds functionality.
Should anyone find any errors, bugs, have a suggestion, or just are looking for clarification, let us know in our chat!
The premise of this tutorial is to create a starter-level model representing agents exchanging money.
2.4.1.3.6.19 Model Description
This is a simulated agent-based economy. In an agent-based economy, the behavior of an individual economic agent,
such as a consumer or producer, is studied in a market environment. This model is drawn from the field econophysics,
specifically a paper prepared by Drăgulescu et al. for additional information on the modeling assumptions used in this
model. [Drăgulescu, 2002].
The assumption that govern this model are:
1. There are some number of agents.
2. All agents begin with 1 unit of money.
3. At every step of the model, an agent gives 1 unit of money (if they have it) to some other agent.
Even as a starter-level model it yields results that are both interesting and unexpected.
Due to its simplicity and intriguing results, we found it to be a good starter model.
2.4.1.3.6.20 Tutorial Setup
Create and activate a virtual environment. Python version 3.11 or higher is required.
Install Mesa:

2.4. Citing Mesa

13

Mesa Documentation, Release .1

pip install mesa[rec]
Install Jupyter notebook (optional):
pip install jupyter
Install Seaborn (which is used for data visualization):
pip install seaborn
2.4.1.3.6.21 IN COLAB? - Run the next cell
2.4.1.3.6.22 Building the Sample Model
After Mesa is installed a model can be built.
This tutorial is written in Jupyter to facilitate the explanation portions.
Start Jupyter form the command line:
jupyter lab
Create a new notebook named money_model.ipynb (or whatever you want to call it).
2.4.1.3.6.23 Import Dependencies
This includes importing of dependencies needed for the tutorial.
# Has multi-dimensional arrays and matrices.
# Has a large collection of mathematical functions to operate on these arrays.
import numpy as np
# Data manipulation and analysis.
import pandas as pd
# Data visualization tools.
import seaborn as sns
import mesa
2.4.1.3.6.24 Create Agent
First create the agent. As the tutorial progresses, more functionality will be added to the agent.
Background: Agents are the individual entities that act in the model. Mesa automatically assigns each agent that is
created an integer as a unique_id.
Model-specific information: Agents are the individuals that exchange money, in this case the amount of money an
individual agent has is represented as wealth.
Code implementation: This is done by creating a new class (or object) that extends mesa.Agent creating a subclass
of the Agent class from mesa. The new class is named MoneyAgent. The inherited code of the Mesa agent object can
be found in the mesa repo.
The MoneyAgent class is created with the following code:

14

Chapter 2. Using Mesa

Mesa Documentation, Release .1

class MoneyAgent(mesa.Agent):
"""An agent with fixed initial wealth."""
def __init__(self, model):
# Pass the parameters to the parent class.
super().__init__(model)
# Create the agent's variable and set the initial values.
self.wealth = 1
2.4.1.3.6.25 Create Model
Next, create the model. This gives us the two basic classes of any Mesa ABM - the agent class (population of agent objects that doing something) and the manager class (a model object that manages the creation, activation, datacollection
etc of the agents)
Background: The model can be visualized as a list containing all the agents. The model creates, holds and manages
all the agent objects, specifically in a dictionary. The model activates agents in discrete time steps.
Model-specific information: When a model is created the number of agents within the model is specified. The model
then creates the agents and places them in a set of agents.
Code implementation: This is done by creating a new class (or object) that extends mesa.Model and calls super().
__init__(), creating a subclass of the Model class from mesa. The new class is named MoneyModel. The Mesa code
you are using can be found in model module and the AgentSet in the agent module. A critical point is that you can
use the seed kwarg (keyword argument) to set a seed which controls the random number generator of the model class
allowing for the reproducibility of results.
The MoneyModel class is created with the following code:
class MoneyModel(mesa.Model):
"""A model with some number of agents."""
def __init__(self, n, seed=None):
super().__init__(seed=seed)
self.num_agents = n
# Create agents
MoneyAgent.create_agents(model=self, n=n)
2.4.1.3.6.26 Making the Agents do
With the basics of the Agent class and Model class created we can now activate the agents to do things
Background: Mesa’s do function calls agent functions to grow your ABM. A step is the smallest unit of time in the
model, and is often referred to as a tick. The do function and Python functionality can be configured to activate agents
in different orders. This can be important as the order in which agents are activated can impact the results of the model
[Comer2014]. At each step of the model, one or more of the agents – usually all of them – are activated and take their
own step, changing internally and/or interacting with one another or the environment.
Model-specific information: For this section we will randomly reorder the Agent activation order using mesa.Agent.
shuffle_do and have the agents step function print the agent’s unique id that they were assigned during the agent
creation process.
Code implementation: Using standard ABM convention we add a step function to the MoneyModel class which calls
the mesa.Agent.shuffle_do function. We then pass into shuffle_do the parameter “step”. This tells mesa to look
for and execute the step function in our MoneyAgent class.

2.4. Citing Mesa

15

Mesa Documentation, Release .1

class MoneyAgent(mesa.Agent):
"""An agent with fixed initial wealth."""
def __init__(self, model):
# Pass the parameters to the parent class.
super().__init__(model)
# Create the agent's attribute and set the initial values.
self.wealth = 1
def say_hi(self):
# The agent's step will go here.
# For demonstration purposes we will print the agent's unique_id
print(f"Hi, I am an agent, you can call me {self.unique_id!s}.")

class MoneyModel(mesa.Model):
"""A model with some number of agents."""
def __init__(self, n, seed=None):
super().__init__(seed=seed)
self.num_agents = n
# Create n agents
MoneyAgent.create_agents(model=self, n=n)
def step(self):
"""Advance the model by one step."""
# This function psuedo-randomly reorders the list of agent objects and
# then iterates through calling the function passed in as the parameter
self.agents.shuffle_do("say_hi")
2.4.1.3.6.27 Running the Model
We now have the pieces of a basic model. The model can be run by creating a model object and calling the step method.
The model will run for one step and print the unique_id of each agent. You may run the model for multiple steps by
calling the step method multiple times.
Create the model object, and run it for one step:
starter_model = MoneyModel(10)
starter_model.step()
Hi, I am an agent, you can call me 5.
Hi, I am an agent, you can call me 4.
Hi, I am an agent, you can call me 6.
Hi, I am an agent, you can call me 2.
Hi, I am an agent, you can call me 1.
Hi, I am an agent, you can call me 9.
Hi, I am an agent, you can call me 7.
Hi, I am an agent, you can call me 10.
Hi, I am an agent, you can call me 3.
Hi, I am an agent, you can call me 8.

16

Chapter 2. Using Mesa

Mesa Documentation, Release .1

# Run this step a few times and see what happens!
starter_model.step()
# Notice the order of the agents changes each time.
Hi, I am an agent, you can call me 9.
Hi, I am an agent, you can call me 4.
Hi, I am an agent, you can call me 2.
Hi, I am an agent, you can call me 3.
Hi, I am an agent, you can call me 8.
Hi, I am an agent, you can call me 6.
Hi, I am an agent, you can call me 10.
Hi, I am an agent, you can call me 5.
Hi, I am an agent, you can call me 7.
Hi, I am an agent, you can call me 1.
# Challenge: Change the seed from None to a number like 42 and see the impact
# Challenge: Change `shuffle_do` to just `do` and see the impact
2.4.1.3.6.28 Exercise
Modifying the code below to have every agent print out its wealth when it is activated.
class MoneyAgent(mesa.Agent):
"""An agent with fixed initial wealth."""
def __init__(self, model):
# Pass the parameters to the parent class.
super().__init__(model)
# Create the agent's variable and set the initial values.
self.wealth = 1
def say_wealth(self):
# The agent's step will go here.
# FIXME: need to print the agent's wealth
print("Hi, I am an agent and I am broke!")
Create a model for 12 Agents, and run it for a few steps to see the output.
# Fixme: Create the model object, and run it
2.4.1.3.6.29 Agents Exchange
Returning back to the MoneyAgent the actual exchange process is now going to be created.
Background: This is where the agent’s behavior as it relates to each step or tick of the model is defined.
Model-specific information: In this case, the agent will check its wealth, and if it has money, give one unit of it away
to another random agent.
Code implementation: The agent’s step method is called by mesa.Agent.shuffle_do("exchange")during each
step of the model. To allow the agent to choose another agent at random, we use the model.random random-number

2.4. Citing Mesa

17

Mesa Documentation, Release .1

generator. This works just like Python’s random module, but if a fixed seed is set when the model is instantiated (see
earlier challenge), this allows users to replicate a specific model run later. Once we identify this other agent object we
increase their wealth by 1 and decrease this agents wealth by one.
This updates the step function as shown below:
class MoneyAgent(mesa.Agent):
"""An agent with fixed initial wealth."""
def __init__(self, model):
# Pass the parameters to the parent class.
super().__init__(model)
# Create the agent's variable and set the initial values.
self.wealth = 1
def exchange(self):
# Verify agent has some wealth
if self.wealth > 0:
other_agent = self.random.choice(self.model.agents)
if other_agent is not None:
other_agent.wealth += 1
self.wealth -= 1

class MoneyModel(mesa.Model):
"""A model with some number of agents."""
def __init__(self, n):
super().__init__()
self.num_agents = n
# Create agents
MoneyAgent.create_agents(model=self, n=n)
def step(self):
"""Advance the model by one step."""
# This function psuedo-randomly reorders the list of agent objects and
# then iterates through calling the function passed in as the parameter
self.agents.shuffle_do("exchange")
2.4.1.3.6.30 Running your first model
With exchange behavior added, it’s time for the first rudimentary run of the model.
Now let’s create a model with 10 agents, and run it for 30 steps.
model = MoneyModel(10) # Tells the model to create 10 agents
for _ in range(30): # Runs the model for 30 steps;
model.step()
# Note: An underscore is common convention for a variable that is not used.
Next, we need to get some data out of the model. Specifically, we want to see the distribution of the agent’s wealth.

18

Chapter 2. Using Mesa

Mesa Documentation, Release .1

We can get the wealth values with list comprehension, and then use seaborn (or another graphics library) to visualize
the data in a histogram.
agent_wealth = [a.wealth for a in model.agents]
# Create a histogram with seaborn
g = sns.histplot(agent_wealth, discrete=True)
g.set(
title="Wealth distribution", xlabel="Wealth", ylabel="number of agents"
); # The semicolon is just to avoid printing the object representation

To get a better idea of how a model behaves, we can create multiple model objects and see the distribution that emerges
from all of them.
We can do this with a nested for loop:
all_wealth = []
# This runs the model 100 times, each model executing 10 steps.
for _ in range(100):
# Run the model
model = MoneyModel(10)
for _ in range(30):
model.step()
# Store the results
for agent in model.agents:
all_wealth.append(agent.wealth)
(continues on next page)

2.4. Citing Mesa

19

Mesa Documentation, Release .1

(continued from previous page)

# Use seaborn
g = sns.histplot(all_wealth, discrete=True)
g.set(title="Wealth distribution", xlabel="Wealth", ylabel="number of agents");

This runs 100 instantiations of the model, and runs each for 30 steps.
Notice that we set the histogram bins to be integers (discrete=True), since agents can only have whole numbers of
wealth.
This distribution looks a lot smoother. By running the model 100 times, we smooth out some of the ‘noise’ of randomness, and get to the model’s overall expected behavior.
This outcome might be surprising. Despite the fact that all agents, on average, give and receive one unit of money every
step, the model converges to a state where most agents have a small amount of money and a small number have a lot of
money.

20

Chapter 2. Using Mesa

Mesa Documentation, Release .1

2.4.1.3.6.31 Exercise
Change the above code to see the impact of different model runs, agent populations, and number of steps.
2.4.1.3.6.32 Next Steps
Check out the adding space tutorial on how to build interactive dashboards for your models.
2.4.1.3.6.33 More Mesa
If you are looking for other Mesa models or tools here are some additional resources.
• Example ABMs: Find canonical examples and examples of ABMs demonstrating highlighted features in the
Examples Tab
• Expanded Examples: Want to integrate Reinforcement Learning or work on the Traveling Salesman Problem?
Checkout Mesa Examples
• Mesa-Geo: If you need an ABM with Geographic Information Systems (GIS) checkout Mesa-Geo
• Mesa Frames: Have a large complex model that you need to speed up, check out Mesa Frames
2.4.1.3.6.34 Happy Modeling!
This document is a work in progress. If you see any errors, exclusions or have any problems please contact us.
[Comer2014] Comer, Kenneth W. “Who Goes First?
An Examination of the Impact of Activation on Outcome Behavior in AgentBased Models.” George Mason University,
2014.
http://mars.gmu.edu/bitstream/handle/1920/9070/Comer_gmu_0883E_10539.pdf
[Dragulescu2002] Drăgulescu, Adrian A., and Victor M. Yakovenko. “Statistical Mechanics of Money, Income, and
Wealth: A Short Survey.” arXiv Preprint Cond-mat/0211175, 2002. http://arxiv.org/abs/cond-mat/0211175.
2.4.1.3.6.35 Adding Space
2.4.1.3.6.36 The Boltzmann Wealth Model
If you want to get straight to the tutorial checkout these environment providers: (with Google Account) (no Google
Account) (This can take 30 seconds to 5 minutes to load)
If you are running locally, please ensure you have the latest Mesa version installed.
2.4.1.3.6.37 Tutorial Description
This tutorial extends the Boltzmann wealth model from the Running Your First Model tutorial, by adding Mesa’s
discrete space module.
In this portion, MoneyAgents will move in a two dimensional grid, made up of discrete cells and randomly exchange
money with other agents.
If you are starting here please see the Running Your First Model tutorial for dependency and start-up instructions
2.4.1.3.6.38 IN COLAB? - Run the next cell
2.4.1.3.6.39 Import Dependencies
This includes importing of dependencies needed for the tutorial.

2.4. Citing Mesa

21

Mesa Documentation, Release .1

# Has multi-dimensional arrays and matrices.
# Has a large collection of mathematical functions to operate on these arrays.
import numpy as np
# Data manipulation and analysis.
import pandas as pd
# Data visualization tools.
import seaborn as sns
import mesa
2.4.1.3.6.40 Base Model
The below provides the base model from which we will add our space functionality.
This is from the Running Your First Model tutorial tutorial. If you have any questions about it functionality please
review that tutorial.
class MoneyAgent(mesa.Agent):
"""An agent with fixed initial wealth."""
def __init__(self, model):
# Pass the parameters to the parent class.
super().__init__(model)
# Create the agent's variable and set the initial values.
self.wealth = 1
def exchange(self):
# Verify agent has some wealth
if self.wealth > 0:
other_agent = self.random.choice(self.model.agents)
if other_agent is not None:
other_agent.wealth += 1
self.wealth -= 1

class MoneyModel(mesa.Model):
"""A model with some number of agents."""
def __init__(self, n):
super().__init__()
self.num_agents = n
# Create agents
MoneyAgent.create_agents(model=self, n=n)
def step(self):
"""Advance the model by one step."""
# This function psuedo-randomly reorders the list of agent objects and
# then iterates through calling the function passed in as the parameter
self.agents.shuffle_do("exchange")

22

Chapter 2. Using Mesa

Mesa Documentation, Release .1

# Execute the model
model = MoneyModel(10)
model.step()
# Make sure it worked
print(f"You have {len(model.agents)} agents.")
You have 10 agents.
2.4.1.3.6.41 Adding space
Background: Due to the complex dynamics of space and movement, Mesa offers a wide range space options and has
built a structure to allow for the addition of even more spaces or custom user space creation. (Please contribute to Mesa
if you develop a new space that can add to user options.)
The two main approaches to space are discrete space (think cells or nodes that agents occupy) and continuous space
(agents can occupy any location(s) in a three-dimensional space). Continuous space is still experimental as we continue
to develop it.
Overview of Discrete Space: For this tutorial we will be using discrete space in the classic cartesian coordinated
system. As indicated in the diagram discrete space is made up of two modules. Cells and Cell Agents.
Cells: The cell class represents a location that can:
• Have properties (like temperature or resources)
• Track and limit the agents it contains
• Connect to neighboring cells
• Provide neighborhood information
Cells form the foundation of the cell space system, enabling rich spatial environments where both location properties and agent behaviors matter. They’re useful for modeling things like varying terrain, infrastructure capacity, or
environmental conditions.
Cell Agents: Agents that understand how to exist in and move through cell spaces.
Cell Agents are specialized agent classes that handle cell occupation, movement, and proper registration:
• CellAgent: Mobile agents that can move between cells
• FixedAgent: Immobile agents permanently fixed to cells
• Grid2DMovingAgent: Agents with grid-specific movement capabilities
These classes ensure consistent agent-cell relationships and proper state management as agents move through the space.
They can be used directly or as examples for creating custom cell-aware agents.
From these basic building blocks we can then add features to allow for different types of spaces and behaviors. To keep
this tutorial concise we will not go through all of them, however, the current layout of discrete space is below as well as
the different support modules. To find out more about the other options and what they can do, check out the Discrete
Space API

2.4. Citing Mesa

23

Mesa Documentation, Release .1

A big thanks to maintainer qualquel and his creation of this exceptional space dynamic.
Model-specific information: In addition to using discrete space, the agents will access their Moore neighborhood. A
Moore neighborhood means agents can interact with 8 neighbors. Instead of giving their unit of money to any random
agent, they’ll give it to an agent on the same cell. For the Money model multiple agents can be in the same spaces and
since they are on a torus the agents on the left side can exchange money with agent on the right. Agents on the top can
exchange with agents on the bottom.
2.4.1.3.6.42 Code Implementation
To ensure we give our agents discrete space functionality we now instantiate our MoneyAgents as CellAgents. Cell
Agent is a subclass to Mesa’s Agent class that is specifically built to interact and move within the discrete space
module.
Below highlights each of the changes to the base code to add space and movement of agents.
Imports # Import Cell Agent and OrthogonalMooreGrid
• Description: Import the cell agent class and a specific grid construct the OrthognalMooreGrid.
• API: CellAgent and OrthogonalMooreGrid
MoneyAgent Class # Instantiate MoneyAgent as CellAgent
• Description: MoneyAgent inherits CellAgent, a subclass of Agent.
• API: CellAgent
# Instantiate agent with location (x,y)
• Description: Pass the cell object as a parameter to the agent to give the agent a location
24

Chapter 2. Using Mesa

Mesa Documentation, Release .1

• API: N/A
# Move function
• Description: Update the agents cell through methods in Mesa’s discrete_space module neighborhood, which
defaults to radius one and select_random_cell which selects a random cell for the provided neighborhood
• API: neighborhood and select_random_cell
MoneyModel Class # Instantiate an instance of Moore neighborhood space
• Description: Instantiate a OrthgonalMooreGrid as self.grid with passing in the parameters width and height
as a tuple, torus as True, a cell capacity of 5 agents, and the models random seed to the discrete space
• API: OrthogonalMooreGrid
# Randomly select agents cell
• Description: Use Python’s random.choices and pass in all cells with discrete space all_cells properties and
the number of choices k to assign each agent a location.
• API: random.choices and all_cells
# Import Cell Agent and OrthogonalMooreGrid
from mesa.discrete_space import CellAgent, OrthogonalMooreGrid

# Instantiate MoneyAgent as CellAgent
class MoneyAgent(CellAgent):
"""An agent with fixed initial wealth."""
def __init__(self, model, cell):
super().__init__(model)
self.cell = cell # Instantiate agent with location (x,y)
self.wealth = 1
# Move Function
def move(self):
self.cell = self.cell.neighborhood.select_random_cell()
def give_money(self):
cellmates = [
a for a in self.cell.agents if a is not self
] # Get all agents in cell
if self.wealth > 0 and cellmates:
other_agent = self.random.choice(cellmates)
other_agent.wealth += 1
self.wealth -= 1

class MoneyModel(mesa.Model):
"""A model with some number of agents."""
def __init__(self, n, width, height, seed=None):
super().__init__(seed=seed)
self.num_agents = n
# Instantiate an instance of Moore neighborhood space
(continues on next page)

2.4. Citing Mesa

25

Mesa Documentation, Release .1

(continued from previous page)

self.grid = OrthogonalMooreGrid(
(width, height), torus=True, capacity=10, random=self.random
)
# Create agents
agents = MoneyAgent.create_agents(
self,
self.num_agents,
# Randomly select agents cell
self.random.choices(self.grid.all_cells.cells, k=self.num_agents),
)
def step(self):
self.agents.shuffle_do("move")
self.agents.do("give_money")
Let’s create a model with 100 agents on a 10x10 grid, and run it for 20 steps.
model = MoneyModel(100, 10, 10)
for _ in range(20):
model.step()
Now let’s use seaborn and numpy to visualize the number of agents residing in each cell. To do that, we create a numpy
array of the same size as the grid, filled with zeros.
Then again use all_cells to loop over every cell in the grid, giving us each cell’s position (cell coordinate attribute)
and its contents (cell agent attribute).
Cell API
agent_counts = np.zeros((model.grid.width, model.grid.height))
for cell in model.grid.all_cells:
agent_counts[cell.coordinate] = len(cell.agents)
# Plot using seaborn, with a visual size of 5x5
g = sns.heatmap(agent_counts, cmap="viridis", annot=True, cbar=False, square=True)
g.figure.set_size_inches(5, 5)
g.set(title="Number of agents on each cell of the grid");

26

Chapter 2. Using Mesa

Mesa Documentation, Release .1

2.4.1.3.6.43 Exercises
• Change the size of the grid
• Change the capacity of the cells
• Try a different grid space like OrthognalVonNeumann, Network, or Voronoi
2.4.1.3.6.44 Next Steps
Check out the collecting data tutorial on how to collect data form your model.
[Comer2014] Comer, Kenneth W. “Who Goes First?
An Examination of the Impact of Activation on Outcome Behavior in AgentBased Models.” George Mason University,
2014.
http://mars.gmu.edu/bitstream/handle/1920/9070/Comer_gmu_0883E_10539.pdf
[Dragulescu2002] Drăgulescu, Adrian A., and Victor M. Yakovenko. “Statistical Mechanics of Money, Income, and
Wealth: A Short Survey.” arXiv Preprint Cond-mat/0211175, 2002. http://arxiv.org/abs/cond-mat/0211175.
2.4.1.3.6.45 Collecting Data
2.4.1.3.6.46 The Boltzmann Wealth Model
If you want to get straight to the tutorial checkout these environment providers: (with Google Account) (No Google
Account) (This can take 30 seconds to 5 minutes to load)
If you are running locally, please ensure you have the latest Mesa version installed.

2.4. Citing Mesa

27

Mesa Documentation, Release .1

2.4.1.3.6.47 Tutorial Description
This tutorial extends the Boltzmann wealth model from the Adding Space tutorial, by adding Mesa’s data collection
module.
In this portion, we will collect both model level data and agent level data to better understand the dynamics of our
model.
If you are starting here please see the Running Your First Model tutorial for dependency and start-up instructions
2.4.1.3.6.48 IN COLAB? - Run the next cell
2.4.1.3.6.49 Import Dependencies
This includes importing of dependencies needed for the tutorial.
# Has multi-dimensional arrays and matrices.
# Has a large collection of mathematical functions to operate on these arrays.
import numpy as np
# Data manipulation and analysis.
import pandas as pd
# Data visualization tools.
import seaborn as sns
import mesa
# Import Cell Agent and OrthogonalMooreGrid
from mesa.discrete_space import CellAgent, OrthogonalMooreGrid
2.4.1.3.6.50 Base Model
The below provides the base model from which we will add our space functionality.
This is from the Adding Space tutorial tutorial. If you have any questions about it functionality please review that
tutorial.
class MoneyAgent(CellAgent):
"""An agent with fixed initial wealth."""
def __init__(self, model, cell):
super().__init__(model)
self.cell = cell # Instantiate agent with location (x,y)
self.wealth = 1
# Move Function
def move(self):
self.cell = self.cell.neighborhood.select_random_cell()
def give_money(self):
cellmates = [
a for a in self.cell.agents if a is not self
] # Get all agents in cell
(continues on next page)

28

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

if self.wealth > 0 and cellmates:
other_agent = self.random.choice(cellmates)
other_agent.wealth += 1
self.wealth -= 1

class MoneyModel(mesa.Model):
"""A model with some number of agents."""
def __init__(self, n, width, height, seed=None):
super().__init__(seed=seed)
self.num_agents = n
# Instantiate an instance of Moore neighborhood space
self.grid = OrthogonalMooreGrid(
(width, height), torus=True, capacity=10, random=self.random
)
# Create agents
agents = MoneyAgent.create_agents(
self,
self.num_agents,
# Randomly select agents cell
self.random.choices(self.grid.all_cells.cells, k=self.num_agents),
)
def step(self):
self.agents.shuffle_do("move")
self.agents.do("give_money")
Let’s create a model with 100 agents on a 10x10 grid, and run it for 20 steps to make sure our base model works.
model = MoneyModel(100, 10, 10)
for _ in range(20):
model.step()
# Let's make sure it worked
print(len(model.agents))
100
2.4.1.3.6.51 Collecting Data
Background: So far, at the end of every model run, we’ve had to go and write our own code to get the data out of the
model. This has two problems: it isn’t very efficient, and it only gives us end results. If we wanted to know the wealth
of each agent at each step, we’d have to add that to the loop of executing steps, and figure out some way to store the
data.
Since one of the main goals of agent-based modeling is generating data for analysis, Mesa provides a class which can
handle data collection and storage for us and make it easier to analyze.
The data collector stores three categories of data:
• Model-level variables : Model-level collection functions take a model object as an input. Such as a function that
computes a dynamic of the whole model (in this case we will compute a measure of wealth inequality based on
all agent’s wealth)
2.4. Citing Mesa

29

Mesa Documentation, Release .1

• Agent-level variables: Agent-level collection functions take an agent object as an input and is typically the state
of an agent attributes, in this case wealth.
• Tables (which are a catch-all for everything else).
Model-specific information: We will collect two variables to show Mesa capabilities.
• At the model level, let’s measure the model’s Gini Coefficient, a measure of wealth inequality.
• At the agent level, we want to collect every agent’s wealth at every step.
Code implementation:
Let’s add a DataCollector to the model with mesa.DataCollector, and collect the agent’s wealth and the gini coefficient at each time step. In the below code each new line of code is described with a comment. These additions are
described below.
Helper Function # Add function for model level collection -Description: Helper function used by the model class to
compute the gini coefficient as described previously. -API: N/A
MoneyModel Class # Instantiate DataCollector
• Description: Create a mesa data collector instance and use keyword arguments (kwargs) model_reporters and
agent_reporters to pass in a dictionary, where the key is the name of the data collected and the value is either
function (i.e. computer gini) or an attribute (i.e. “wealth”). If it is an attribute it is passed in as a string.
• API: Data Collection
# Collect data each step
• Description: Call the collect method from DataCollector. This causes the reporters to collect the data at
each step. If this is not put in the step function then the data collector will collect the described information at
the end of the model run. If you want to collect the data only on lets say the 5th step, then you can just add an
if statement to only collect on the fifth step.
• API: DataCollector.collect
# Add function for model level collection
def compute_gini(model):
agent_wealths = [agent.wealth for agent in model.agents]
x = sorted(agent_wealths)
n = model.num_agents
B = sum(xi * (n - i) for i, xi in enumerate(x)) / (n * sum(x))
return 1 + (1 / n) - 2 * B

class MoneyAgent(CellAgent):
"""An agent with fixed initial wealth."""
def __init__(self, model, cell):
super().__init__(model)
self.cell = cell
self.wealth = 1
def move(self):
self.cell = self.cell.neighborhood.select_random_cell()
def give_money(self):
cellmates = [a for a in self.cell.agents if a is not self]
(continues on next page)

30

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

if self.wealth > 0 and cellmates:
other_agent = self.random.choice(cellmates)
other_agent.wealth += 1
self.wealth -= 1

class MoneyModel(mesa.Model):
"""A model with some number of agents."""
def __init__(self, n, width, height, seed=None):
super().__init__(seed=seed)
self.num_agents = n
self.grid = OrthogonalMooreGrid(
(width, height), torus=True, capacity=10, random=self.random
)
# Instantiate DataCollector
self.datacollector = mesa.DataCollector(
model_reporters={"Gini": compute_gini}, agent_reporters={"Wealth": "wealth"}
)
# Create agents
agents = MoneyAgent.create_agents(
self,
self.num_agents,
self.random.choices(self.grid.all_cells.cells, k=self.num_agents),
)
def step(self):
# Collect data each step
self.datacollector.collect(self)
self.agents.shuffle_do("move")
self.agents.do("give_money")
At every step of the model, the datacollector will collect and store the model-level current Gini coefficient, as well as
each agent’s wealth, associating each with the current step.
We run the model just as we did above. Now is when an interactive session, especially via a notebook, comes in handy:
the DataCollector can export the data it has collected as a pandas* DataFrame, for easy and interactive analysis.
*If you are new to Python, please be aware that pandas is already installed as a dependency of Mesa and that pandas is
a “fast, powerful, flexible and easy to use open source data analysis and manipulation tool”. Pandas is a great resource
to help analyze the data collected in your models.
model = MoneyModel(100, 10, 10)
for _ in range(100):
model.step()
2.4.1.3.6.52 Analyzing MoneyModel Data
Code implementation:
# Extract MoneyModel data in a Pandas dataframe
• Description: Call DataCollector.get_model_vars_dataframe() method to get the model reporters (in this

2.4. Citing Mesa

31

Mesa Documentation, Release .1

case gini coefficient) from the model object. We the use seaborn (sns) to do a line plot of the data of the model
run.
• API: get_model_vars_dataframe
# Extract MoneyModel data in a Pandas dataframe
gini = model.datacollector.get_model_vars_dataframe()
g = sns.lineplot(data=gini)
g.set(title="Gini Coefficient over Time", ylabel="Gini Coefficient");

2.4.1.3.6.53 Exercises
• Display just the data to see the format
• Comment on the collect method on the step function and see the impact
• Increase agents and time to see how the plot changes
2.4.1.3.6.54 Analyzing an MoneyAgent Data
Code implementation:
# Extract MoneyAgent data in a Pandas dataframe
• Description: Call DataCollector.get_model_agent_dataframe() method to get the agent reporters (in
this case agent wealth attribute) from the model object.
• API: get_model_agent_dataframe

32

Chapter 2. Using Mesa

Mesa Documentation, Release .1

# Extract MoneyAgent data in a Pandas dataframe
agent_wealth = model.datacollector.get_agent_vars_dataframe()
agent_wealth.head()
Wealth
Step AgentID
1
1
2
3
4
5

1
1
1
1
1

You’ll see that the DataFrame’s index is pairings of model step and agent ID. This is because the data collector stores
the data in a dictionary, with the step number as the key, and a dictionary of agent ID and variable value pairs as the
value. The data collector then converts this dictionary into a DataFrame, which is why the index is a pair of (model
step, agent ID). You can analyze it the way you would any other DataFrame. For example, to get a histogram of agent
wealth at the model’s end.
Note: As the following code is pandas and seaborn we do not provide explanatory text
last_step = agent_wealth.index.get_level_values("Step").max()
end_wealth = agent_wealth.xs(last_step, level="Step")[
"Wealth"
] # Get the welath of each agentat the last step
# Create a histogram of wealth at the last step
g = sns.histplot(end_wealth, discrete=True)
g.set(
title="Distribution of wealth at the end of simulation",
xlabel="Wealth",
ylabel="number of agents",
);

2.4. Citing Mesa

# Get the last step

33

Mesa Documentation, Release .1

Or to plot the wealth of a given agent (in this example, agent 7):
# Get the wealth of agent 7 over time
one_agent_wealth = agent_wealth.xs(7, level="AgentID")
# Plot the wealth of agent 7 over time
g = sns.lineplot(data=one_agent_wealth, x="Step", y="Wealth")
g.set(title="Wealth of agent 7 over time");

34

Chapter 2. Using Mesa

Mesa Documentation, Release .1

You can also plot a reporter of multiple agents over time.
agent_list = [3, 14, 25]
# Get the wealth of multiple agents over time
multiple_agents_wealth = agent_wealth[
agent_wealth.index.get_level_values("AgentID").isin(agent_list)
]
# Plot the wealth of multiple agents over time
g = sns.lineplot(data=multiple_agents_wealth, x="Step", y="Wealth", hue="AgentID")
g.set(title="Wealth of agents 3, 14 and 25 over time");

2.4. Citing Mesa

35

Mesa Documentation, Release .1

We can also plot the average of all agents, with a 95% confidence interval for that average.
# Transform the data to a long format
agent_wealth_long = agent_wealth.T.unstack().reset_index()
agent_wealth_long.columns = ["Step", "AgentID", "Variable", "Value"]
agent_wealth_long.head(3)
# Plot the average wealth over time
g = sns.lineplot(data=agent_wealth_long, x="Step", y="Value", errorbar=("ci", 95))
g.set(title="Average wealth over time")
[Text(0.5, 1.0, 'Average wealth over time')]

36

Chapter 2. Using Mesa

Mesa Documentation, Release .1

Which is exactly 1, as expected in this model, since each agent starts with one wealth unit, and each agent gives one
wealth unit to another agent at each step.
You can also use pandas to export the data to a CSV (comma separated value) file, which can be opened by any common
spreadsheet application or opened by pandas.
If you do not specify a file path, the file will be saved in the local directory. After you run the code below you will see
two files appear (model_data.csv and agent_data.csv)
# save the model data (stored in the pandas gini object) to CSV
gini.to_csv("model_data.csv")
# save the agent data (stored in the pandas agent_wealth object) to CSV
agent_wealth.to_csv("agent_data.csv")
# Challenge update the model, conduct a batch run with a parameter sweep,
# and visualize your results
2.4.1.3.6.55 Next Steps
Check out the Agent Management Through AgentSet tutorial on effective ways to manage agents.
[Comer2014] Comer, Kenneth W. “Who Goes First?
An Examination of the Impact of Activation on Outcome Behavior in AgentBased Models.” George Mason University,
2014.
http://mars.gmu.edu/bitstream/handle/1920/9070/Comer_gmu_0883E_10539.pdf
[Dragulescu2002] Drăgulescu, Adrian A., and Victor M. Yakovenko. “Statistical Mechanics of Money, Income, and

2.4. Citing Mesa

37

Mesa Documentation, Release .1

Wealth: A Short Survey.” arXiv Preprint Cond-mat/0211175, 2002. http://arxiv.org/abs/cond-mat/0211175.
2.4.1.3.6.56 Agent Management Through AgentSet
2.4.1.3.6.57 The Boltzmann Wealth Model
If you want to get straight to the tutorial checkout these environment providers: (with Google Account) (No Google
Account) (This can take 30 seconds to 5 minutes to load)
If you are running locally, please ensure you have the latest Mesa version installed.
2.4.1.3.6.58 Tutorial Description
This tutorial extends the Boltzmann wealth model from the Collecting Data tutorial, by demonstrating Mesa’s AgentSet
functionality.
In this portion, we will demonstrate how users can employ AgentSet for different purposes.
If you are starting here please see the Running Your First Model tutorial for dependency and start-up instructions
2.4.1.3.6.59 IN COLAB? - Run the next cell
2.4.1.3.6.60 Import Dependencies
This includes importing of dependencies needed for the tutorial.
# Has multi-dimensional arrays and matrices.
# Has a large collection of mathematical functions to operate on these arrays.
import numpy as np
# Data manipulation and analysis.
import pandas as pd
# Data visualization tools.
import seaborn as sns
import mesa
2.4.1.3.6.61 Agent Management Through AgentSet
Background: Mesa uses a set based approach, AgentSet to allow users efficiently and intuitively manage their agents.
For the most part users will never explicitly call AgentSet and in fact, we have already used the AgentSet methods
functionality when we used shuffle_do(move) to reorder the agents and then do(exchange) to have the agents
exchange money in sequence. Although you will likely never interact with AgentSent directly it is important to know
the Mesa uses a set based approach for agent management.
Beyond the method functionality there are additional ways AgentSet can help you manage your agents and we will look
at two additional examples in this tutorial, but you can see more in the Getting Started Section of Mesa.
Model-specific information: We will show two agent management techniques just to demonstrate the capability
1. Selecting We will institute a policy that has the rich agents give money to the poor agents
2. GroupBy We will group agents together based on wealth
A big thanks to @Ewout for his exceptional work on developing and implementing AgentSet

38

Chapter 2. Using Mesa

Mesa Documentation, Release .1

2.4.1.3.6.62 Selecting
Model-specific Information: For this variation of the model we are going to institute a policy that only rich agents
give money to poor agent
Code Implementation: We will use agents.select to separate the agents into rich and poor agents. If there are rich
agents then they are the only ones who give money.
# Get lists of rich and poor agents
• Description: Uses AgentSet.select with a function (in this case a lambda function) to select agents with
greater than 3 units of wealth and less than three units of wealth. This will give us two lists of agents rich agent
and poor agent which we can then use to execute the give_money method.
• API: AgentSet.select
def compute_gini(model):
agent_wealths = [agent.wealth for agent in model.agents]
x = sorted(agent_wealths)
n = model.num_agents
B = sum(xi * (n - i) for i, xi in enumerate(x)) / (n * sum(x))
return 1 + (1 / n) - 2 * B

class MoneyAgent(mesa.Agent):
"""An agent with fixed initial wealth."""
def __init__(self, model):
super().__init__(model)
self.wealth = 1
def give_money(self, poor_agents):
if self.wealth > 0:
other_agent = self.random.choice(poor_agents)
other_agent.wealth += 1
self.wealth -= 1

class MoneyModel(mesa.Model):
"""A model with some number of agents."""
def __init__(self, n):
super().__init__()
self.num_agents = n
# Create agents
MoneyAgent.create_agents(model=self, n=n)
self.datacollector = mesa.DataCollector(
model_reporters={"Gini": compute_gini}, agent_reporters={"Wealth": "wealth"}
)
def step(self):
self.datacollector.collect(self)
# Get lists of rich and poor agents
rich_agents = model.agents.select(lambda a: a.wealth >= 3)

2.4. Citing Mesa

(continues on next page)

39

Mesa Documentation, Release .1

(continued from previous page)

poor_agents = model.agents.select(lambda a: a.wealth < 3)
# When there is rich agents only have them give money to poor agents
if len(rich_agents) > 0:
rich_agents.shuffle_do("give_money", poor_agents)
else:
poor_agents.shuffle_do("give_money", poor_agents)
We now run the model, collect the data, and plot the results.
model = MoneyModel(100)
for _ in range(20):
model.step()

data = model.datacollector.get_agent_vars_dataframe()
# Use seaborn
g = sns.histplot(data["Wealth"], discrete=True)
g.set(title="Wealth distribution", xlabel="Wealth", ylabel="number of agents");

2.4.1.3.6.63 Group By
Model-specific implementation: In this case we will give agents an attribute of ethnicity of Green, Blue or Mixed.
Green and Blue agents only give money to their ethnicity while Mixed can give money to anyone.
Code Implementation: Using groupby we will execute the above logic in our code by passing a list of grouped agents
40

Chapter 2. Using Mesa

Mesa Documentation, Release .1

into our give_money function. To ensure we can plot wealth by group we also need to add ethnicity to our datacollector.
# Create dictionary of agents groupby
Description: Uses AgentSet.groupby to group agents by their ethnicity attribute. This will give us a dictionary
where the keys are the different ethnicities and the values are an AgentSet. In this case we will then use the AgentSet
class and leverage its shuffle_do capability to then give money to the target groups.
• API: AgentSet.select
• Note: AgentSet has a lot of functionality and similar to discrete_space has the ability to add new features
and make Mesa models more user-friendly. We strongly encourage you to check out the AgentSet API to see all
the functionality and if you have an idea feel free to contribute
class MoneyAgent(mesa.Agent):
"""An agent with fixed initial wealth."""
def __init__(self, model, ethnicity):
super().__init__(model)
self.wealth = 1
self.ethnicity = ethnicity
def give_money(self, similars):
if self.wealth > 0:
other_agent = self.random.choice(similars)
other_agent.wealth += 1
self.wealth -= 1

class MoneyModel(mesa.Model):
"""A model with some number of agents."""
def __init__(self, n):
super().__init__()
self.num_agents = n
# Create a list of our different ethnicities
ethnicities = ["Green", "Blue", "Mixed"]
# Create agents
MoneyAgent.create_agents(
model=self,
n=self.num_agents,
ethnicity=self.random.choices(ethnicities, k=self.num_agents),
)
self.datacollector = mesa.DataCollector(
model_reporters={"Gini": compute_gini},
agent_reporters={"Wealth": "wealth", "Ethnicity": "ethnicity"},
)
def step(self):
self.datacollector.collect(self)
# Create dictionary of agents groupby
grouped_agents = model.agents.groupby("ethnicity")
(continues on next page)

2.4. Citing Mesa

41

Mesa Documentation, Release .1

(continued from previous page)

for ethnic, similars in grouped_agents:
if ethnic != "Mixed":
similars.shuffle_do("give_money", similars)
else:
similars.shuffle_do(
"give_money", self.agents
) # This allows mixed to trade with anyone
# Run the model
model = MoneyModel(100)
for _ in range(20):
model.step()
# get the data
data = model.datacollector.get_agent_vars_dataframe()
# assign histogram colors
palette = {"Green": "green", "Blue": "blue", "Mixed": "purple"}
sns.histplot(data=data, x="Wealth", hue="Ethnicity", discrete=True, palette=palette)
g.set(title="Wealth distribution", xlabel="Wealth", ylabel="number of agents");

2.4.1.3.6.64 Exercises
• Create a new policy or alter an existing policy in this model to see the impact
• Use a different feature in AgentSet and integrate into this model

42

Chapter 2. Using Mesa

Mesa Documentation, Release .1

2.4.1.3.6.65 Next Steps
Check out the basic visualization tutorial on how to build interactive dashboards for your models.
[Comer2014] Comer, Kenneth W. “Who Goes First?
An Examination of the Impact of Activation on Outcome Behavior in AgentBased Models.” George Mason University,
2014.
http://mars.gmu.edu/bitstream/handle/1920/9070/Comer_gmu_0883E_10539.pdf
[Dragulescu2002] Drăgulescu, Adrian A., and Victor M. Yakovenko. “Statistical Mechanics of Money, Income, and
Wealth: A Short Survey.” arXiv Preprint Cond-mat/0211175, 2002. http://arxiv.org/abs/cond-mat/0211175.
2.4.1.3.6.66 Visualization - Basic Dashboard
2.4.1.3.6.67 The Boltzmann Wealth Model
If you want to get straight to the tutorial checkout these environment providers: (This can take 30 seconds to 5 minutes
to load)
Due to conflict with Colab and Solara there are no colab links for this tutorial
If you are running locally, please ensure you have the latest Mesa version installed.
2.4.1.3.6.68 Tutorial Description
This tutorial extends the Boltzmann wealth model from the AgentSet tutorial, by adding an interactive dashboard.
In this portion, we will demonstrate how users can employ build a basic dashboard. This is part one of three part series
on building interactive dashboards in Mesa.
If you are starting here please see the Running Your First Model tutorial for dependency and start-up instructions
2.4.1.3.6.69 Import Dependencies
This includes importing of dependencies needed for the tutorial.
# Has multi-dimensional arrays and matrices.
# Has a large collection of mathematical functions to operate on these arrays.
import numpy as np
# Data manipulation and analysis.
import pandas as pd
# Data visualization tools.
import seaborn as sns
import mesa
from mesa.discrete_space import CellAgent, OrthogonalMooreGrid
from mesa.visualization import SolaraViz, make_plot_component, make_space_component
2.4.1.3.6.70 Basic Model
The following is the basic model we will be using to build the dashboard. This is the same model seen in tutorials 0-3.
def compute_gini(model):
agent_wealths = [agent.wealth for agent in model.agents]
x = sorted(agent_wealths)
(continues on next page)

2.4. Citing Mesa

43

Mesa Documentation, Release .1

(continued from previous page)

N = model.num_agents
B = sum(xi * (N - i) for i, xi in enumerate(x)) / (N * sum(x))
return 1 + (1 / N) - 2 * B

class MoneyAgent(CellAgent):
"""An agent with fixed initial wealth."""
def __init__(self, model, cell):
"""initialize a MoneyAgent instance.
Args:
model: A model instance
"""
super().__init__(model)
self.cell = cell
self.wealth = 1
def move(self):
"""Move the agent to a random neighboring cell."""
self.cell = self.cell.neighborhood.select_random_cell()
def give_money(self):
"""Give 1 unit of wealth to a random agent in the same cell."""
cellmates = [a for a in self.cell.agents if a is not self]
if cellmates: # Only give money if there are other agents present
other = self.random.choice(cellmates)
other.wealth += 1
self.wealth -= 1
def step(self):
"""do one step of the agent."""
self.move()
if self.wealth > 0:
self.give_money()

class MoneyModel(mesa.Model):
"""A model with some number of agents."""
def __init__(self, n=10, width=10, height=10, seed=None):
"""Initialize a MoneyModel instance.
Args:
N: The number of agents.
width: width of the grid.
height: Height of the grid.
"""
super().__init__(seed=seed)
self.num_agents = n
self.grid = OrthogonalMooreGrid((width, height), random=self.random)
(continues on next page)

44

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

# Create agents
MoneyAgent.create_agents(
self,
self.num_agents,
self.random.choices(self.grid.all_cells.cells, k=self.num_agents),
)
self.datacollector = mesa.DataCollector(
model_reporters={"Gini": compute_gini}, agent_reporters={"Wealth": "wealth"}
)
self.datacollector.collect(self)
def step(self):
"""do one step of the model"""
self.agents.shuffle_do("step")
self.datacollector.collect(self)
# Lets make sure the model works
model = MoneyModel(100, 10, 10)
for _ in range(20):
model.step()

data = model.datacollector.get_agent_vars_dataframe()
# Use seaborn
g = sns.histplot(data["Wealth"], discrete=True)
g.set(title="Wealth distribution", xlabel="Wealth", ylabel="number of agents");

2.4. Citing Mesa

45

Mesa Documentation, Release .1

2.4.1.3.6.71 Adding visualization
So far, we’ve built a model, run it, and analyzed some output afterwards. However, one of the advantages of agentbased models is that we can often watch them run step by step, potentially spotting unexpected patterns, behaviors
or bugs, or developing new intuitions, hypotheses, or insights. Other times, watching a model run can explain it
to an unfamiliar audience better than static explanations. Like many ABM frameworks, Mesa allows you to create
an interactive visualization of the model. In this section we’ll walk through creating a visualization using built-in
components, and (for advanced users) how to create a new visualization element.
First, a quick explanation of how Mesa’s interactive visualization works. The visualization is done in a browser window
or Jupyter instance, using the Solara framework, a pure Python, React-style web framework. Running solara run
app.py will launch a web server, which runs the model, and displays model detail at each step via a plotting library.
Alternatively, you can execute everything inside a Jupyter instance and display it inline.
2.4.1.3.6.72 Grid Visualization
Mesa’s grid visualizer works by looping over every cell in a grid, and generating a portrayal for every agent it finds.
A portrayal is a dictionary (which can easily be turned into a JSON object) which tells Matplotlib the color and size
of the scatterplot markers (each signifying an agent). The only thing we need to provide is a function which takes an
agent, and returns a portrayal dictionary. Here’s the simplest one: it’ll draw each agent as a blue, filled circle, with a
radius size of 50.
def agent_portrayal(agent):
return {
"color": "tab:blue",
(continues on next page)

46

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

"size": 50,
}
In addition to the portrayal method, we instantiate the model parameters, some of which are modifiable by user inputs.
In this case, the number of agents, N, is specified as a slider of integers.
model_params = {
"n": {
"type": "SliderInt",
"value": 50,
"label": "Number of agents:",
"min": 10,
"max": 100,
"step": 1,
},
"width": 10,
"height": 10,
}
Next, we instantiate the visualization object which (by default) displays the grid containing the agents, and timeseries
of values computed by the model’s data collector. In this example, we specify the Gini coefficient.
There are 3 buttons:
• the step button, which advances the model by 1 step
• the play button, which advances the model indefinitely until it is paused
• the pause button, which pauses the model
To reset the model, the order of operations are important
1. Stop the model
2. Update the parameters (e.g. move the sliders)
3. Press reset
# Create initial model instance
money_model = MoneyModel(n=50, width=10, height=10)

# keyword arguments

SpaceGraph = make_space_component(agent_portrayal)
GiniPlot = make_plot_component("Gini")
page = SolaraViz(
money_model,
components=[SpaceGraph, GiniPlot],
model_params=model_params,
name="Boltzmann Wealth Model",
)
# This is required to render the visualization in the Jupyter notebook
page
<IPython.core.display.Javascript object>

2.4. Citing Mesa

47

Mesa Documentation, Release .1

<IPython.core.display.Javascript object>
Cannot show ipywidgets in text
2.4.1.3.6.73 Next Steps
Check out the next visualization tutorial dynamic agents on how to further enhance your interactive dashboard.
[Comer2014] Comer, Kenneth W. “Who Goes First?
An Examination of the Impact of Activation on Outcome Behavior in AgentBased Models.” George Mason University,
2014.
http://mars.gmu.edu/bitstream/handle/1920/9070/Comer_gmu_0883E_10539.pdf
[Dragulescu2002] Drăgulescu, Adrian A., and Victor M. Yakovenko. “Statistical Mechanics of Money, Income, and
Wealth: A Short Survey.” arXiv Preprint Cond-mat/0211175, 2002. http://arxiv.org/abs/cond-mat/0211175.
2.4.1.3.6.74 Visualization - Dynamic Agents
2.4.1.3.6.75 The Boltzmann Wealth Model
If you want to get straight to the tutorial checkout these environment providers: (This can take 30 seconds to 5 minutes
to load)
Due to conflict with Colab and Solara there are no colab links for this tutorial
If you are running locally, please ensure you have the latest Mesa version installed.
2.4.1.3.6.76 Tutorial Description
This tutorial extends the Boltzmann wealth model from the Visualization Basic Dashboard tutorial, by adding an interactive dashboard.
In this portion, we will demonstrate how users can employ create dynamic agent representation with their Mesa dashboards. This is part two of three visualization tutorials.
If you are starting here please see the Running Your First Model tutorial for dependency and start-up instructions
2.4.1.3.6.77 Import Dependencies
This includes importing of dependencies needed for the tutorial.
# Has multi-dimensional arrays and matrices.
# Has a large collection of mathematical functions to operate on these arrays.
import numpy as np
# Data manipulation and analysis.
import pandas as pd
# Data visualization tools.
import seaborn as sns
import mesa
from mesa.discrete_space import CellAgent, OrthogonalMooreGrid
from mesa.visualization import SolaraViz, make_plot_component, make_space_component

48

Chapter 2. Using Mesa

Mesa Documentation, Release .1

2.4.1.3.6.78 Basic Model
The following is the basic model we will be using to build the dashboard. This is the same model seen in tutorials 0-3.
def compute_gini(model):
agent_wealths = [agent.wealth for agent in model.agents]
x = sorted(agent_wealths)
N = model.num_agents
B = sum(xi * (N - i) for i, xi in enumerate(x)) / (N * sum(x))
return 1 + (1 / N) - 2 * B

class MoneyAgent(CellAgent):
"""An agent with fixed initial wealth."""
def __init__(self, model, cell):
"""initialize a MoneyAgent instance.
Args:
model: A model instance
"""
super().__init__(model)
self.cell = cell
self.wealth = 1
def move(self):
"""Move the agent to a random neighboring cell."""
self.cell = self.cell.neighborhood.select_random_cell()
def give_money(self):
"""Give 1 unit of wealth to a random agent in the same cell."""
cellmates = [a for a in self.cell.agents if a is not self]
if cellmates: # Only give money if there are other agents present
other = self.random.choice(cellmates)
other.wealth += 1
self.wealth -= 1
def step(self):
"""do one step of the agent."""
self.move()
if self.wealth > 0:
self.give_money()

class MoneyModel(mesa.Model):
"""A model with some number of agents."""
def __init__(self, n=10, width=10, height=10, seed=None):
"""Initialize a MoneyModel instance.
Args:
N: The number of agents.
width: width of the grid.

2.4. Citing Mesa

(continues on next page)

49

Mesa Documentation, Release .1

(continued from previous page)

height: Height of the grid.
"""
super().__init__(seed=seed)
self.num_agents = n
self.grid = OrthogonalMooreGrid((width, height), random=self.random)
# Create agents
MoneyAgent.create_agents(
self,
self.num_agents,
self.random.choices(self.grid.all_cells.cells, k=self.num_agents),
)
self.datacollector = mesa.DataCollector(
model_reporters={"Gini": compute_gini}, agent_reporters={"Wealth": "wealth"}
)
self.datacollector.collect(self)
def step(self):
"""do one step of the model"""
self.agents.shuffle_do("step")
self.datacollector.collect(self)
# Lets make sure the model works
model = MoneyModel(100, 10, 10)
for _ in range(20):
model.step()

data = model.datacollector.get_agent_vars_dataframe()
# Use seaborn
g = sns.histplot(data["Wealth"], discrete=True)
g.set(title="Wealth distribution", xlabel="Wealth", ylabel="number of agents");

50

Chapter 2. Using Mesa

Mesa Documentation, Release .1

2.4.1.3.6.79 Adding visualization
So far, we’ve built a model, run it, and analyzed some output afterwards. However, one of the advantages of agentbased models is that we can often watch them run step by step, potentially spotting unexpected patterns, behaviors
or bugs, or developing new intuitions, hypotheses, or insights. Other times, watching a model run can explain it
to an unfamiliar audience better than static explanations. Like many ABM frameworks, Mesa allows you to create
an interactive visualization of the model. In this section we’ll walk through creating a visualization using built-in
components, and (for advanced users) how to create a new visualization element.
First, a quick explanation of how Mesa’s interactive visualization works. The visualization is done in a browser window
or Jupyter instance, using the Solara framework, a pure Python, React-style web framework. Running solara run
app.py will launch a web server, which runs the model, and displays model detail at each step via a plotting library.
Alternatively, you can execute everything inside a Jupyter instance and display it inline.
2.4.1.3.6.80 Dynamic Agent Representation
In the first visualization, all we could see is the agents moving around – but not how much money they had, or anything
else of interest. In this tutorial let’s change it so that agents are represented by the units of wealth they have. So those
who are broke (wealth 0) are drawn in red, smaller.
As Mesa is open source, it is important to point out that currently, we can’t direct the drawing order of the circles, so a
broke agent may be overshadowed by a wealthy agent. If you have some ideas, please feel free to contribute.
In addition to size and color, an agent’s shape can also be customized when using the default drawer. The allowed
values for shapes can be found here.
To do this, we go back to our agent_portrayal code and add some code to change the portrayal based on the agent

2.4. Citing Mesa

51

Mesa Documentation, Release .1

properties and launch the server again.
def agent_portrayal(agent):
size = 10
color = "tab:red"
if agent.wealth > 0:
size = 50
color = "tab:blue"
return {"size": size, "color": color}
As like last time we then instantiate the model parameters, some of which are modifiable by user inputs. In this case,
the number of agents, N, is specified as a slider of integers.
model_params = {
"n": {
"type": "SliderInt",
"value": 50,
"label": "Number of agents:",
"min": 10,
"max": 100,
"step": 1,
},
"width": 10,
"height": 10,
}
Then just like last time we instantiate the visualization object which (by default) displays the grid containing the agents,
and timeseries of values computed by the model’s data collector. In this example, we specify the Gini coefficient.
There are 3 buttons:
• the step button, which advances the model by 1 step
• the play button, which advances the model indefinitely until it is paused
• the pause button, which pauses the model
To reset the model, the order of operations are important
1. Stop the model
2. Update the parameters (e.g. move the sliders)
3. Press reset
# Create initial model instance
money_model = MoneyModel(n=50, width=10, height=10)
SpaceGraph = make_space_component(agent_portrayal)
GiniPlot = make_plot_component("Gini")
page = SolaraViz(
money_model,
components=[SpaceGraph, GiniPlot],
model_params=model_params,
name="Boltzmann Wealth Model",
)
(continues on next page)

52

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

# This is required to render the visualization in the Jupyter notebook
page
Cannot show ipywidgets in text
2.4.1.3.6.81 Exercise
• Change the agent representations, such as squares, triangles or even .pngs
2.4.1.3.6.82 Next Steps
Check out the next visualization tutorial custom components on how to further enahnce your interactive dashboard.
[Comer2014] Comer, Kenneth W. “Who Goes First?
An Examination of the Impact of Activation on Outcome Behavior in AgentBased Models.” George Mason University,
2014.
http://mars.gmu.edu/bitstream/handle/1920/9070/Comer_gmu_0883E_10539.pdf
[Dragulescu2002] Drăgulescu, Adrian A., and Victor M. Yakovenko. “Statistical Mechanics of Money, Income, and
Wealth: A Short Survey.” arXiv Preprint Cond-mat/0211175, 2002. http://arxiv.org/abs/cond-mat/0211175.
2.4.1.3.6.83 Visualization - Custom Components
2.4.1.3.6.84 The Boltzmann Wealth Model
If you want to get straight to the tutorial checkout these environment providers: (This can take 30 seconds to 5 minutes
to load)
Due to conflict with Colab and Solara there are no colab links for this tutorial
If you are running locally, please ensure you have the latest Mesa version installed.
2.4.1.3.6.85 Tutorial Description
This tutorial extends the Boltzmann wealth model from the Visualization Basic Dashboard tutorial, by adding an interactive dashboard.
In this portion, we will demonstrate how users can employ create dynamic agent representation with their Mesa dashboards. This is part two of three visualization tutorials.
If you are starting here please see the Running Your First Model tutorial for dependency and start-up instructions
2.4.1.3.6.86 Import Dependencies
This includes importing of dependencies needed for the tutorial.
# Has multi-dimensional arrays and matrices.
# Has a large collection of mathematical functions to operate on these arrays.
import numpy as np
# Data manipulation and analysis.
import pandas as pd
# Data visualization tools.
import seaborn as sns
(continues on next page)

2.4. Citing Mesa

53

Mesa Documentation, Release .1

(continued from previous page)

import mesa
from mesa.discrete_space import CellAgent, OrthogonalMooreGrid
from mesa.visualization import SolaraViz, make_plot_component, make_space_component
2.4.1.3.6.87 Basic Model
The following is the basic model we will be using to build the dashboard. This is the same model seen in tutorials 0-3.
def compute_gini(model):
agent_wealths = [agent.wealth for agent in model.agents]
x = sorted(agent_wealths)
N = model.num_agents
B = sum(xi * (N - i) for i, xi in enumerate(x)) / (N * sum(x))
return 1 + (1 / N) - 2 * B

class MoneyAgent(CellAgent):
"""An agent with fixed initial wealth."""
def __init__(self, model, cell):
"""initialize a MoneyAgent instance.
Args:
model: A model instance
"""
super().__init__(model)
self.cell = cell
self.wealth = 1
def move(self):
"""Move the agent to a random neighboring cell."""
self.cell = self.cell.neighborhood.select_random_cell()
def give_money(self):
"""Give 1 unit of wealth to a random agent in the same cell."""
cellmates = [a for a in self.cell.agents if a is not self]
if cellmates: # Only give money if there are other agents present
other = self.random.choice(cellmates)
other.wealth += 1
self.wealth -= 1
def step(self):
"""do one step of the agent."""
self.move()
if self.wealth > 0:
self.give_money()

class MoneyModel(mesa.Model):
"""A model with some number of agents."""
(continues on next page)

54

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

def __init__(self, n=10, width=10, height=10, seed=None):
"""Initialize a MoneyModel instance.
Args:
N: The number of agents.
width: width of the grid.
height: Height of the grid.
"""
super().__init__(seed=seed)
self.num_agents = n
self.grid = OrthogonalMooreGrid((width, height), random=self.random)
# Create agents
MoneyAgent.create_agents(
self,
self.num_agents,
self.random.choices(self.grid.all_cells.cells, k=self.num_agents),
)
self.datacollector = mesa.DataCollector(
model_reporters={"Gini": compute_gini}, agent_reporters={"Wealth": "wealth"}
)
self.datacollector.collect(self)
def step(self):
"""do one step of the model"""
self.agents.shuffle_do("step")
self.datacollector.collect(self)
# Lets make sure the model works
model = MoneyModel(100, 10, 10)
for _ in range(20):
model.step()

data = model.datacollector.get_agent_vars_dataframe()
# Use seaborn
g = sns.histplot(data["Wealth"], discrete=True)
g.set(title="Wealth distribution", xlabel="Wealth", ylabel="Number of Agents");

2.4. Citing Mesa

55

Mesa Documentation, Release .1

2.4.1.3.6.88 Adding visualization
So far, we’ve built a model, run it, and analyzed some output afterwards. However, one of the advantages of agentbased models is that we can often watch them run step by step, potentially spotting unexpected patterns, behaviors
or bugs, or developing new intuitions, hypotheses, or insights. Other times, watching a model run can explain it
to an unfamiliar audience better than static explanations. Like many ABM frameworks, Mesa allows you to create
an interactive visualization of the model. In this section we’ll walk through creating a visualization using built-in
components, and (for advanced users) how to create a new visualization element.
First, a quick explanation of how Mesa’s interactive visualization works. The visualization is done in a browser window
or Jupyter instance, using the Solara framework, a pure Python, React-style web framework. Running solara run
app.py will launch a web server, which runs the model, and displays model detail at each step via a plotting library.
Alternatively, you can execute everything inside a Jupyter instance and display it inline.
Thanks to @Corvince for all his work creating Mesa’s visualization capability
2.4.1.3.6.89 Building Custom Components
This section is for users who have a basic familiarity with Python’s Matplotlib plotting library.
If the visualization elements provided by Mesa aren’t enough for you, you can build your own and plug them into the
model server.
For this example, let’s build a simple histogram visualization, which can count the number of agents with each value
of wealth.
First we need to update our imports

56

Chapter 2. Using Mesa

Mesa Documentation, Release .1

We use Matplotlib in this tutorial, but Mesa also has Altair. If you would like other visualization support like Plotly or
Bokeh, please feel free to contribute
In addition, due to the way Solara works we need to trigger an update whenever the underlying model changes. For
this you need to register an update counter with every component.
import solara
from matplotlib.figure import Figure
from mesa.visualization.utils import update_counter
Next we provide a function for our agent portrayal and our model parameters.
def agent_portrayal(agent):
size = 10
color = "tab:red"
if agent.wealth > 0:
size = 50
color = "tab:blue"
return {"size": size, "color": color}

model_params = {
"n": {
"type": "SliderInt",
"value": 50,
"label": "Number of agents:",
"min": 10,
"max": 100,
"step": 1,
},
"width": 10,
"height": 10,
}
Now we add our custom component. In this case we will build a histogram of agent wealth.
Besides the standard matplotlib code to build a histogram, please notice 3 key features.
1. @solara.component this is needed for any compoenent you add
2. update_counter.get() this is needed so solara updates the dashboard with your agent based model
3. you must initialize a figure using this method instead of plt.figure(), for thread safety purpose
@solara.component
def Histogram(model):
update_counter.get() # This is required to update the counter
# Note: you must initialize a figure using this method instead of
# plt.figure(), for thread safety purpose
fig = Figure()
ax = fig.subplots()
wealth_vals = [agent.wealth for agent in model.agents]
# Note: you have to use Matplotlib's OOP API instead of plt.hist
# because plt.hist is not thread-safe.
ax.hist(wealth_vals, bins=10)
solara.FigureMatplotlib(fig)

2.4. Citing Mesa

57

Mesa Documentation, Release .1

Now we create the model an initialize the visualization
# Create initial model instance
money_model = MoneyModel(n=50, width=10, height=10)
SpaceGraph = make_space_component(agent_portrayal)
GiniPlot = make_plot_component("Gini")
page = SolaraViz(
money_model,
components=[SpaceGraph, GiniPlot, Histogram],
model_params=model_params,
name="Boltzmann Wealth Model",
)
# This is required to render the visualization in the Jupyter notebook
page
Cannot show ipywidgets in text
You can even run the visuals independently by calling it with the model instance
Histogram(money_model)
Cannot show ipywidgets in text
2.4.1.3.6.90 Exercise
• Build you own custom component
2.4.1.3.6.91 Next Steps
Check out the next batch run tutorial on how to conduct parameter sweeps and run numerous iterations of your model.
[Comer2014] Comer, Kenneth W. “Who Goes First?
An Examination of the Impact of Activation on Outcome Behavior in AgentBased Models.” George Mason University,
2014.
http://mars.gmu.edu/bitstream/handle/1920/9070/Comer_gmu_0883E_10539.pdf
[Dragulescu2002] Drăgulescu, Adrian A., and Victor M. Yakovenko. “Statistical Mechanics of Money, Income, and
Wealth: A Short Survey.” arXiv Preprint Cond-mat/0211175, 2002. http://arxiv.org/abs/cond-mat/0211175.
2.4.1.3.6.92 BatchRunner
2.4.1.3.6.93 The Boltzmann Wealth Model
If you want to get straight to the tutorial checkout these environment providers: (with Google Account) (No Google
Account) (This can take 30 seconds to 5 minutes to load)
If you are running locally, please ensure you have the latest Mesa version installed.
2.4.1.3.6.94 Tutorial Description
This tutorial extends the Boltzmann wealth model from the Collecting Data tutorial, by showing how users can use
batch_run to conduct parameter sweeps of their models.
If you are starting here please see the Running Your First Model tutorial for dependency and start-up instructions

58

Chapter 2. Using Mesa

Mesa Documentation, Release .1

2.4.1.3.6.95 IN COLAB? - Run the next cell
2.4.1.3.6.96 Import Dependencies
This includes importing of dependencies needed for the tutorial.
# Has multi-dimensional arrays and matrices.
# Has a large collection of mathematical functions to operate on these arrays.
import numpy as np
# Data manipulation and analysis.
import pandas as pd
# Data visualization tools.
import seaborn as sns
import mesa
# Import Cell Agent and OrthogonalMooreGrid
from mesa.discrete_space import CellAgent, OrthogonalMooreGrid
2.4.1.3.6.97 Base Model
The below provides the base model from which we will add batch_run functionality. Of note, this is the same as the
collecting data tutorial but we add one agent reporter that counts if money is not given to that agent during a time step.
We also added self.running=True in the MoneyModel class. This allows users to provide a conditional stop attribute
(e.g. all sheep and wolves die) as opposed to a step count.)
This is from the Running Your First Model tutorial tutorial. If you have any questions about it functionality please
review that tutorial.
def compute_gini(model):
agent_wealths = [agent.wealth for agent in model.agents]
x = sorted(agent_wealths)
n = model.num_agents
B = sum(xi * (n - i) for i, xi in enumerate(x)) / (n * sum(x))
return 1 + (1 / n) - 2 * B

class MoneyAgent(CellAgent):
"""An agent with fixed initial wealth."""
def __init__(self, model, cell):
super().__init__(model)
self.cell = cell
self.wealth = 1
self.steps_not_given = 0
def move(self):
self.cell = self.cell.neighborhood.select_random_cell()
def give_money(self):
cellmates = [a for a in self.cell.agents if a is not self]
(continues on next page)

2.4. Citing Mesa

59

Mesa Documentation, Release .1

(continued from previous page)

if len(cellmates) > 0 and self.wealth > 0:
other = self.random.choice(cellmates)
other.wealth += 1
self.wealth -= 1
self.steps_not_given = 0
else:
self.steps_not_given += 1

class MoneyModel(mesa.Model):
"""A model with some number of agents."""
def __init__(self, n, width, height, seed=None):
super().__init__(seed=seed)
self.num_agents = n
self.grid = OrthogonalMooreGrid(
(width, height), torus=True, capacity=10, random=self.random
)
# Instantiate DataCollector
self.datacollector = mesa.DataCollector(
model_reporters={"Gini": compute_gini},
agent_reporters={"Wealth": "wealth", "Steps_not_given": "steps_not_given"},
)
self.running = True
# Create agents
agents = MoneyAgent.create_agents(
self,
self.num_agents,
self.random.choices(self.grid.all_cells.cells, k=self.num_agents),
)
def step(self):
# Collect data each step
self.datacollector.collect(self)
self.agents.shuffle_do("move")
self.agents.do("give_money")
model = MoneyModel(100, 10, 10)
for _ in range(100):
model.step()
gini = model.datacollector.get_model_vars_dataframe()
g = sns.lineplot(data=gini)
g.set(title="Gini Coefficient over Time", ylabel="Gini Coefficient");

60

Chapter 2. Using Mesa

Mesa Documentation, Release .1

2.4.1.3.6.98 Batch Run
Modelers typically won’t run a model just once, but multiple times, with fixed parameters to find the overall distributions the model generates, and with varying parameters to analyze how these variables drive the model’s outputs and
behaviors. This is commonly referred to as parameter sweeps. Instead of needing to write nested for-loops for each
model, Mesa provides a batch_run function which automates parameter sweeps and allows the model variants to run
on multiple processors.
2.4.1.3.6.99 Batch run parameters
We call batch_run with the following arguments:
• model_cls The model class that is used for the batch run.
• parameters A dictionary containing all the parameters of the model class and desired values to use for the batch
run as key-value pairs. Each value can either be fixed ( e.g. {"height": 10, "width": 10}) or an iterable
(e.g. {"n": range(10, 500, 10)}). batch_run will then generate all possible parameter combinations
based on this dictionary and run the model iterations times for each combination.
• number_processes If not specified, defaults to 1. Set it to None to use all the available processors. Note:
Multiprocessing does make debugging challenging. If your parameter sweeps are resulting in unexpected errors
set number_processes=1.
• iterations The number of iterations to run each parameter combination for. Optional. If not specified, defaults
to 1.
• data_collection_period The length of the period (number of steps) after which the model and agent reporters
collect data. Optional. If not specified, defaults to -1, i.e. only at the end of each episode.

2.4. Citing Mesa

61

Mesa Documentation, Release .1

• max_steps The maximum number of time steps after which the model halts. An episode does either end when
self.running of the model class is set to False or when model.steps == max_steps is reached. Optional.
If not specified, defaults to 1000.
• display_progress Display the batch run progress. Optional. If not specified, defaults to True.
In the following example, we hold the height and width fixed, and vary the number of agents. We tell the batch runner
to run 5 instantiations of the model with each number of agents, and to run each for 100 steps.
We want to keep track of
1. The Gini coefficient value at each time step
2. The individual agent’s wealth development and steps without giving money.
Important: Since for the latter, changes at each time step might be interesting, we set data_collection_period=1.
By default, it only collects data at the end of each episode.
Note: The total number of runs is 100 (20 different populations * 5 iterations per population).
params = {"width": 10, "height": 10, "n": range(5, 105, 5)}
results = mesa.batch_run(
MoneyModel,
parameters=params,
iterations=5,
max_steps=100,
number_processes=1,
data_collection_period=1,
display_progress=True,
)
0%|

| 0/100 [00:00<?, ?it/s]

To further analyze the return of the batch_run function, we convert the list of dictionaries to a Pandas DataFrame and
print its keys.
2.4.1.3.6.100 Batch Run Analysis and Visualization
results_df = pd.DataFrame(results)
print(f"The results have {len(results)} rows.")
print(f"The columns of the data frame are {list(results_df.keys())}.")
The results have 525100 rows.
The columns of the data frame are ['RunId', 'iteration', 'Step', 'width', 'height', 'n',
˓→'Gini', 'AgentID', 'Wealth', 'Steps_not_given'].
First, we want to take a closer look at how the Gini coefficient at the end of each episode changes as we increase the
size of the population. For this, we filter our results to only contain the data of one agent (the Gini coefficient will be
the same for the entire population at any time) at the 100th step of each episode and then scatter-plot the values for
the Gini coefficient over the the number of agents. Notice there are five values for each population size since we set
iterations=5 when calling the batch run.
# Filter the results to only contain the data of one agent
# The Gini coefficient will be the same for the entire population at any time
results_filtered = results_df[(results_df.AgentID == 1) & (results_df.Step == 100)]
(continues on next page)

62

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

results_filtered[["iteration", "n", "Gini"]].reset_index(
drop=True
).head() # Create a scatter plot
g = sns.scatterplot(data=results_filtered, x="n", y="Gini")
g.set(
xlabel="number of agents",
ylabel="Gini coefficient",
title="Gini coefficient vs. Number of Agents",
);

We can create different kinds of plot from this filtered DataFrame. For example, a point plot with error bars.
# Create a point plot with error bars
g = sns.pointplot(data=results_filtered, x="n", y="Gini", linestyle="None")
g.figure.set_size_inches(8, 4)
g.set(
xlabel="number of agents",
ylabel="Gini coefficient",
title="Gini coefficient vs. number of agents",
);

2.4. Citing Mesa

63

Mesa Documentation, Release .1

Secondly, we want to display the agent’s wealth at each time step of one specific episode. To do this, we again filter our
large data frame, this time with a fixed number of agents and only for a specific iteration of that population. To print
the results, we convert the filtered data frame to a string specifying the desired columns to print.
Pandas has built-in functions to convert to a lot of different data formats. For example, to display as a table in a Jupyter,
we can use the to_html() function which takes the same arguments as to_string() (see commented lines).
# First, we filter the results
one_episode_wealth = results_df[(results_df.n == 10) & (results_df.iteration == 2)]
# Then, print the columns of interest of the filtered data frame
print(
one_episode_wealth.to_string(
index=False, columns=["Step", "AgentID", "Wealth"], max_rows=10
)
)
# For a prettier display we can also convert the data frame to html
# Uncomment the two lines below to test in Jupyter
# from IPython.display import display, HTML
# display(HTML(one_episode_wealth.to_html(index=False, columns=['Step',
# 'AgentID', 'Wealth'], max_rows=25)))
Step
0
1
1
1
1
...
100
100
100

AgentID
NaN
1.0
2.0
3.0
4.0
...
6.0
7.0
8.0

Wealth
NaN
1.0
1.0
1.0
1.0
...
1.0
1.0
1.0
(continues on next page)

64

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

100
100

9.0
10.0

1.0
0.0

Lastly, we want to take a look at the development of the Gini coefficient over the course of one iteration. Filtering and
printing looks almost the same as above, only this time we choose a different episode.
results_one_episode = results_df[
(results_df.n == 10) & (results_df.iteration == 1) & (results_df.AgentID == 1)
]
print(results_one_episode.to_string(index=False, columns=["Step", "Gini"], max_rows=10))
Step
1
2
3
4
5
...
96
97
98
99
100

Gini
0.0
0.0
0.0
0.0
0.0
...
0.0
0.0
0.0
0.0
0.0

2.4.1.3.6.101 Next Steps
Check out the comparing 5 scenarios on analyzing batch_run results.
[Comer2014] Comer, Kenneth W. “Who Goes First?
An Examination of the Impact of Activation on Outcome Behavior in AgentBased Models.” George Mason University,
2014.
http://mars.gmu.edu/bitstream/handle/1920/9070/Comer_gmu_0883E_10539.pdf
[Dragulescu2002] Drăgulescu, Adrian A., and Victor M. Yakovenko. “Statistical Mechanics of Money, Income, and
Wealth: A Short Survey.” arXiv Preprint Cond-mat/0211175, 2002. http://arxiv.org/abs/cond-mat/0211175.
2.4.1.3.6.102 Comparing Scenarios
2.4.1.3.6.103 The Boltzmann Wealth Model
If you want to get straight to the tutorial checkout these environment providers: (with Google Account) (No Google
Account) (This can take 30 seconds to 5 minutes to load)
If you are running locally, please ensure you have the latest Mesa version installed.
2.4.1.3.6.104 Tutorial Description
This tutorial extends the Boltzmann wealth model from the Batch Run tutorial, by showing some ways in which users
can analyze batch_run results.
If you are starting here please see the Running Your First Model tutorial for dependency and start-up instructions

2.4. Citing Mesa

65

Mesa Documentation, Release .1

2.4.1.3.6.105 IN COLAB? - Run the next cell
2.4.1.3.6.106 Import Dependencies
This includes importing of dependencies needed for the tutorial.
# Has multi-dimensional arrays and matrices.
# Has a large collection of mathematical functions to operate on these arrays.
import numpy as np
# Data manipulation and analysis.
import pandas as pd
# Data visualization tools.
import seaborn as sns
import mesa
# Import Cell Agent and OrthogonalMooreGrid
from mesa.discrete_space import CellAgent, OrthogonalMooreGrid
2.4.1.3.6.107 Base Model
The below provides the base model from which we conduct a parameter sweep by altering the population parameter
and running each variation for 5 scenarios.
This is from the Batch Run tutorial tutorial. If you have any questions about it functionality please review that tutorial.
def compute_gini(model):
agent_wealths = [agent.wealth for agent in model.agents]
x = sorted(agent_wealths)
n = model.num_agents
B = sum(xi * (n - i) for i, xi in enumerate(x)) / (n * sum(x))
return 1 + (1 / n) - 2 * B

class MoneyAgent(CellAgent):
"""An agent with fixed initial wealth."""
def __init__(self, model, cell):
super().__init__(model)
self.cell = cell
self.wealth = 1
self.steps_not_given = 0
def move(self):
self.cell = self.cell.neighborhood.select_random_cell()
def give_money(self):
cellmates = [a for a in self.cell.agents if a is not self]
if len(cellmates) > 0 and self.wealth > 0:
other = self.random.choice(cellmates)
other.wealth += 1
(continues on next page)

66

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

self.wealth -= 1
self.steps_not_given = 0
else:
self.steps_not_given += 1

class MoneyModel(mesa.Model):
"""A model with some number of agents."""
def __init__(self, n, width, height, seed=None):
super().__init__(seed=seed)
self.num_agents = n
self.grid = OrthogonalMooreGrid(
(width, height), torus=True, capacity=10, random=self.random
)
# Instantiate DataCollector
self.datacollector = mesa.DataCollector(
model_reporters={"Gini": compute_gini},
agent_reporters={"Wealth": "wealth", "Steps_not_given": "steps_not_given"},
)
self.running = True
# Create agents
agents = MoneyAgent.create_agents(
self,
self.num_agents,
self.random.choices(self.grid.all_cells.cells, k=self.num_agents),
)
def step(self):
# Collect data each step
self.datacollector.collect(self)
self.agents.shuffle_do("move")
self.agents.do("give_money")
params = {"width": 10, "height": 10, "n": range(5, 105, 5)}
results = mesa.batch_run(
MoneyModel,
parameters=params,
iterations=5,
max_steps=100,
number_processes=1,
data_collection_period=1,
display_progress=True,
)
0%|

| 0/100 [00:00<?, ?it/s]

We will now extract the results into a pandas dataframe.

2.4. Citing Mesa

67

Mesa Documentation, Release .1

results_df = pd.DataFrame(results)
print(f"The results have {len(results)} rows.")
print(f"The columns of the data frame are {list(results_df.keys())}.")
The results have 525100 rows.
The columns of the data frame are ['RunId', 'iteration', 'Step', 'width', 'height', 'n',
˓→'Gini', 'AgentID', 'Wealth', 'Steps_not_given'].
2.4.1.3.6.108 Analyzing model reporters: Comparing 5 scenarios
Other insights might be gathered when we compare the Gini coefficient of different scenarios. For example, we can
compare the Gini coefficient of a population with 25 agents to the Gini coefficient of a population with 400 agents.
While doing this, we increase the number of iterations to 25 to get a better estimate of the Gini coefficient for each
population size and get usable error estimations.
As we look varying the parameters to see the impact on model outcomes, it is critical to again point out that users can
set the random seed. Due to the often inherent randomness with ABMs the seed becomes crucial for:
• Reproducibility - Being able to replicate the ABM results
• Sensitivity Analysis - Identifying how sensitive/robust your model results are to random fluctuations
Treating the seed as an additional parameter and running numerous scenarios allows us to see the impact of randomness
on this model.
params = {"seed": None, "width": 10, "height": 10, "n": [5, 10, 20, 40, 80]}
results_5s = mesa.batch_run(
MoneyModel,
parameters=params,
iterations=25,
max_steps=100,
number_processes=1,
data_collection_period=1,
display_progress=True,
)

# Need to collect every step

results_5s_df = pd.DataFrame(results_5s)
0%|

| 0/125 [00:00<?, ?it/s]

We filter the results to only contain the data of one agent
# The Gini coefficient will be the same for the entire population at any time.
results_5s_df_filtered = results_5s_df[(results_5s_df.AgentID == 1)]
results_5s_df_filtered.head(3)

1
6
11

RunId
0
0
0

iteration
0
0
0

1

Steps_not_given
0.0

Step
1
2
3

seed
None
None
None

width
10
10
10

height
10
10
10

n
5
5
5

Gini
0.0
0.0
0.0

AgentID
1.0
1.0
1.0

Wealth
1.0
1.0
1.0

\

(continues on next page)

68

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

6
11

1.0
2.0

# Create a lineplot with error bars
g = sns.lineplot(
data=results_5s_df,
x="Step",
y="Gini",
hue="n",
errorbar=("ci", 95),
palette="tab10",
)
g.figure.set_size_inches(8, 4)
plot_title = (
"Gini coefficient for different population sizes\n"
"(mean over 100 runs, with 95% confidence interval)"
)
g.set(title=plot_title, ylabel="Gini coefficient");

In this case it looks like the Gini coefficient increases slower for smaller populations. This can be because of different
things, either because the Gini coefficient is a measure of inequality and the smaller the population, the more likely
it is that the agents are all in the same wealth class, or because there are less interactions between agents in smaller
populations, which means that the wealth of an agent is less likely to change.

2.4. Citing Mesa

69

Mesa Documentation, Release .1

2.4.1.3.6.109 Exercise:
Treat the seed as a parameter and see the impact on the Gini Coefficient
You can also plot the seeds against the Gini Coefficient by changing the “hue” parameter in sns.lineplot function.
2.4.1.3.6.110 Analyzing agent reporters: Comparing 5 scenarios
From the agents we collected the wealth and the number of consecutive rounds without a transaction. We can compare
the 5 different population sizes by plotting the average number of consecutive rounds without a transaction for each
population size.
Note that we’re aggregating multiple times here: First we take the average of all agents for each single replication. Then
we plot the averages for all replications, with the error band showing the 95% confidence interval of that first average
(over all agents). So this error band is representing the uncertainty of the mean value of the number of consecutive
rounds without a transaction for each population size.
# Calculate the mean of the wealth and the number of consecutive rounds
# for all agents in each episode.
agg_results_df = (
results_5s_df.groupby(["iteration", "n", "Step"])
.agg({"Wealth": "mean", "Steps_not_given": "mean"})
.reset_index()
)
agg_results_df.head(3)

0
1
2

iteration
0
0
0

n
5
5
5

Step
0
1
2

Wealth
NaN
1.0
1.0

Steps_not_given
NaN
0.0
1.0

# Create a line plot with error bars
g = sns.lineplot(
data=agg_results_df, x="Step", y="Steps_not_given", hue="n", palette="tab10"
)
g.figure.set_size_inches(8, 4)
g.set(
title="Average number of consecutive rounds without a transaction for "
"different population sizes\n(mean with 95% confidence interval)",
ylabel="Consecutive rounds without a transaction",
);

70

Chapter 2. Using Mesa

Mesa Documentation, Release .1

It can be clearly seen that the lower the number of agents, the higher the number of consecutive rounds without a
transaction. This is because the agents have fewer interactions with each other and therefore the wealth of an agent is
less likely to change.
2.4.1.3.6.111 General steps for analyzing results
Many other analysis are possible based on the policies, scenarios and uncertainties that you might be interested in. In
general, you can follow these steps to do your own analysis:
1. Determine which metrics you want to analyse. Add these as model and agent reporters to the datacollector of
your model.
2. Determine the input parameters you want to vary. Add these as parameters to the batch_run function, using
ranges or lists to test different values.
3. Determine the hyperparameters of the batch_run function. Define the number of iterations, the number of processes, the number of steps, the data collection period, etc.
4. Run the batch_run function and save the results.
5. Transform, filter and aggregate the results to get the data you want to analyze. Make sure it’s in long format, so
that each row represents a single value.
6. Choose a plot type, what to plot on the x and y axis, which columns to use for the hue. Seaborn also has an
amazing Example Gallery.
7. Plot the data and analyze the results.
2.4.1.3.6.112 Exercise:
Update the model in some new way (e.g. a new agent attribute, a new model reporter), conduct a batch run with a
parameter sweep and visualize your results

2.4. Citing Mesa

71

Mesa Documentation, Release .1

2.4.1.3.6.113 That is it you have successfully completed Mesa’s Introductory Tutorial!
2.4.1.3.6.114 More Mesa
If you are looking for other Mesa models or tools here are some additional resources.
• Interactive Dashboard: There is a separate visualization tutorial that will take users through building a dashboard
for this model (aka Boltzmann Wealth Model).
• Example ABMs: Find canonical examples and examples of ABMs demonstrating highlighted features in the
Examples Tab
• Expanded Examples: Want to integrate Reinforcement Learning or work on the Traveling Salesman Problem?
Checkout Mesa Examples
• Mesa-Geo: If you need an ABM with Geographic Information Systems (GIS) checkout Mesa-Geo
• Mesa Frames: Have a large complex model that you need to speed up, check out Mesa Frames
2.4.1.3.6.115 Happy Modeling!
This document is a work in progress. If you see any errors, exclusions or have any problems please contact us.
[Comer2014] Comer, Kenneth W. “Who Goes First?
An Examination of the Impact of Activation on Outcome Behavior in AgentBased Models.” George Mason University,
2014.
http://mars.gmu.edu/bitstream/handle/1920/9070/Comer_gmu_0883E_10539.pdf
[Dragulescu2002] Drăgulescu, Adrian A., and Victor M. Yakovenko. “Statistical Mechanics of Money, Income, and
Wealth: A Short Survey.” arXiv Preprint Cond-mat/0211175, 2002. http://arxiv.org/abs/cond-mat/0211175.
2.4.1.3.6.116 Best Practices
Here are some general principles that have proven helpful for developing models.
2.4.1.3.6.117 Model Layout
A model should be contained in a folder named with lower-case letters and underscores, such as wolf_sheep. Within
that directory:
• Readme.md describes the model, how to use it, and any other details.
• model.py should contain the model class.
• agents.py should contain the agent class(es).
• app.py should contain the Solara-based visualization code (optional).
You can add more files as needed, for example:
• run.py could contain the code to run the model.
• batch_run.py could contain the code to run the model multiple times.
• analysis.py could contain any analysis code.
Input data can be stored in a data directory, output data in an output, processed results in a results directory, images
in an images directory, etc.
All our examples follow this layout.

72

Chapter 2. Using Mesa

Mesa Documentation, Release .1

2.4.1.3.6.118 Randomization
If your model involves some random choice, you can use the built-in random property that many Mesa objects have,
including Model, Agent, and AgentSet. This works exactly like the built-in random library.
class AwesomeModel(Model):
# ...
def cool_method(self):
interesting_number = self.random.random()
print(interesting_number)
class AwesomeAgent(Agent):
# ...
def __init__(self, unique_id, model, ...):
super().__init__(unique_id, model)
# ...
def my_method(self):
random_number = self.random.randint(0, 100)
Agent.random is just a convenient shorthand in the Agent class to self.model.random. If you create your
own AgentSet instances, you have to pass random explicitly. Typically, you can simply do, in a Model instance,
my_agentset = AgentSet([], random=self.random). This ensures that my_agentset uses the same random
number generator as the rest of the model.
When a model object is created, its random property is automatically seeded with the current time. The seed determines
the sequence of random numbers; if you instantiate a model with the same seed, you will get the same results. To allow
you to set the seed, make sure your model has a seed argument in its __init__.
class AwesomeModel(Model):
def __init__(self, seed=None):
super().__init__(seed=seed)
...
def cool_method(self):
interesting_number = self.random.random()
print(interesting_number)
>>> model0 = AwesomeModel(seed=0)
>>> model0._seed
0
>>> model0.cool_method()
0.8444218515250481
>>> model1 = AwesomeModel(seed=0)
>>> model1.cool_method()
0.8444218515250481

2.4.2 Mesa Core Examples
This repository contains a curated set of classic agent-based models implemented using Mesa. These core examples
are maintained by the Mesa development team and serve as both demonstrations of Mesa’s capabilities and starting
points for your own models.

2.4. Citing Mesa

73

Mesa Documentation, Release .1

2.4.2.1 Overview
The examples are categorized into two groups:
1. Basic Examples - Simpler models that use only stable Mesa features; ideal for beginners
2. Advanced Examples - More complex models that demonstrate additional concepts and may use some experimental features
Note: Looking for more examples? Visit the mesa-examples repository for user-contributed models and
showcases.
2.4.2.2 Basic Examples
The basic examples are relatively simple and only use stable Mesa features. They are good starting points for learning
how to use Mesa.
2.4.2.2.1 Boltzmann Wealth Model
Completed code to go along with the tutorial on making a simple model of how a highly-skewed wealth distribution
can emerge from simple rules.
2.4.2.2.2 Boids Flockers Model
Boids-style flocking model, demonstrating the use of agents moving through a continuous space following direction
vectors.
2.4.2.2.3 Conway’s Game of Life
Implementation of Conway’s Game of Life, a cellular automata where simple rules can give rise to complex patterns.
2.4.2.2.4 Schelling Segregation Model
Mesa implementation of the classic Schelling segregation model.
2.4.2.2.5 Virus on a Network Model
This model is based on the NetLogo Virus on a Network model.
2.4.2.3 Advanced Examples
The advanced examples are more complex and may use experimental Mesa features. They are good starting points for
learning how to build more complex models.
2.4.2.3.1 Epstein Civil Violence Model
Joshua Epstein’s model of how a decentralized uprising can be suppressed or reach a critical mass of support.
2.4.2.3.2 Demographic Prisoner’s Dilemma on a Grid
Grid-based demographic prisoner’s dilemma model, demonstrating how simple rules can lead to the emergence of
widespread cooperation – and how a model activation regime can change its outcome.

74

Chapter 2. Using Mesa

Mesa Documentation, Release .1

2.4.2.3.3 Sugarscape Model with Traders
This is Epstein & Axtell’s Sugarscape model with Traders, a detailed description is in Chapter four of Growing Artificial
Societies: Social Science from the Bottom Up (1996). The model shows how emergent price equilibrium can happen
via decentralized dynamics.
2.4.2.3.4 Wolf-Sheep Predation Model
Implementation of an ecological model of predation and reproduction, based on the NetLogo Wolf Sheep Predation
model.
2.4.2.3.4.1 Schelling Segregation Model
2.4.2.3.4.2 Summary
The Schelling segregation model is a classic agent-based model, demonstrating how even a mild preference for similar
neighbors can lead to a much higher degree of segregation than we would intuitively expect. The model consists of
agents on a square grid, where each grid cell can contain at most one agent. Agents come in two colors: red and blue.
They are happy if a certain number of their eight possible neighbors are of the same color, and unhappy otherwise.
Unhappy agents will pick a random empty cell to move to each step, until they are happy. The model keeps running
until there are no unhappy agents.
By default, the number of similar neighbors the agents need to be happy is set to 3. That means the agents would be
perfectly happy with a majority of their neighbors being of a different color (e.g. a Blue agent would be happy with
five Red neighbors and three Blue ones). Despite this, the model consistently leads to a high degree of segregation,
with most agents ending up with no neighbors of a different color.
2.4.2.3.4.3 How to Run
To run the model interactively, in this directory, run the following command
$ solara run app.py
2.4.2.3.4.4 Files
• model.py: Contains the Schelling model class
• agents.py: Contains the Schelling agent class
• app.py: Code for the interactive visualization.
• analysis.ipynb: Notebook demonstrating how to run experiments and parameter sweeps on the model.
2.4.2.3.4.5 Further Reading
Schelling’s original paper describing the model:
Schelling, Thomas C. Dynamic Models of Segregation. Journal of Mathematical Sociology. 1971, Vol. 1, pp 143-186.
An interactive, browser-based explanation and implementation:
Parable of the Polygons, by Vi Hart and Nicky Case.

2.4. Citing Mesa

75

Mesa Documentation, Release .1

2.4.2.3.4.6 Agents
from mesa.discrete_space import CellAgent

class SchellingAgent(CellAgent):
"""Schelling segregation agent."""
def __init__(
self, model, cell, agent_type: int, homophily: float = 0.4, radius: int = 1
) -> None:
"""Create a new Schelling agent.
Args:
model: The model instance the agent belongs to
agent_type: Indicator for the agent's type (minority=1, majority=0)
homophily: Minimum number of similar neighbors needed for happiness
radius: Search radius for checking neighbor similarity
"""
super().__init__(model)
self.cell = cell
self.type = agent_type
self.homophily = homophily
self.radius = radius
def step(self) -> None:
"""Determine if agent is happy and move if necessary."""
neighbors = list(self.cell.get_neighborhood(radius=self.radius).agents)
# Count similar neighbors
similar_neighbors = len([n for n in neighbors if n.type == self.type])
# Calculate the fraction of similar neighbors
if (valid_neighbors := len(neighbors)) > 0:
similarity_fraction = similar_neighbors / valid_neighbors
else:
# If there are no neighbors, the similarity fraction is 0
similarity_fraction = 0.0
# Move if unhappy
if similarity_fraction < self.homophily:
self.cell = self.model.grid.select_random_empty_cell()
else:
self.model.happy += 1

2.4.2.3.4.7 Model
from mesa import Model
from mesa.datacollection import DataCollector
from mesa.discrete_space import OrthogonalMooreGrid
from mesa.examples.basic.schelling.agents import SchellingAgent
(continues on next page)

76

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

class Schelling(Model):
"""Model class for the Schelling segregation model."""
def __init__(
self,
height: int = 20,
width: int = 20,
density: float = 0.8,
minority_pc: float = 0.5,
homophily: float = 0.4,
radius: int = 1,
seed=None,
):
"""Create a new Schelling model.
Args:
width: Width of the grid
height: Height of the grid
density: Initial chance for a cell to be populated (0-1)
minority_pc: Chance for an agent to be in minority class (0-1)
homophily: Minimum number of similar neighbors needed for happiness
radius: Search radius for checking neighbor similarity
seed: Seed for reproducibility
"""
super().__init__(seed=seed)
# Model parameters
self.density = density
self.minority_pc = minority_pc
# Initialize grid
self.grid = OrthogonalMooreGrid((width, height), random=self.random, capacity=1)
# Track happiness
self.happy = 0
# Set up data collection
self.datacollector = DataCollector(
model_reporters={
"happy": "happy",
"pct_happy": lambda m: (m.happy / len(m.agents)) * 100
if len(m.agents) > 0
else 0,
"population": lambda m: len(m.agents),
"minority_pct": lambda m: (
sum(1 for agent in m.agents if agent.type == 1)
/ len(m.agents)
* 100
if len(m.agents) > 0
else 0
),
(continues on next page)

2.4. Citing Mesa

77

Mesa Documentation, Release .1

(continued from previous page)

},
agent_reporters={"agent_type": "type"},
)
# Create agents and place them on the grid
for cell in self.grid.all_cells:
if self.random.random() < self.density:
agent_type = 1 if self.random.random() < minority_pc else 0
SchellingAgent(
self, cell, agent_type, homophily=homophily, radius=radius
)
# Collect initial state
self.datacollector.collect(self)
def step(self):
"""Run one step of the model."""
self.happy = 0 # Reset counter of happy agents
self.agents.shuffle_do("step") # Activate all agents in random order
self.datacollector.collect(self) # Collect data
self.running = self.happy < len(self.agents) # Continue until everyone is happy

2.4.2.3.4.8 App
import solara
from mesa.examples.basic.schelling.model import Schelling
from mesa.visualization import (
Slider,
SolaraViz,
make_plot_component,
make_space_component,
)

def get_happy_agents(model):
"""Display a text count of how many happy agents there are."""
return solara.Markdown(f"**Happy agents: {model.happy}**")

def agent_portrayal(agent):
return {"color": "tab:orange" if agent.type == 0 else "tab:blue"}

model_params = {
"seed": {
"type": "InputText",
"value": 42,
"label": "Random Seed",
},
(continues on next page)

78

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

"density": Slider("Agent density", 0.8, 0.1, 1.0, 0.1),
"minority_pc": Slider("Fraction minority", 0.2, 0.0, 1.0, 0.05),
"homophily": Slider("Homophily", 0.4, 0.0, 1.0, 0.125),
"width": 20,
"height": 20,
}
model1 = Schelling()
HappyPlot = make_plot_component({"happy": "tab:green"})
page = SolaraViz(
model1,
components=[
make_space_component(agent_portrayal),
HappyPlot,
get_happy_agents,
],
model_params=model_params,
)
page # noqa

2.4.2.3.4.9 Boids Flockers
2.4.2.3.4.10 Summary
An implementation of Craig Reynolds’s Boids flocker model. Agents (simulated birds) try to fly towards the average
position of their neighbors and in the same direction as them, while maintaining a minimum distance. This produces
flocking behavior.
This model tests Mesa’s continuous space feature, and uses numpy arrays to represent vectors.
2.4.2.3.4.11 How to Run
To run the model interactively, in this directory, run the following command
$ solara run app.py
2.4.2.3.4.12 Files
• model.py: Ccntains the Boid Model
• agents.py: Contains the Boid agent
• app.py: Solara based Visualization code.
2.4.2.3.4.13 Further Reading
The following link can be visited for more information on the boid flockers
https://cs.stanford.edu/people/eroberts/courses/soco/projects/2008-09/modeling-natural-systems/boids.html

2.4. Citing Mesa

model:

79

Mesa Documentation, Release .1

2.4.2.3.4.14 Agents
"""A Boid (bird-oid) agent for implementing Craig Reynolds's Boids flocking model.
This implementation uses numpy arrays to represent vectors for efficient computation
of flocking behavior.
"""
import numpy as np
from mesa.experimental.continuous_space import ContinuousSpaceAgent

class Boid(ContinuousSpaceAgent):
"""A Boid-style flocker agent.
The agent follows three behaviors to flock:
- Cohesion: steering towards neighboring agents
- Separation: avoiding getting too close to any other agent
- Alignment: trying to fly in the same direction as neighbors
Boids have a vision that defines the radius in which they look for their
neighbors to flock with. Their speed (a scalar) and direction (a vector)
define their movement. Separation is their desired minimum distance from
any other Boid.
"""
def __init__(
self,
model,
space,
position=(0, 0),
speed=1,
direction=(1, 1),
vision=1,
separation=1,
cohere=0.03,
separate=0.015,
match=0.05,
):
"""Create a new Boid flocker agent.
Args:
model: Model instance the agent belongs to
speed: Distance to move per step
direction: numpy vector for the Boid's direction of movement
vision: Radius to look around for nearby Boids
separation: Minimum distance to maintain from other Boids
cohere: Relative importance of matching neighbors' positions (default: 0.03)
separate: Relative importance of avoiding close neighbors (default: 0.015)
match: Relative importance of matching neighbors' directions (default: 0.05)
"""
super().__init__(space, model)
(continues on next page)

80

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

self.position = position
self.speed = speed
self.direction = direction
self.vision = vision
self.separation = separation
self.cohere_factor = cohere
self.separate_factor = separate
self.match_factor = match
self.neighbors = []
self.angle = 0.0 # represents the angle at which the boid is moving
def step(self):
"""Get the Boid's neighbors, compute the new vector, and move accordingly."""
neighbors, distances = self.get_neighbors_in_radius(radius=self.vision)
self.neighbors = [n for n in neighbors if n is not self]
# If no neighbors, maintain current direction
if not neighbors:
self.position += self.direction * self.speed
return
delta = self.space.calculate_difference_vector(self.position, agents=neighbors)
cohere_vector = delta.sum(axis=0) * self.cohere_factor
separation_vector = (
-1 * delta[distances < self.separation].sum(axis=0) * self.separate_factor
)
match_vector = (
np.asarray([n.direction for n in neighbors]).sum(axis=0) * self.match_factor
)
# Update direction based on the three behaviors
self.direction += (cohere_vector + separation_vector + match_vector) / len(
neighbors
)
# Normalize direction vector
self.direction /= np.linalg.norm(self.direction)
# Move boid
self.position += self.direction * self.speed

2.4.2.3.4.15 Model
"""
Boids Flocking Model
===================
A Mesa implementation of Craig Reynolds's Boids flocker model.
Uses numpy arrays to represent vectors.
"""
(continues on next page)

2.4. Citing Mesa

81

Mesa Documentation, Release .1

(continued from previous page)

import os
import sys
sys.path.insert(0, os.path.abspath("../../../.."))

import numpy as np
from mesa import Model
from mesa.examples.basic.boid_flockers.agents import Boid
from mesa.experimental.continuous_space import ContinuousSpace

class BoidFlockers(Model):
"""Flocker model class. Handles agent creation, placement and scheduling."""
def __init__(
self,
population_size=100,
width=100,
height=100,
speed=1,
vision=10,
separation=2,
cohere=0.03,
separate=0.015,
match=0.05,
seed=None,
):
"""Create a new Boids Flocking model.
Args:
population_size: Number of Boids in the simulation (default: 100)
width: Width of the space (default: 100)
height: Height of the space (default: 100)
speed: How fast the Boids move (default: 1)
vision: How far each Boid can see (default: 10)
separation: Minimum distance between Boids (default: 2)
cohere: Weight of cohesion behavior (default: 0.03)
separate: Weight of separation behavior (default: 0.015)
match: Weight of alignment behavior (default: 0.05)
seed: Random seed for reproducibility (default: None)
"""
super().__init__(seed=seed)
self.agent_angles = np.zeros(
population_size
) # holds the angle representing the direction of all agents at a given step
# Set up the space
self.space = ContinuousSpace(
[[0, width], [0, height]],
(continues on next page)

82

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

torus=True,
random=self.random,
n_agents=population_size,
)
# Create and place the Boid agents
positions = self.rng.random(size=(population_size, 2)) * self.space.size
directions = self.rng.uniform(-1, 1, size=(population_size, 2))
Boid.create_agents(
self,
population_size,
self.space,
position=positions,
direction=directions,
cohere=cohere,
separate=separate,
match=match,
speed=speed,
vision=vision,
separation=separation,
)
# For tracking statistics
self.average_heading = None
self.update_average_heading()
# vectorizing the calculation of angles for all agents
def calculate_angles(self):
d1 = np.array([agent.direction[0] for agent in self.agents])
d2 = np.array([agent.direction[1] for agent in self.agents])
self.agent_angles = np.degrees(np.arctan2(d1, d2))
for agent, angle in zip(self.agents, self.agent_angles):
agent.angle = angle
def update_average_heading(self):
"""Calculate the average heading (direction) of all Boids."""
if not self.agents:
self.average_heading = 0
return
headings = np.array([agent.direction for agent in self.agents])
mean_heading = np.mean(headings, axis=0)
self.average_heading = np.arctan2(mean_heading[1], mean_heading[0])
def step(self):
"""Run one step of the model.
All agents are activated in random order using the AgentSet shuffle_do method.
"""
self.agents.shuffle_do("step")
self.update_average_heading()
self.calculate_angles()
(continues on next page)

2.4. Citing Mesa

83

Mesa Documentation, Release .1

(continued from previous page)

2.4.2.3.4.16 App
import os
import sys
from matplotlib.markers import MarkerStyle
sys.path.insert(0, os.path.abspath("../../../.."))
from mesa.examples.basic.boid_flockers.model import BoidFlockers
from mesa.visualization import Slider, SolaraViz, make_space_component
# Pre-compute markers for different angles (e.g., every 10 degrees)
MARKER_CACHE = {}
for angle in range(0, 360, 10):
marker = MarkerStyle(10)
marker._transform = marker.get_transform().rotate_deg(angle)
MARKER_CACHE[angle] = marker

def boid_draw(agent):
neighbors = len(agent.neighbors)
# Calculate the angle
deg = agent.angle
# Round to nearest 10 degrees
rounded_deg = round(deg / 10) * 10 % 360
# using cached markers to speed things up
if neighbors <= 1:
return {"color": "red", "size": 20, "marker": MARKER_CACHE[rounded_deg]}
elif neighbors >= 2:
return {"color": "green", "size": 20, "marker": MARKER_CACHE[rounded_deg]}

model_params = {
"seed": {
"type": "InputText",
"value": 42,
"label": "Random Seed",
},
"population_size": Slider(
label="Number of boids",
value=100,
min=10,
max=200,
step=10,
),
"width": 100,
(continues on next page)

84

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

"height": 100,
"speed": Slider(
label="Speed of Boids",
value=5,
min=1,
max=20,
step=1,
),
"vision": Slider(
label="Vision of Bird (radius)",
value=10,
min=1,
max=50,
step=1,
),
"separation": Slider(
label="Minimum Separation",
value=2,
min=1,
max=20,
step=1,
),
}
model = BoidFlockers()
page = SolaraViz(
model,
components=[make_space_component(agent_portrayal=boid_draw, backend="matplotlib")],
model_params=model_params,
name="Boid Flocking Model",
)
page # noqa

2.4.2.3.4.17 Virus on a Network
2.4.2.3.4.18 Summary
This model is based on the NetLogo model “Virus on Network”. It demonstrates the spread of a virus through a network
and follows the SIR model, commonly seen in epidemiology.
The SIR model is one of the simplest compartmental models, and many models are derivatives of this basic form. The
model consists of three compartments:
S: The number of susceptible individuals. When a susceptible and an infectious individual come into “infectious contact”, the susceptible individual contracts the disease and transitions to the infectious compartment. I: The number of
infectious individuals. These are individuals who have been infected and are capable of infecting susceptible individuals. R for the number of removed (and immune) or deceased individuals. These are individuals who have been infected
and have either recovered from the disease and entered the removed compartment, or died. It is assumed that the number of deaths is negligible with respect to the total population. This compartment may also be called “recovered” or
“resistant”.
For more information about this model, read the NetLogo’s web page: http://ccl.northwestern.edu/netlogo/models/VirusonaNetwork.
2.4. Citing Mesa

85

Mesa Documentation, Release .1

JavaScript library used in this example to render the network: d3.js.
2.4.2.3.4.19 Installation
To install the dependencies use pip and the requirements.txt in this directory. e.g.
$ pip install -r requirements.txt
2.4.2.3.4.20 How to Run
To run the model interactively, in this directory, run the following command
$ solara run app.py
2.4.2.3.4.21 Files
• model.py: Contains the agent class, and the overall model class.
• agents.py: Contains the agent class.
• app.py: Contains the code for the interactive Solara visualization.
2.4.2.3.4.22 Further Reading
Stonedahl, F. and Wilensky, U. (2008). NetLogo Virus on a Network model. Center for Connected Learning and
Computer-Based Modeling, Northwestern University, Evanston, IL.
Wilensky, U. (1999). NetLogo Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.
2.4.2.3.4.23 Agents
from enum import Enum
from mesa.discrete_space import FixedAgent

class State(Enum):
SUSCEPTIBLE = 0
INFECTED = 1
RESISTANT = 2

class VirusAgent(FixedAgent):
"""Individual Agent definition and its properties/interaction methods."""
def __init__(
self,
model,
initial_state,
virus_spread_chance,
virus_check_frequency,
recovery_chance,
gain_resistance_chance,
(continues on next page)

86

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

cell,
):
super().__init__(model)
self.state = initial_state
self.virus_spread_chance = virus_spread_chance
self.virus_check_frequency = virus_check_frequency
self.recovery_chance = recovery_chance
self.gain_resistance_chance = gain_resistance_chance
self.cell = cell
def try_to_infect_neighbors(self):
for agent in self.cell.neighborhood.agents:
if (agent.state is State.SUSCEPTIBLE) and (
self.random.random() < self.virus_spread_chance
):
agent.state = State.INFECTED
def try_gain_resistance(self):
if self.random.random() < self.gain_resistance_chance:
self.state = State.RESISTANT
def try_remove_infection(self):
# Try to remove
if self.random.random() < self.recovery_chance:
# Success
self.state = State.SUSCEPTIBLE
self.try_gain_resistance()
else:
# Failed
self.state = State.INFECTED
def check_situation(self):
if (self.state is State.INFECTED) and (
self.random.random() < self.virus_check_frequency
):
self.try_remove_infection()
def step(self):
if self.state is State.INFECTED:
self.try_to_infect_neighbors()
self.check_situation()

2.4.2.3.4.24 Model
import math
import networkx as nx
(continues on next page)

2.4. Citing Mesa

87

Mesa Documentation, Release .1

(continued from previous page)

import mesa
from mesa import Model
from mesa.discrete_space import CellCollection, Network
from mesa.examples.basic.virus_on_network.agents import State, VirusAgent

def number_state(model, state):
return sum(1 for a in model.grid.all_cells.agents if a.state is state)

def number_infected(model):
return number_state(model, State.INFECTED)

def number_susceptible(model):
return number_state(model, State.SUSCEPTIBLE)

def number_resistant(model):
return number_state(model, State.RESISTANT)

class VirusOnNetwork(Model):
"""A virus model with some number of agents."""
def __init__(
self,
num_nodes=10,
avg_node_degree=3,
initial_outbreak_size=1,
virus_spread_chance=0.4,
virus_check_frequency=0.4,
recovery_chance=0.3,
gain_resistance_chance=0.5,
seed=None,
):
super().__init__(seed=seed)
prob = avg_node_degree / num_nodes
graph = nx.erdos_renyi_graph(n=num_nodes, p=prob)
self.grid = Network(graph, capacity=1, random=self.random)
self.initial_outbreak_size = (
initial_outbreak_size if initial_outbreak_size <= num_nodes else num_nodes
)
self.datacollector = mesa.DataCollector(
{
"Infected": number_infected,
"Susceptible": number_susceptible,
"Resistant": number_resistant,
"R over S": self.resistant_susceptible_ratio,
}
(continues on next page)

88

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

)
VirusAgent.create_agents(
self,
num_nodes,
State.SUSCEPTIBLE,
virus_spread_chance,
virus_check_frequency,
recovery_chance,
gain_resistance_chance,
list(self.grid.all_cells),
)
# Infect some nodes
infected_nodes = CellCollection(
self.random.sample(list(self.grid.all_cells), self.initial_outbreak_size),
random=self.random,
)
for a in infected_nodes.agents:
a.state = State.INFECTED
self.running = True
self.datacollector.collect(self)
def resistant_susceptible_ratio(self):
try:
return number_state(self, State.RESISTANT) / number_state(
self, State.SUSCEPTIBLE
)
except ZeroDivisionError:
return math.inf
def step(self):
self.agents.shuffle_do("step")
# collect data
self.datacollector.collect(self)

2.4.2.3.4.25 App
import math
import solara
from mesa.examples.basic.virus_on_network.model import (
State,
VirusOnNetwork,
number_infected,
)
from mesa.visualization import (
Slider,
(continues on next page)

2.4. Citing Mesa

89

Mesa Documentation, Release .1

(continued from previous page)

SolaraViz,
make_plot_component,
make_space_component,
)

def agent_portrayal(agent):
node_color_dict = {
State.INFECTED: "tab:red",
State.SUSCEPTIBLE: "tab:green",
State.RESISTANT: "tab:gray",
}
return {"color": node_color_dict[agent.state], "size": 10}

def get_resistant_susceptible_ratio(model):
ratio = model.resistant_susceptible_ratio()
ratio_text = r"$\infty$" if ratio is math.inf else f"{ratio:.2f}"
infected_text = str(number_infected(model))
return solara.Markdown(
f"Resistant/Susceptible Ratio: {ratio_text}<br>Infected Remaining: {infected_
˓→text}"
)

model_params = {
"seed": {
"type": "InputText",
"value": 42,
"label": "Random Seed",
},
"num_nodes": Slider(
label="Number of agents",
value=10,
min=10,
max=100,
step=1,
),
"avg_node_degree": Slider(
label="Avg Node Degree",
value=3,
min=3,
max=8,
step=1,
),
"initial_outbreak_size": Slider(
label="Initial Outbreak Size",
value=1,
min=1,
max=10,
step=1,
(continues on next page)

90

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

),
"virus_spread_chance": Slider(
label="Virus Spread Chance",
value=0.4,
min=0.0,
max=1.0,
step=0.1,
),
"virus_check_frequency": Slider(
label="Virus Check Frequency",
value=0.4,
min=0.0,
max=1.0,
step=0.1,
),
"recovery_chance": Slider(
label="Recovery Chance",
value=0.3,
min=0.0,
max=1.0,
step=0.1,
),
"gain_resistance_chance": Slider(
label="Gain Resistance Chance",
value=0.5,
min=0.0,
max=1.0,
step=0.1,
),
}

def post_process_lineplot(ax):
ax.set_ylim(ymin=0)
ax.set_ylabel("# people")
ax.legend(bbox_to_anchor=(1.05, 1.0), loc="upper left")

SpacePlot = make_space_component(agent_portrayal)
StatePlot = make_plot_component(
{"Infected": "tab:red", "Susceptible": "tab:green", "Resistant": "tab:gray"},
post_process=post_process_lineplot,
)
model1 = VirusOnNetwork()
page = SolaraViz(
model1,
components=[
SpacePlot,
StatePlot,
get_resistant_susceptible_ratio,
(continues on next page)

2.4. Citing Mesa

91

Mesa Documentation, Release .1

(continued from previous page)

],
model_params=model_params,
name="Virus Model",
)
page

# noqa

2.4.2.3.4.26 Boltzmann Wealth Model (Tutorial)
2.4.2.3.4.27 Summary
A simple model of agents exchanging wealth. All agents start with the same amount of money. Every step, each agent
with one unit of money or more gives one unit of wealth to another random agent. Mesa’s Getting Started section walks
through the Boltzmann Wealth Model in a series of short introductory tutorials, starting withCreating your First Model.
As the model runs, the distribution of wealth among agents goes from being perfectly uniform (all agents have the same
starting wealth), to highly skewed – a small number have high wealth, more have none at all.
2.4.2.3.4.28 How to Run
To run the model interactively, in this directory, run the following command
$ solara run app.py
2.4.2.3.4.29 Files
• model.py: Final version of the model.
• agents.py: Final version of the agent.
• app.py: Code for the interactive visualization.
2.4.2.3.4.30 Optional
An optional visualization is also provided using Streamlit, which is another popular Python library for creating interactive web applications.
To run the Streamlit app, you will need to install the streamlit and altair libraries:
$ pip install streamlit altair
Then, you can run the Streamlit app using the following command:
$ streamlit run st_app.py
2.4.2.3.4.31 Further Reading
This model is drawn from econophysics and presents a statistical mechanics approach to wealth distribution. Some
examples of further reading on the topic can be found at:
Milakovic, M. A Statistical Equilibrium Model of Wealth Distribution. February, 2001.
Dragulescu, A and Yakovenko, V. Statistical Mechanics of Money, Income, and Wealth: A Short Survey. November,
2002

92

Chapter 2. Using Mesa

Mesa Documentation, Release .1

2.4.2.3.4.32 Agents
from mesa.discrete_space import CellAgent

class MoneyAgent(CellAgent):
"""An agent with fixed initial wealth.
Each agent starts with 1 unit of wealth and can give 1 unit to other agents
if they occupy the same cell.
Attributes:
wealth (int): The agent's current wealth (starts at 1)
"""
def __init__(self, model, cell):
"""Create a new agent.
Args:
model (Model): The model instance that contains the agent
"""
super().__init__(model)
self.cell = cell
self.wealth = 1
def move(self):
"""Move the agent to a random neighboring cell."""
self.cell = self.cell.neighborhood.select_random_cell()
def give_money(self):
"""Give 1 unit of wealth to a random agent in the same cell."""
cellmates = [a for a in self.cell.agents if a is not self]
if cellmates: # Only give money if there are other agents present
other = self.random.choice(cellmates)
other.wealth += 1
self.wealth -= 1
def step(self):
"""Execute one step for the agent:
1. Move to a neighboring cell
2. If wealth > 0, maybe give money to another agent in the same cell
"""
self.move()
if self.wealth > 0:
self.give_money()

2.4.2.3.4.33 Model
"""
Boltzmann Wealth Model
(continues on next page)

2.4. Citing Mesa

93

Mesa Documentation, Release .1

(continued from previous page)

=====================
A simple model of wealth distribution based on the Boltzmann-Gibbs distribution.
Agents move randomly on a grid, giving one unit of wealth to a random neighbor
when they occupy the same cell.
"""
from mesa import Model
from mesa.datacollection import DataCollector
from mesa.discrete_space import OrthogonalMooreGrid
from mesa.examples.basic.boltzmann_wealth_model.agents import MoneyAgent

class BoltzmannWealth(Model):
"""A simple model of an economy where agents exchange currency at random.
All agents begin with one unit of currency, and each time step agents can give
a unit of currency to another agent in the same cell. Over time, this produces
a highly skewed distribution of wealth.
Attributes:
num_agents (int): Number of agents in the model
grid (MultiGrid): The space in which agents move
running (bool): Whether the model should continue running
datacollector (DataCollector): Collects and stores model data
"""
def __init__(self, n=100, width=10, height=10, seed=None):
"""Initialize the model.
Args:
n (int, optional): Number of agents. Defaults to 100.
width (int, optional): Grid width. Defaults to 10.
height (int, optional): Grid height. Defaults to 10.
seed (int, optional): Random seed. Defaults to None.
"""
super().__init__(seed=seed)
self.num_agents = n
self.grid = OrthogonalMooreGrid((width, height), random=self.random)
# Set up data collection
self.datacollector = DataCollector(
model_reporters={"Gini": self.compute_gini},
agent_reporters={"Wealth": "wealth"},
)
MoneyAgent.create_agents(
self,
self.num_agents,
self.random.choices(self.grid.all_cells.cells, k=self.num_agents),
)
(continues on next page)

94

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

self.running = True
self.datacollector.collect(self)
def step(self):
self.agents.shuffle_do("step") # Activate all agents in random order
self.datacollector.collect(self) # Collect data
def compute_gini(self):
"""Calculate the Gini coefficient for the model's current wealth distribution.
The Gini coefficient is a measure of inequality in distributions.
- A Gini of 0 represents complete equality, where all agents have equal wealth.
- A Gini of 1 represents maximal inequality, where one agent has all wealth.
"""
agent_wealths = [agent.wealth for agent in self.agents]
x = sorted(agent_wealths)
n = self.num_agents
# Calculate using the standard formula for Gini coefficient
b = sum(xi * (n - i) for i, xi in enumerate(x)) / (n * sum(x))
return 1 + (1 / n) - 2 * b

2.4.2.3.4.34 App
from mesa.examples.basic.boltzmann_wealth_model.model import BoltzmannWealth
from mesa.mesa_logging import INFO, log_to_stderr
from mesa.visualization import (
SolaraViz,
make_plot_component,
make_space_component,
)
log_to_stderr(INFO)

def agent_portrayal(agent):
color = agent.wealth # we are using a colormap to translate wealth to color
return {"color": color}

model_params = {
"seed": {
"type": "InputText",
"value": 42,
"label": "Random Seed",
},
"n": {
"type": "SliderInt",
"value": 50,
"label": "Number of agents:",
"min": 10,
(continues on next page)

2.4. Citing Mesa

95

Mesa Documentation, Release .1

(continued from previous page)

"max": 100,
"step": 1,
},
"width": 10,
"height": 10,
}

def post_process(ax):
ax.get_figure().colorbar(ax.collections[0], label="wealth", ax=ax)

# Create initial model instance
model = BoltzmannWealth(50, 10, 10)
# Create visualization elements. The visualization elements are solara components
# that receive the model instance as a "prop" and display it in a certain way.
# Under the hood these are just classes that receive the model instance.
# You can also author your own visualization elements, which can also be functions
# that receive the model instance and return a valid solara component.
SpaceGraph = make_space_component(
agent_portrayal, cmap="viridis", vmin=0, vmax=10, post_process=post_process
)
GiniPlot = make_plot_component("Gini")
# Create the SolaraViz page. This will automatically create a server and display the
# visualization elements in a web browser.
# Display it using the following command in the example directory:
# solara run app.py
# It will automatically update and display any changes made to this file
page = SolaraViz(
model,
components=[SpaceGraph, GiniPlot],
model_params=model_params,
name="Boltzmann Wealth Model",
)
page # noqa

# In a notebook environment, we can also display the visualization elements directly
# SpaceGraph(model1)
# GiniPlot(model1)
# The plots will be static. If you want to pick up model steps,
# you have to make the model reactive first
# reactive_model = solara.reactive(model1)
# SpaceGraph(reactive_model)
# In a different notebook block:
# reactive_model.value.step()

96

Chapter 2. Using Mesa

Mesa Documentation, Release .1

2.4.2.3.4.35 Conway’s Game Of “Life”
2.4.2.3.4.36 Summary
The Game of Life, also known simply as “Life”, is a cellular automaton devised by the British mathematician John
Horton Conway in 1970.
The “game” is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input
by a human. One interacts with the Game of “Life” by creating an initial configuration and observing how it evolves,
or, for advanced “players”, by creating patterns with particular properties.
2.4.2.3.4.37 How to Run
To run the model interactively, in this directory, run the following command
$ solara run app.py
2.4.2.3.4.38 Files
• agents.py: Defines the behavior of an individual cell, which can be in two states: DEAD or ALIVE.
• model.py: Defines the model itself, initialized with a random configuration of alive and dead cells.
• app.py: Defines an interactive visualization using solara.
• st_app.py: Defines an interactive visualization using Streamlit.
2.4.2.3.4.39 Optional
• For the streamlit version, you need to have streamlit installed (can be done via pip install streamlit)
2.4.2.3.4.40 Further Reading
Conway’s Game of Life
2.4.2.3.4.41 Agents
from mesa.discrete_space import FixedAgent

class Cell(FixedAgent):
"""Represents a single ALIVE or DEAD cell in the simulation."""
DEAD = 0
ALIVE = 1
@property
def x(self):
return self.cell.coordinate[0]
@property
def y(self):
return self.cell.coordinate[1]
def __init__(self, model, cell, init_state=DEAD):
(continues on next page)

2.4. Citing Mesa

97

Mesa Documentation, Release .1

(continued from previous page)

"""Create a cell, in the given state, at the given x, y position."""
super().__init__(model)
self.cell = cell
self.state = init_state
self._next_state = None
@property
def is_alive(self):
return self.state == self.ALIVE
@property
def neighbors(self):
return self.cell.neighborhood.agents
def determine_state(self):
"""Compute if the cell will be dead or alive at the next tick. This is
based on the number of alive or dead neighbors. The state is not
changed here, but is just computed and stored in self._nextState,
because our current state may still be necessary for our neighbors
to calculate their next state.
"""
# Get the neighbors and apply the rules on whether to be alive or dead
# at the next tick.
live_neighbors = sum(neighbor.is_alive for neighbor in self.neighbors)
# Assume nextState is unchanged, unless changed below.
self._next_state = self.state
if self.is_alive:
if live_neighbors < 2 or live_neighbors > 3:
self._next_state = self.DEAD
else:
if live_neighbors == 3:
self._next_state = self.ALIVE
def assume_state(self):
"""Set the state to the new computed state -- computed in step()."""
self.state = self._next_state

2.4.2.3.4.42 Model
from mesa import Model
from mesa.discrete_space import OrthogonalMooreGrid
from mesa.examples.basic.conways_game_of_life.agents import Cell

class ConwaysGameOfLife(Model):
"""Represents the 2-dimensional array of cells in Conway's Game of Life."""
def __init__(self, width=50, height=50, initial_fraction_alive=0.2, seed=None):
"""Create a new playing area of (width, height) cells."""
(continues on next page)

98

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

super().__init__(seed=seed)
# Use a simple grid, where edges wrap around.
self.grid = OrthogonalMooreGrid((width, height), capacity=1, torus=True)
# Place a cell at each location, with some initialized to
# ALIVE and some to DEAD.
for cell in self.grid.all_cells:
Cell(
self,
cell,
init_state=Cell.ALIVE
if self.random.random() < initial_fraction_alive
else Cell.DEAD,
)
self.running = True
def step(self):
"""Perform the model step in two stages:
- First, all cells assume their next state (whether they will be dead or alive)
- Then, all cells change state to their next state.
"""
self.agents.do("determine_state")
self.agents.do("assume_state")

2.4.2.3.4.43 App
from mesa.examples.basic.conways_game_of_life.model import ConwaysGameOfLife
from mesa.visualization import (
SolaraViz,
make_space_component,
)

def agent_portrayal(agent):
return {
"color": "white" if agent.state == 0 else "black",
"marker": "s",
"size": 25,
}

def post_process(ax):
ax.set_aspect("equal")
ax.set_xticks([])
ax.set_yticks([])

model_params = {
"seed": {
(continues on next page)

2.4. Citing Mesa

99

Mesa Documentation, Release .1

(continued from previous page)

"type": "InputText",
"value": 42,
"label": "Random Seed",
},
"width": {
"type": "SliderInt",
"value": 50,
"label": "Width",
"min": 5,
"max": 60,
"step": 1,
},
"height": {
"type": "SliderInt",
"value": 50,
"label": "Height",
"min": 5,
"max": 60,
"step": 1,
},
"initial_fraction_alive": {
"type": "SliderFloat",
"value": 0.2,
"label": "Cells initially alive",
"min": 0,
"max": 1,
"step": 0.01,
},
}
# Create initial model instance
model1 = ConwaysGameOfLife()
# Create visualization elements. The visualization elements are solara components
# that receive the model instance as a "prop" and display it in a certain way.
# Under the hood these are just classes that receive the model instance.
# You can also author your own visualization elements, which can also be functions
# that receive the model instance and return a valid solara component.
SpaceGraph = make_space_component(
agent_portrayal, post_process=post_process, draw_grid=False
)

# Create the SolaraViz page. This will automatically create a server and display the
# visualization elements in a web browser.
# Display it using the following command in the example directory:
# solara run app.py
# It will automatically update and display any changes made to this file
page = SolaraViz(
model1,
components=[SpaceGraph],
model_params=model_params,
(continues on next page)

100

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

name="Game of Life",
)
page

# noqa

2.4.2.3.4.44 Epstein Civil Violence Model
2.4.2.3.4.45 Summary
This model is based on Joshua Epstein’s simulation of how civil unrest grows and is suppressed. Citizen agents wander
the grid randomly, and are endowed with individual risk aversion and hardship levels; there is also a universal regime
legitimacy value. There are also Cop agents, who work on behalf of the regime. Cops arrest Citizens who are actively
rebelling; Citizens decide whether to rebel based on their hardship and the regime legitimacy, and their perceived
probability of arrest.
The model generates mass uprising as self-reinforcing processes: if enough agents are rebelling, the probability of any
individual agent being arrested is reduced, making more agents more likely to join the uprising. However, the more
rebelling Citizens the Cops arrest, the less likely additional agents become to join.
2.4.2.3.4.46 How to Run
To run the model interactively, in this directory, run the following command
$ solara run app.py
2.4.2.3.4.47 Files
• model.py: Core model code.
• agent.py: Agent classes.
• app.py: Sets up the interactive visualization.
• Epstein Civil Violence.ipynb: Jupyter notebook conducting some preliminary analysis of the model.
2.4.2.3.4.48 Further Reading
This model is based adapted from:
Epstein, J. “Modeling civil violence: An agent-based computational approach”, Proceedings of the National Academy
of Sciences, Vol. 99, Suppl. 3, May 14, 2002
A similar model is also included with NetLogo:
Wilensky, U. (2004). NetLogo Rebellion model. http://ccl.northwestern.edu/netlogo/models/Rebellion. Center for
Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.
2.4.2.3.4.49 Agents
import math
from enum import Enum
import mesa

(continues on next page)

2.4. Citing Mesa

101

Mesa Documentation, Release .1

(continued from previous page)

class CitizenState(Enum):
ACTIVE = 1
QUIET = 2
ARRESTED = 3

class EpsteinAgent(mesa.discrete_space.CellAgent):
def update_neighbors(self):
"""
Look around and see who my neighbors are
"""
self.neighborhood = self.cell.get_neighborhood(radius=self.vision)
self.neighbors = self.neighborhood.agents
self.empty_neighbors = [c for c in self.neighborhood if c.is_empty]
def move(self):
if self.model.movement and self.empty_neighbors:
new_pos = self.random.choice(self.empty_neighbors)
self.move_to(new_pos)

class Citizen(EpsteinAgent):
"""
A member of the general population, may or may not be in active rebellion.
Summary of rule: If grievance - risk > threshold, rebel.
Attributes:
hardship: Agent's 'perceived hardship (i.e., physical or economic
privation).' Exogenous, drawn from U(0,1).
regime_legitimacy: Agent's perception of regime legitimacy, equal
across agents. Exogenous.
risk_aversion: Exogenous, drawn from U(0,1).
threshold: if (grievance - (risk_aversion * arrest_probability)) >
threshold, go/remain Active
vision: number of cells in each direction (N, S, E and W) that agent
can inspect
condition: Can be "Quiescent" or "Active;" deterministic function of
greivance, perceived risk, and
grievance: deterministic function of hardship and regime_legitimacy;
how aggrieved is agent at the regime?
arrest_probability: agent's assessment of arrest probability, given
rebellion
"""
def __init__(
self, model, regime_legitimacy, threshold, vision, arrest_prob_constant
):
"""
Create a new Citizen.
Args:
model: the model to which the agent belongs
hardship: Agent's 'perceived hardship (i.e., physical or economic
(continues on next page)

102

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

privation).' Exogenous, drawn from U(0,1).
regime_legitimacy: Agent's perception of regime legitimacy, equal
across agents. Exogenous.
risk_aversion: Exogenous, drawn from U(0,1).
threshold: if (grievance - (risk_aversion * arrest_probability)) >
threshold, go/remain Active
vision: number of cells in each direction (N, S, E and W) that
agent can inspect. Exogenous.
model: model instance
"""
super().__init__(model)
self.hardship = self.random.random()
self.risk_aversion = self.random.random()
self.regime_legitimacy = regime_legitimacy
self.threshold = threshold
self.state = CitizenState.QUIET
self.vision = vision
self.jail_sentence = 0
self.grievance = self.hardship * (1 - self.regime_legitimacy)
self.arrest_prob_constant = arrest_prob_constant
self.arrest_probability = None
self.neighborhood = []
self.neighbors = []
self.empty_neighbors = []
def step(self):
"""
Decide whether to activate, then move if applicable.
"""
if self.jail_sentence:
self.jail_sentence -= 1
return # no other changes or movements if agent is in jail.
self.update_neighbors()
self.update_estimated_arrest_probability()
net_risk = self.risk_aversion * self.arrest_probability
if (self.grievance - net_risk) > self.threshold:
self.state = CitizenState.ACTIVE
else:
self.state = CitizenState.QUIET
self.move()
def update_estimated_arrest_probability(self):
"""
Based on the ratio of cops to actives in my neighborhood, estimate the
p(Arrest | I go active).
"""
cops_in_vision = 0
actives_in_vision = 1 # citizen counts herself
for neighbor in self.neighbors:
(continues on next page)

2.4. Citing Mesa

103

Mesa Documentation, Release .1

(continued from previous page)

if isinstance(neighbor, Cop):
cops_in_vision += 1
elif neighbor.state == CitizenState.ACTIVE:
actives_in_vision += 1
# there is a body of literature on this equation
# the round is not in the pnas paper but without it, its impossible to replicate
# the dynamics shown there.
self.arrest_probability = 1 - math.exp(
-1 * self.arrest_prob_constant * round(cops_in_vision / actives_in_vision)
)

class Cop(EpsteinAgent):
"""
A cop for life. No defection.
Summary of rule: Inspect local vision and arrest a random active agent.
Attributes:
unique_id: unique int
x, y: Grid coordinates
vision: number of cells in each direction (N, S, E and W) that cop is
able to inspect
"""
def __init__(self, model, vision, max_jail_term):
"""
Create a new Cop.
Args:
x, y: Grid coordinates
vision: number of cells in each direction (N, S, E and W) that
agent can inspect. Exogenous.
model: model instance
"""
super().__init__(model)
self.vision = vision
self.max_jail_term = max_jail_term
def step(self):
"""
Inspect local vision and arrest a random active agent. Move if
applicable.
"""
self.update_neighbors()
active_neighbors = []
for agent in self.neighbors:
if isinstance(agent, Citizen) and agent.state == CitizenState.ACTIVE:
active_neighbors.append(agent)
if active_neighbors:
arrestee = self.random.choice(active_neighbors)
arrestee.jail_sentence = self.random.randint(0, self.max_jail_term)
arrestee.state = CitizenState.ARRESTED
(continues on next page)

104

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

self.move()

2.4.2.3.4.50 Model
import mesa
from mesa.examples.advanced.epstein_civil_violence.agents import (
Citizen,
CitizenState,
Cop,
)

class EpsteinCivilViolence(mesa.Model):
"""
Model 1 from "Modeling civil violence: An agent-based computational
approach," by Joshua Epstein.
http://www.pnas.org/content/99/suppl_3/7243.full
Args:
height: grid height
width: grid width
citizen_density: approximate % of cells occupied by citizens.
cop_density: approximate % of cells occupied by cops.
citizen_vision: number of cells in each direction (N, S, E and W) that
citizen can inspect
cop_vision: number of cells in each direction (N, S, E and W) that cop
can inspect
legitimacy: (L) citizens' perception of regime legitimacy, equal
across all citizens
max_jail_term: (J_max)
active_threshold: if (grievance - (risk_aversion * arrest_probability))
> threshold, citizen rebels
arrest_prob_constant: set to ensure agents make plausible arrest
probability estimates
movement: binary, whether agents try to move at step end
max_iters: model may not have a natural stopping point, so we set a
max.
"""
def __init__(
self,
width=40,
height=40,
citizen_density=0.7,
cop_density=0.074,
citizen_vision=7,
cop_vision=7,
legitimacy=0.8,
max_jail_term=1000,
(continues on next page)

2.4. Citing Mesa

105

Mesa Documentation, Release .1

(continued from previous page)

active_threshold=0.1,
arrest_prob_constant=2.3,
movement=True,
max_iters=1000,
seed=None,
):
super().__init__(seed=seed)
self.movement = movement
self.max_iters = max_iters
self.grid = mesa.discrete_space.OrthogonalVonNeumannGrid(
(width, height), capacity=1, torus=True, random=self.random
)
model_reporters = {
"active": CitizenState.ACTIVE.name,
"quiet": CitizenState.QUIET.name,
"arrested": CitizenState.ARRESTED.name,
}
agent_reporters = {
"jail_sentence": lambda a: getattr(a, "jail_sentence", None),
"arrest_probability": lambda a: getattr(a, "arrest_probability", None),
}
self.datacollector = mesa.DataCollector(
model_reporters=model_reporters, agent_reporters=agent_reporters
)
if cop_density + citizen_density > 1:
raise ValueError("Cop density + citizen density must be less than 1")
for cell in self.grid.all_cells:
klass = self.random.choices(
[Citizen, Cop, None],
cum_weights=[citizen_density, citizen_density + cop_density, 1],
)[0]
if klass == Cop:
cop = Cop(self, vision=cop_vision, max_jail_term=max_jail_term)
cop.move_to(cell)
elif klass == Citizen:
citizen = Citizen(
self,
regime_legitimacy=legitimacy,
threshold=active_threshold,
vision=citizen_vision,
arrest_prob_constant=arrest_prob_constant,
)
citizen.move_to(cell)
self.running = True
self._update_counts()
self.datacollector.collect(self)
(continues on next page)

106

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

def step(self):
"""
Advance the model by one step and collect data.
"""
self.agents.shuffle_do("step")
self._update_counts()
self.datacollector.collect(self)
if self.steps > self.max_iters:
self.running = False
def _update_counts(self):
"""Helper function for counting nr. of citizens in given state."""
counts = self.agents_by_type[Citizen].groupby("state").count()
for state in CitizenState:
setattr(self, state.name, counts.get(state, 0))

2.4.2.3.4.51 App
from mesa.examples.advanced.epstein_civil_violence.agents import (
Citizen,
CitizenState,
Cop,
)
from mesa.examples.advanced.epstein_civil_violence.model import EpsteinCivilViolence
from mesa.visualization import (
Slider,
SolaraViz,
make_plot_component,
make_space_component,
)
COP_COLOR = "#000000"
agent_colors = {
CitizenState.ACTIVE: "#FE6100",
CitizenState.QUIET: "#648FFF",
CitizenState.ARRESTED: "#808080",
}

def citizen_cop_portrayal(agent):
if agent is None:
return
portrayal = {
"size": 50,
}
(continues on next page)

2.4. Citing Mesa

107

Mesa Documentation, Release .1

(continued from previous page)

if isinstance(agent, Citizen):
portrayal["color"] = agent_colors[agent.state]
elif isinstance(agent, Cop):
portrayal["color"] = COP_COLOR
return portrayal

def post_process(ax):
ax.set_aspect("equal")
ax.set_xticks([])
ax.set_yticks([])
ax.get_figure().set_size_inches(10, 10)

model_params = {
"seed": {
"type": "InputText",
"value": 42,
"label": "Random Seed",
},
"height": 40,
"width": 40,
"citizen_density": Slider("Initial Agent Density", 0.7, 0.0, 0.9, 0.1),
"cop_density": Slider("Initial Cop Density", 0.04, 0.0, 0.1, 0.01),
"citizen_vision": Slider("Citizen Vision", 7, 1, 10, 1),
"cop_vision": Slider("Cop Vision", 7, 1, 10, 1),
"legitimacy": Slider("Government Legitimacy", 0.82, 0.0, 1, 0.01),
"max_jail_term": Slider("Max Jail Term", 30, 0, 50, 1),
}
space_component = make_space_component(
citizen_cop_portrayal, post_process=post_process, draw_grid=False
)
chart_component = make_plot_component(
{state.name.lower(): agent_colors[state] for state in CitizenState}
)
epstein_model = EpsteinCivilViolence()
page = SolaraViz(
epstein_model,
components=[space_component, chart_component],
model_params=model_params,
name="Epstein Civil Violence",
)
page # noqa

108

Chapter 2. Using Mesa

Mesa Documentation, Release .1

2.4.2.3.4.52 Alliance Formation Model (Meta-Agent Example)
2.4.2.3.4.53 Summary
This model demonstrates Mesa’s meta agent capability.
Overview of meta agent: Complex systems often have multiple levels of components. A city is not a single entity, but
it is made of districts,neighborhoods, buildings, and people. A forest comprises an ecosystem of trees, plants, animals,
and microorganisms. An organization is not one entity, but is made of departments, sub-departments, and people. A
person is not a single entity, but it is made of micro biomes, organs and cells.
This reality is the motivation for meta-agents. It allows users to represent these multiple levels, where each level can
have agents with sub-agents.
This model demonstrates Mesa’s ability to dynamically create new classes of agents that are composed of existing
agents. These meta-agents inherits functions and attributes from their sub-agents and users can specify new functionality or attributes they want the meta agent to have. For example, if a user is doing a factory simulation with autonomous
systems, each major component of that system can be a sub-agent of the overall robot agent. Or, if someone is doing
a simulation of an organization, individuals can be part of different organizational units that are working for some
purpose.
To provide a simple demonstration of this capability is an alliance formation model.
In this simulation n agents are created, who have two attributes (1) power and (2) preference. Each attribute is a number
between 0 and 1 over a gaussian distribution. Agents then randomly select other agents and use the bilateral shapley
value to determine if they should form an alliance. If the expected utility support an alliances, the agent creates a
meta-agent. Subsequent steps may add agents to the meta-agent, create new instances of similar hierarchy, or create
a new hierarchy level where meta-agents form an alliance of meta-agents. In this visualization of this model a new
meta-agent hierarchy will be a larger node and a new color.
In MetaAgents current configuration, agents being part of multiple meta-agents is not supported.
If you would like to see an example of explicit meta-agent formation see the warehouse model in the Mesa example’s
repository
2.4.2.3.4.54 Installation
This model requires Mesa’s recommended install and scipy
$ pip install mesa[rec]
2.4.2.3.4.55 How to Run
To run the model interactively, in this directory, run the following command
$ solara run app.py
2.4.2.3.4.56 Files
• model.py: Contains creation of agents, the network and management of agent execution.
• agents.py: Contains logic for forming alliances and creation of new agents
• app.py: Contains the code for the interactive Solara visualization.

2.4. Citing Mesa

109

Mesa Documentation, Release .1

2.4.2.3.4.57 Further Reading
The full tutorial describing how the model is built can be found at: https://mesa.readthedocs.io/en/latest/tutorials/intro_tutorial.html
An example of the bilateral shapley value in another model: Techno-Social Energy Infrastructure Siting: Sustainable
Energy Modeling Programming (SEMPro)
2.4.2.3.4.58 Agents
import mesa

class AllianceAgent(mesa.Agent):
"""
Agent has three attributes power (float), position (float) and level (int)
"""
def __init__(self, model, power, position, level=0):
super().__init__(model)
self.power = power
self.position = position
self.level = level
"""
For this demo model agent only need attributes.
More complex models could have functions that define agent behavior.
"""

2.4.2.3.4.59 Model
import networkx as nx
import numpy as np
import mesa
from mesa import Agent
from mesa.examples.advanced.alliance_formation.agents import AllianceAgent
from mesa.experimental.meta_agents.meta_agent import (
create_meta_agent,
find_combinations,
)

class MultiLevelAllianceModel(mesa.Model):
"""
Model for simulating multi-level alliances among agents.
"""
def __init__(self, n=50, mean=0.5, std_dev=0.1, seed=42):
"""
Initialize the model.
(continues on next page)

110

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

Args:
n (int): Number of agents.
mean (float): Mean value for normal distribution.
std_dev (float): Standard deviation for normal distribution.
seed (int): Random seed.
"""
super().__init__(seed=seed)
self.population = n
self.network = nx.Graph() # Initialize the network
self.datacollector = mesa.DataCollector(model_reporters={"Network": "network"})
# Create Agents
power = self.rng.normal(mean, std_dev, n)
power = np.clip(power, 0, 1)
position = self.rng.normal(mean, std_dev, n)
position = np.clip(position, 0, 1)
AllianceAgent.create_agents(self, n, power, position)
agent_ids = [
(agent.unique_id, {"size": 300, "level": 0}) for agent in self.agents
]
self.network.add_nodes_from(agent_ids)
def add_link(self, meta_agent, agents):
"""
Add links between a meta agent and its constituent agents in the network.
Args:
meta_agent (MetaAgent): The meta agent.
agents (list): List of agents.
"""
for agent in agents:
self.network.add_edge(meta_agent.unique_id, agent.unique_id)
def calculate_shapley_value(self, agents):
"""
Calculate the Shapley value of the two agents.
Args:
agents (list): List of agents.
Returns:
tuple: Potential utility, new position, and level.
"""
positions = agents.get("position")
new_position = 1 - (max(positions) - min(positions))
potential_utility = agents.agg("power", sum) * 1.2 * new_position
value_0 = 0.5 * agents[0].power + 0.5 * (potential_utility - agents[1].power)
value_1 = 0.5 * agents[1].power + 0.5 * (potential_utility - agents[0].power)
if value_0 > agents[0].power and value_1 > agents[1].power:
(continues on next page)

2.4. Citing Mesa

111

Mesa Documentation, Release .1

(continued from previous page)

if agents[0].level > agents[1].level:
level = agents[0].level
elif agents[0].level == agents[1].level:
level = agents[0].level + 1
else:
level = agents[1].level
return potential_utility, new_position, level
def only_best_combination(self, combinations):
"""
Filter to keep only the best combination for each agent.
Args:
combinations (list): List of combinations.
Returns:
dict: Unique combinations.
"""
best = {}
# Determine best option for EACH agent
for group, value in combinations:
agent_ids = sorted(group.get("unique_id")) # by default is bilateral
# Deal with all possibilities
if (
agent_ids[0] not in best and agent_ids[1] not in best
): # if neither in add both
best[agent_ids[0]] = [group, value, agent_ids]
best[agent_ids[1]] = [group, value, agent_ids]
elif (
agent_ids[0] in best and agent_ids[1] in best
): # if both in, see if both would be trading up
if (
value[0] > best[agent_ids[0]][1][0]
and value[0] > best[agent_ids[1]][1][0]
):
# Remove the old alliances
del best[best[agent_ids[0]][2][1]]
del best[best[agent_ids[1]][2][0]]
# Add the new alliance
best[agent_ids[0]] = [group, value, agent_ids]
best[agent_ids[1]] = [group, value, agent_ids]
elif (
agent_ids[0] in best
): # if only agent_ids[0] in, see if it would be trading up
if value[0] > best[agent_ids[0]][1][0]:
# Remove the old alliance for agent_ids[0]
del best[best[agent_ids[0]][2][1]]
# Add the new alliance
best[agent_ids[0]] = [group, value, agent_ids]
best[agent_ids[1]] = [group, value, agent_ids]
elif (
(continues on next page)

112

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

):

agent_ids[1] in best
# if only agent_ids[1] in, see if it would be trading up
if value[0] > best[agent_ids[1]][1][0]:
# Remove the old alliance for agent_ids[1]
del best[best[agent_ids[1]][2][0]]
# Add the new alliance
best[agent_ids[0]] = [group, value, agent_ids]
best[agent_ids[1]] = [group, value, agent_ids]

# Create a unique dictionary of the best combinations
unique_combinations = {}
for group, value, agents_nums in best.values():
unique_combinations[tuple(agents_nums)] = [group, value]
return unique_combinations.values()
def step(self):
"""
Execute one step of the model.
"""
# Get all other agents of the same type
agent_types = list(self.agents_by_type.keys())
for agent_type in agent_types:
similar_agents = self.agents_by_type[agent_type]
# Find the best combinations using find_combinations
if (
len(similar_agents) > 1
): # only form alliances if there are more than 1 agent
combinations = find_combinations(
self,
similar_agents,
size=2,
evaluation_func=self.calculate_shapley_value,
filter_func=self.only_best_combination,
)
for alliance, attributes in combinations:
class_name = f"MetaAgentLevel{attributes[2]}"
meta = create_meta_agent(
self,
class_name,
alliance,
Agent,
meta_attributes={
"level": attributes[2],
"power": attributes[0],
"position": attributes[1],
},
)
(continues on next page)

2.4. Citing Mesa

113

Mesa Documentation, Release .1

(continued from previous page)

# Update the network if a new meta agent instance created
if meta:
self.network.add_node(
meta.unique_id,
size=(meta.level + 1) * 300,
level=meta.level,
)
self.add_link(meta, meta.agents)

2.4.2.3.4.60 App
import matplotlib.pyplot as plt
import networkx as nx
import solara
from matplotlib.figure import Figure
from mesa.examples.advanced.alliance_formation.model import MultiLevelAllianceModel
from mesa.visualization import SolaraViz
from mesa.visualization.utils import update_counter
model_params = {
"seed": {
"type": "InputText",
"value": 42,
"label": "Random Seed",
},
"n": {
"type": "SliderInt",
"value": 50,
"label": "Number of agents:",
"min": 10,
"max": 100,
"step": 1,
},
}
# Create visualization elements. The visualization elements are solara components
# that receive the model instance as a "prop" and display it in a certain way.
# Under the hood these are just classes that receive the model instance.
# You can also author your own visualization elements, which can also be functions
# that receive the model instance and return a valid solara component.

@solara.component
def plot_network(model):
update_counter.get()
g = model.network
pos = nx.fruchterman_reingold_layout(g)
fig = Figure()
ax = fig.subplots()
(continues on next page)

114

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

labels = {agent.unique_id: agent.unique_id for agent in model.agents}
node_sizes = [g.nodes[node]["size"] for node in g.nodes]
node_colors = [g.nodes[node]["size"] for node in g.nodes()]
nx.draw(
g,
pos,
node_size=node_sizes,
node_color=node_colors,
cmap=plt.cm.coolwarm,
labels=labels,
ax=ax,
)
solara.FigureMatplotlib(fig)

# Create initial model instance
model = MultiLevelAllianceModel(50)
# Create the SolaraViz page. This will automatically create a server and display the
# visualization elements in a web browser.
# Display it using the following command in the example directory:
# solara run app.py
# It will automatically update and display any changes made to this file
page = SolaraViz(
model,
components=[plot_network],
model_params=model_params,
name="Alliance Formation Model",
)
page # noqa

2.4.2.3.4.61 Demographic Prisoner’s Dilemma on a Grid
2.4.2.3.4.62 Summary
The Demographic Prisoner’s Dilemma is a family of variants on the classic two-player [Prisoner’s Dilemma]. The
model consists of agents, each with a strategy of either Cooperate or Defect. Each agent’s payoff is based on its strategy
and the strategies of its spatial neighbors. After each step of the model, the agents adopt the strategy of their neighbor
with the highest total score.
The model payoff table is:

Cooperate
Defect

Cooperate

Defect

1, 1
D, 0

0, D
0, 0

Where D is the defection bonus, generally set higher than 1. In these runs, the defection bonus is set to $D=1.6$.

2.4. Citing Mesa

115

Mesa Documentation, Release .1

The Demographic Prisoner’s Dilemma demonstrates how simple rules can lead to the emergence of widespread cooperation, despite the Defection strategy dominating each individual interaction game. However, it is also interesting for
another reason: it is known to be sensitive to the activation regime employed in it.
2.4.2.3.4.63 How to Run
To run the model interactively, in this directory, run the following command
$ solara run app.py
2.4.2.3.4.64 Files
• agents.py: contains the agent class.
• model.py: contains the model class; the model takes a activation_order string as an argument, which determines in which order agents are activated: Sequential, Random or Simultaneous.
• app.py: contains the interactive visualization server.
• Demographic Prisoner's Dilemma Activation Schedule.ipynb: Jupyter Notebook for running the
scheduling experiment. This runs the model three times, one for each activation type, and demonstrates how
the activation regime drives the model to different outcomes.
2.4.2.3.4.65 Further Reading
This model is adapted from:
Wilensky, U. (2002). NetLogo PD Basic Evolutionary model. http://ccl.northwestern.edu/netlogo/models/PDBasicEvolutionary.
Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.
The Demographic Prisoner’s Dilemma originates from:
Epstein, J. Zones of Cooperation in Demographic Prisoner’s Dilemma. 1998.
2.4.2.3.4.66 Agents
from mesa.discrete_space import CellAgent

class PDAgent(CellAgent):
"""Agent member of the iterated, spatial prisoner's dilemma model."""
def __init__(self, model, starting_move=None, cell=None):
"""
Create a new Prisoner's Dilemma agent.
Args:
model: model instance
starting_move: If provided, determines the agent's initial state:
C(ooperating) or D(efecting). Otherwise, random.
"""
super().__init__(model)
self.score = 0
self.cell = cell
if starting_move:
self.move = starting_move
(continues on next page)

116

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

else:
self.move = self.random.choice(["C", "D"])
self.next_move = None
@property
def is_cooroperating(self):
return self.move == "C"
def step(self):
"""Get the best neighbor's move, and change own move accordingly
if better than own score."""
# neighbors = self.model.grid.get_neighbors(self.pos, True, include_center=True)
neighbors = [*list(self.cell.neighborhood.agents), self]
best_neighbor = max(neighbors, key=lambda a: a.score)
self.next_move = best_neighbor.move
if self.model.activation_order != "Simultaneous":
self.advance()
def advance(self):
self.move = self.next_move
self.score += self.increment_score()
def increment_score(self):
neighbors = self.cell.neighborhood.agents
if self.model.activation_order == "Simultaneous":
moves = [neighbor.next_move for neighbor in neighbors]
else:
moves = [neighbor.move for neighbor in neighbors]
return sum(self.model.payoff[(self.move, move)] for move in moves)

2.4.2.3.4.67 Model
import mesa
from mesa.discrete_space import OrthogonalMooreGrid
from mesa.examples.advanced.pd_grid.agents import PDAgent

class PdGrid(mesa.Model):
"""Model class for iterated, spatial prisoner's dilemma model."""
activation_regimes = ["Sequential", "Random", "Simultaneous"]
# This dictionary holds the payoff for this agent,
# keyed on: (my_move, other_move)
payoff = {("C", "C"): 1, ("C", "D"): 0, ("D", "C"): 1.6, ("D", "D"): 0}
def __init__(
(continues on next page)

2.4. Citing Mesa

117

Mesa Documentation, Release .1

(continued from previous page)

self, width=50, height=50, activation_order="Random", payoffs=None, seed=None
):
"""
Create a new Spatial Prisoners' Dilemma Model.
Args:
width, height: Grid size. There will be one agent per grid cell.
activation_order: Can be "Sequential", "Random", or "Simultaneous".
Determines the agent activation regime.
payoffs: (optional) Dictionary of (move, neighbor_move) payoffs.
"""
super().__init__(seed=seed)
self.activation_order = activation_order
self.grid = OrthogonalMooreGrid((width, height), torus=True, random=self.random)
if payoffs is not None:
self.payoff = payoffs
PDAgent.create_agents(
self, len(self.grid.all_cells.cells), cell=self.grid.all_cells.cells
)
self.datacollector = mesa.DataCollector(
{
"Cooperating_Agents": lambda m: len(
[a for a in m.agents if a.move == "C"]
)
}
)
self.running = True
self.datacollector.collect(self)
def step(self):
# Activate all agents, based on the activation regime
match self.activation_order:
case "Sequential":
self.agents.do("step")
case "Random":
self.agents.shuffle_do("step")
case "Simultaneous":
self.agents.do("step")
self.agents.do("advance")
case _:
raise ValueError(f"Unknown activation order: {self.activation_order}")
# Collect data
self.datacollector.collect(self)
def run(self, n):
"""Run the model for n steps."""
for _ in range(n):
(continues on next page)

118

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

self.step()

2.4.2.3.4.68 App
"""
Solara-based visualization for the Spatial Prisoner's Dilemma Model.
"""
from mesa.examples.advanced.pd_grid.model import PdGrid
from mesa.visualization import (
Slider,
SolaraViz,
make_plot_component,
make_space_component,
)

def pd_agent_portrayal(agent):
"""
Portrayal function for rendering PD agents in the visualization.
"""
return {
"color": "blue" if agent.move == "C" else "red",
"marker": "s", # square marker
"size": 25,
}

# Model parameters
model_params = {
"seed": {
"type": "InputText",
"value": 42,
"label": "Random Seed",
},
"width": Slider("Grid Width", value=50, min=10, max=100, step=1),
"height": Slider("Grid Height", value=50, min=10, max=100, step=1),
"activation_order": {
"type": "Select",
"value": "Random",
"values": PdGrid.activation_regimes,
"label": "Activation Regime",
},
}

# Create grid visualization component using Altair
grid_viz = make_space_component(agent_portrayal=pd_agent_portrayal)
# Create plot for tracking cooperating agents over time
(continues on next page)

2.4. Citing Mesa

119

Mesa Documentation, Release .1

(continued from previous page)

plot_component = make_plot_component("Cooperating_Agents")
# Initialize model
initial_model = PdGrid()
# Create visualization with all components
page = SolaraViz(
model=initial_model,
components=[grid_viz, plot_component],
model_params=model_params,
name="Spatial Prisoner's Dilemma",
)
page # noqa B018

2.4.2.3.4.69 Wolf-Sheep Predation Model
2.4.2.3.4.70 Summary
A simple ecological model, consisting of three agent types: wolves, sheep, and grass. The wolves and the sheep wander
around the grid at random. Wolves and sheep both expend energy moving around, and replenish it by eating. Sheep
eat grass, and wolves eat sheep if they end up on the same grid cell.
If wolves and sheep have enough energy, they reproduce, creating a new wolf or sheep (in this simplified model, only
one parent is needed for reproduction). The grass on each cell regrows at a constant rate. If any wolves and sheep run
out of energy, they die.
The model is tests and demonstrates several Mesa concepts and features:
• MultiGrid
• Multiple agent types (wolves, sheep, grass)
• Overlay arbitrary text (wolf’s energy) on agent’s shapes while drawing on CanvasGrid
• Agents inheriting a behavior (random movement) from an abstract parent
• Writing a model composed of multiple files.
• Dynamically adding and removing agents from the schedule
2.4.2.3.4.71 How to Run
To run the model interactively, in this directory, run the following command
$ solara run app.py
2.4.2.3.4.72 Files
• wolf_sheep/random_walk.py: This defines the RandomWalker agent, which implements the behavior of
moving randomly across a grid, one cell at a time. Both the Wolf and Sheep agents will inherit from it.
• wolf_sheep/test_random_walk.py: Defines a simple model and a text-only visualization intended to make
sure the RandomWalk class was working as expected. This doesn’t actually model anything, but serves as an
ad-hoc unit test. To run it, cd into the wolf_sheep directory and run python test_random_walk.py. You’ll
see a series of ASCII grids, one per model step, with each cell showing a count of the number of agents in it.

120

Chapter 2. Using Mesa

Mesa Documentation, Release .1

• wolf_sheep/agents.py: Defines the Wolf, Sheep, and GrassPatch agent classes.
• wolf_sheep/scheduler.py: Defines a custom variant on the RandomActivationByType scheduler, where we
can define filters for the get_type_count function.
• wolf_sheep/model.py: Defines the Wolf-Sheep Predation model itself
• wolf_sheep/server.py: Sets up the interactive visualization server
• run.py: Launches a model visualization server.
2.4.2.3.4.73 Further Reading
This model is closely based on the NetLogo Wolf-Sheep Predation Model:
Wilensky, U. (1997). NetLogo Wolf Sheep Predation model. http://ccl.northwestern.edu/netlogo/models/WolfSheepPredation.
Center for Connected Learning and Computer-Based Modeling, Northwestern University, Evanston, IL.
See also the Lotka–Volterra equations for an example of a classic differential-equation model with similar dynamics.
2.4.2.3.4.74 Agents
from mesa.discrete_space import CellAgent, FixedAgent

class Animal(CellAgent):
"""The base animal class."""
def __init__(
self, model, energy=8, p_reproduce=0.04, energy_from_food=4, cell=None
):
"""Initialize an animal.
Args:
model: Model instance
energy: Starting amount of energy
p_reproduce: Probability of reproduction (asexual)
energy_from_food: Energy obtained from 1 unit of food
cell: Cell in which the animal starts
"""
super().__init__(model)
self.energy = energy
self.p_reproduce = p_reproduce
self.energy_from_food = energy_from_food
self.cell = cell
def spawn_offspring(self):
"""Create offspring by splitting energy and creating new instance."""
self.energy /= 2
self.__class__(
self.model,
self.energy,
self.p_reproduce,
self.energy_from_food,
self.cell,
)
(continues on next page)

2.4. Citing Mesa

121

Mesa Documentation, Release .1

(continued from previous page)

def feed(self):
"""Abstract method to be implemented by subclasses."""
def step(self):
"""Execute one step of the animal's behavior."""
# Move to random neighboring cell
self.move()
self.energy -= 1
# Try to feed
self.feed()
# Handle death and reproduction
if self.energy < 0:
self.remove()
elif self.random.random() < self.p_reproduce:
self.spawn_offspring()

class Sheep(Animal):
"""A sheep that walks around, reproduces (asexually) and gets eaten."""
def feed(self):
"""If possible, eat grass at current location."""
grass_patch = next(
obj for obj in self.cell.agents if isinstance(obj, GrassPatch)
)
if grass_patch.fully_grown:
self.energy += self.energy_from_food
grass_patch.fully_grown = False
def move(self):
"""Move towards a cell where there isn't a wolf, and preferably with grown grass.
˓→"""
cells_without_wolves = self.cell.neighborhood.select(
lambda cell: not any(isinstance(obj, Wolf) for obj in cell.agents)
)
# If all surrounding cells have wolves, stay put
if len(cells_without_wolves) == 0:
return
# Among safe cells, prefer those with grown grass
cells_with_grass = cells_without_wolves.select(
lambda cell: any(
isinstance(obj, GrassPatch) and obj.fully_grown for obj in cell.agents
)
)
# Move to a cell with grass if available, otherwise move to any safe cell
target_cells = (
cells_with_grass if len(cells_with_grass) > 0 else cells_without_wolves
(continues on next page)

122

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

)
self.cell = target_cells.select_random_cell()

class Wolf(Animal):
"""A wolf that walks around, reproduces (asexually) and eats sheep."""
def feed(self):
"""If possible, eat a sheep at current location."""
sheep = [obj for obj in self.cell.agents if isinstance(obj, Sheep)]
if sheep: # If there are any sheep present
sheep_to_eat = self.random.choice(sheep)
self.energy += self.energy_from_food
sheep_to_eat.remove()
def move(self):
"""Move to a neighboring cell, preferably one with sheep."""
cells_with_sheep = self.cell.neighborhood.select(
lambda cell: any(isinstance(obj, Sheep) for obj in cell.agents)
)
target_cells = (
cells_with_sheep if len(cells_with_sheep) > 0 else self.cell.neighborhood
)
self.cell = target_cells.select_random_cell()

class GrassPatch(FixedAgent):
"""A patch of grass that grows at a fixed rate and can be eaten by sheep."""
@property
def fully_grown(self):
"""Whether the grass patch is fully grown."""
return self._fully_grown
@fully_grown.setter
def fully_grown(self, value: bool) -> None:
"""Set grass growth state and schedule regrowth if eaten."""
self._fully_grown = value
if not value: # If grass was just eaten
self.model.simulator.schedule_event_relative(
setattr,
self.grass_regrowth_time,
function_args=[self, "fully_grown", True],
)
def __init__(self, model, countdown, grass_regrowth_time, cell):
"""Create a new patch of grass.
Args:
model: Model instance
countdown: Time until grass is fully grown again
(continues on next page)

2.4. Citing Mesa

123

Mesa Documentation, Release .1

(continued from previous page)

grass_regrowth_time: Time needed to regrow after being eaten
cell: Cell to which this grass patch belongs
"""
super().__init__(model)
self._fully_grown = countdown == 0
self.grass_regrowth_time = grass_regrowth_time
self.cell = cell
# Schedule initial growth if not fully grown
if not self.fully_grown:
self.model.simulator.schedule_event_relative(
setattr, countdown, function_args=[self, "fully_grown", True]
)

2.4.2.3.4.75 Model
"""
Wolf-Sheep Predation Model
================================
Replication of the model found in NetLogo:
Wilensky, U. (1997). NetLogo Wolf Sheep Predation model.
http://ccl.northwestern.edu/netlogo/models/WolfSheepPredation.
Center for Connected Learning and Computer-Based Modeling,
Northwestern University, Evanston, IL.
"""
import math
from mesa import Model
from mesa.datacollection import DataCollector
from mesa.discrete_space import OrthogonalVonNeumannGrid
from mesa.examples.advanced.wolf_sheep.agents import GrassPatch, Sheep, Wolf
from mesa.experimental.devs import ABMSimulator

class WolfSheep(Model):
"""Wolf-Sheep Predation Model.
A model for simulating wolf and sheep (predator-prey) ecosystem modelling.
"""
description = (
"A model for simulating wolf and sheep (predator-prey) ecosystem modelling."
)
def __init__(
self,
width=20,
height=20,
(continues on next page)

124

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

initial_sheep=100,
initial_wolves=50,
sheep_reproduce=0.04,
wolf_reproduce=0.05,
wolf_gain_from_food=20,
grass=True,
grass_regrowth_time=30,
sheep_gain_from_food=4,
seed=None,
simulator: ABMSimulator = None,
):
"""Create a new Wolf-Sheep model with the given parameters.
Args:
height: Height of the grid
width: Width of the grid
initial_sheep: Number of sheep to start with
initial_wolves: Number of wolves to start with
sheep_reproduce: Probability of each sheep reproducing each step
wolf_reproduce: Probability of each wolf reproducing each step
wolf_gain_from_food: Energy a wolf gains from eating a sheep
grass: Whether to have the sheep eat grass for energy
grass_regrowth_time: How long it takes for a grass patch to regrow
once it is eaten
sheep_gain_from_food: Energy sheep gain from grass, if enabled
seed: Random seed
simulator: ABMSimulator instance for event scheduling
"""
super().__init__(seed=seed)
self.simulator = simulator
self.simulator.setup(self)
# Initialize model parameters
self.height = height
self.width = width
self.grass = grass
# Create grid using experimental cell space
self.grid = OrthogonalVonNeumannGrid(
[self.height, self.width],
torus=True,
capacity=math.inf,
random=self.random,
)
# Set up data collection
model_reporters = {
"Wolves": lambda m: len(m.agents_by_type[Wolf]),
"Sheep": lambda m: len(m.agents_by_type[Sheep]),
}
if grass:
model_reporters["Grass"] = lambda m: len(
(continues on next page)

2.4. Citing Mesa

125

Mesa Documentation, Release .1

(continued from previous page)

m.agents_by_type[GrassPatch].select(lambda a: a.fully_grown)
)
self.datacollector = DataCollector(model_reporters)
# Create sheep:
Sheep.create_agents(
self,
initial_sheep,
energy=self.rng.random((initial_sheep,)) * 2 * sheep_gain_from_food,
p_reproduce=sheep_reproduce,
energy_from_food=sheep_gain_from_food,
cell=self.random.choices(self.grid.all_cells.cells, k=initial_sheep),
)
# Create Wolves:
Wolf.create_agents(
self,
initial_wolves,
energy=self.rng.random((initial_wolves,)) * 2 * wolf_gain_from_food,
p_reproduce=wolf_reproduce,
energy_from_food=wolf_gain_from_food,
cell=self.random.choices(self.grid.all_cells.cells, k=initial_wolves),
)
# Create grass patches if enabled
if grass:
possibly_fully_grown = [True, False]
for cell in self.grid:
fully_grown = self.random.choice(possibly_fully_grown)
countdown = (
0 if fully_grown else self.random.randrange(0, grass_regrowth_time)
)
GrassPatch(self, countdown, grass_regrowth_time, cell)
# Collect initial data
self.running = True
self.datacollector.collect(self)
def step(self):
"""Execute one step of the model."""
# First activate all sheep, then all wolves, both in random order
self.agents_by_type[Sheep].shuffle_do("step")
self.agents_by_type[Wolf].shuffle_do("step")
# Collect data
self.datacollector.collect(self)

126

Chapter 2. Using Mesa

Mesa Documentation, Release .1

2.4.2.3.4.76 App
from mesa.examples.advanced.wolf_sheep.agents import GrassPatch, Sheep, Wolf
from mesa.examples.advanced.wolf_sheep.model import WolfSheep
from mesa.experimental.devs import ABMSimulator
from mesa.visualization import (
CommandConsole,
Slider,
SolaraViz,
make_plot_component,
make_space_component,
)

def wolf_sheep_portrayal(agent):
if agent is None:
return
portrayal = {
"size": 25,
}
if isinstance(agent, Wolf):
portrayal["color"] = "tab:red"
portrayal["marker"] = "o"
portrayal["zorder"] = 2
elif isinstance(agent, Sheep):
portrayal["color"] = "tab:cyan"
portrayal["marker"] = "o"
portrayal["zorder"] = 2
elif isinstance(agent, GrassPatch):
if agent.fully_grown:
portrayal["color"] = "tab:green"
else:
portrayal["color"] = "tab:brown"
portrayal["marker"] = "s"
portrayal["size"] = 75
return portrayal

model_params = {
"seed": {
"type": "InputText",
"value": 42,
"label": "Random Seed",
},
"grass": {
"type": "Select",
"value": True,
"values": [True, False],
"label": "grass regrowth enabled?",
},
(continues on next page)

2.4. Citing Mesa

127

Mesa Documentation, Release .1

(continued from previous page)

"grass_regrowth_time": Slider("Grass Regrowth Time", 20, 1, 50),
"initial_sheep": Slider("Initial Sheep Population", 100, 10, 300),
"sheep_reproduce": Slider("Sheep Reproduction Rate", 0.04, 0.01, 1.0, 0.01),
"initial_wolves": Slider("Initial Wolf Population", 10, 5, 100),
"wolf_reproduce": Slider(
"Wolf Reproduction Rate",
0.05,
0.01,
1.0,
0.01,
),
"wolf_gain_from_food": Slider("Wolf Gain From Food Rate", 20, 1, 50),
"sheep_gain_from_food": Slider("Sheep Gain From Food", 4, 1, 10),
}

def post_process_space(ax):
ax.set_aspect("equal")
ax.set_xticks([])
ax.set_yticks([])

def post_process_lines(ax):
ax.legend(loc="center left", bbox_to_anchor=(1, 0.9))

space_component = make_space_component(
wolf_sheep_portrayal, draw_grid=False, post_process=post_process_space
)
lineplot_component = make_plot_component(
{"Wolves": "tab:orange", "Sheep": "tab:cyan", "Grass": "tab:green"},
post_process=post_process_lines,
)
simulator = ABMSimulator()
model = WolfSheep(simulator=simulator, grass=True)
page = SolaraViz(
model,
components=[space_component, lineplot_component, CommandConsole],
model_params=model_params,
name="Wolf Sheep",
simulator=simulator,
)
page # noqa

128

Chapter 2. Using Mesa

Mesa Documentation, Release .1

2.4.2.3.4.77 Sugarscape Constant Growback Model with Traders
2.4.2.3.4.78 Summary
This is Epstein & Axtell’s Sugarscape model with Traders, a detailed description is in Chapter four of Growing Artificial
Societies: Social Science from the Bottom Up (1996). The model shows an emergent price equilibrium can happen via
a decentralized dynamics.
This code generally matches the code in the Complexity Explorer Tutorial, but in .py instead of .ipynb format.
2.4.2.3.4.79 Agents:
• Resource: Resource agents grow back at one unit of sugar and spice per time step up to a specified max amount
and can be harvested and traded by the trader agents. (if you do the interactive run, the color will be green if the
resource agent has a bigger amount of sugar, or yellow if it has a bigger amount of spice)
• Traders: Trader agents have the following attributes: (1) metabolism for sugar, (2) metabolism for spice, (3)
vision, (4) initial sugar endowment and (5) initial spice endowment. The traverse the landscape harvesting sugar
and spice and trading with other agents. If they run out of sugar or spice then they are removed from the model.
(red circle if you do the interactive run)
The trader agents traverse the landscape according to rule M:
• Look out as far as vision permits in the four principal lattice directions and identify the unoccupied site(s).
• Considering only unoccupied sites find the nearest position that produces the most welfare using the CobbDouglas function.
• Move to the new position
• Collect all the resources (sugar and spice) at that location (Epstein and Axtell, 1996, p. 99)
The traders trade according to rule T:
• Agents and potential trade partner compute their marginal rates of substitution (MRS), if they are equal end.
• Exchange resources, with spice flowing from the agent with the higher MRS to the agent with the lower MRS
and sugar flowing the opposite direction.
• The price (p) is calculated by taking the geometric mean of the agents’ MRS.
• If p > 1 then p units of spice are traded for 1 unit of sugar; if p < 1 then 1/p units of sugar for 1 unit of spice
• The trade occurs if it will (a) make both agent better off (increases MRS) and (b) does not cause the agents’ MRS
to cross over one another otherwise end.
• This process then repeats until an end condition is met. (Epstein and Axtell, 1996, p. 105)
The model demonstrates several Mesa concepts and features:
• OrthogonalMooreGrid
• Multiple agent types (traders, sugar, spice)
• Dynamically removing agents from the grid and schedule when they die
• Data Collection at the model and agent level
• custom solara matplotlib space visualization

2.4. Citing Mesa

129

Mesa Documentation, Release .1

2.4.2.3.4.80 How to Run
To run the model interactively, in this directory, run the following command
$ solara run app.py
2.4.2.3.4.81 Files
• model.py: The Sugarscape Constant Growback with Traders model.
• agents.py: Defines the Trader agent class and the Resource agent class which contains an amount of sugar and
spice.
• app.py: Runs a visualization server via Solara (solara run app.py).
• sugar_map.txt: Provides sugar and spice landscape in raster type format.
• tests.py: Has tests to ensure that the model reproduces the results in shown in Growing Artificial Societies.
2.4.2.3.4.82 Further Reading
• Growing Artificial Societies
• Complexity Explorer Sugarscape with Traders Tutorial
2.4.2.3.4.83 Agents
import math
from mesa.discrete_space import CellAgent

# Helper function
def get_distance(cell_1, cell_2):
"""
Calculate the Euclidean distance between two positions
used in trade.move()
"""
x1, y1 = cell_1.coordinate
x2, y2 = cell_2.coordinate
dx = x1 - x2
dy = y1 - y2
return math.sqrt(dx**2 + dy**2)

class Trader(CellAgent):
"""
Trader:
- has a metabolism of sugar and spice
- harvest and trade sugar and spice to survive
"""
def __init__(
(continues on next page)

130

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

self,
model,
cell,
sugar=0,
spice=0,
metabolism_sugar=0,
metabolism_spice=0,
vision=0,
):
super().__init__(model)
self.cell = cell
self.sugar = sugar
self.spice = spice
self.metabolism_sugar = metabolism_sugar
self.metabolism_spice = metabolism_spice
self.vision = vision
self.prices = []
self.trade_partners = []
def get_trader(self, cell):
"""
helper function used in self.trade_with_neighbors()
"""
for agent in cell.agents:
if isinstance(agent, Trader):
return agent
def calculate_welfare(self, sugar, spice):
"""
helper function
part 2 self.move()
self.trade()
"""
# calculate total resources
m_total = self.metabolism_sugar + self.metabolism_spice
# Cobb-Douglas functional form; starting on p. 97
# on Growing Artificial Societies
return sugar ** (self.metabolism_sugar / m_total) * spice ** (
self.metabolism_spice / m_total
)
def is_starved(self):
"""
Helper function for self.maybe_die()
"""
return (self.sugar <= 0) or (self.spice <= 0)
def calculate_MRS(self, sugar, spice):
(continues on next page)

2.4. Citing Mesa

131

Mesa Documentation, Release .1

(continued from previous page)

"""
Helper function for
- self.trade()
- self.maybe_self_spice()
Determines what trader agent needs and can give up
"""
return (spice / self.metabolism_spice) / (sugar / self.metabolism_sugar)
def calculate_sell_spice_amount(self, price):
"""
helper function for self.maybe_sell_spice() which is called from
self.trade()
"""
if price >= 1:
sugar = 1
spice = int(price)
else:
sugar = int(1 / price)
spice = 1
return sugar, spice
def sell_spice(self, other, sugar, spice):
"""
used in self.maybe_sell_spice()
exchanges sugar and spice between traders
"""
self.sugar += sugar
other.sugar -= sugar
self.spice -= spice
other.spice += spice
def maybe_sell_spice(self, other, price, welfare_self, welfare_other):
"""
helper function for self.trade()
"""
sugar_exchanged, spice_exchanged = self.calculate_sell_spice_amount(price)
# Assess new sugar and spice amount - what if change did occur
self_sugar = self.sugar + sugar_exchanged
other_sugar = other.sugar - sugar_exchanged
self_spice = self.spice - spice_exchanged
other_spice = other.spice + spice_exchanged
# double check to ensure agents have resources
if (
(continues on next page)

132

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

(self_sugar <= 0)
or (other_sugar <= 0)
or (self_spice <= 0)
or (other_spice <= 0)
):
return False
# trade criteria #1 - are both agents better off?
both_agents_better_off = (
welfare_self < self.calculate_welfare(self_sugar, self_spice)
) and (welfare_other < other.calculate_welfare(other_sugar, other_spice))
# trade criteria #2 is their mrs crossing with potential trade
mrs_not_crossing = self.calculate_MRS(
self_sugar, self_spice
) > other.calculate_MRS(other_sugar, other_spice)
if not (both_agents_better_off and mrs_not_crossing):
return False
# criteria met, execute trade
self.sell_spice(other, sugar_exchanged, spice_exchanged)
return True
def trade(self, other):
"""
helper function used in trade_with_neighbors()
other is a trader agent object
"""
# sanity check to verify code is working as expected
assert self.sugar > 0
assert self.spice > 0
assert other.sugar > 0
assert other.spice > 0
# calculate marginal rate of substitution in Growing Artificial Societies p. 101
mrs_self = self.calculate_MRS(self.sugar, self.spice)
mrs_other = other.calculate_MRS(other.sugar, other.spice)
# calculate each agents welfare
welfare_self = self.calculate_welfare(self.sugar, self.spice)
welfare_other = other.calculate_welfare(other.sugar, other.spice)
if math.isclose(mrs_self, mrs_other):
return
# calculate price
price = math.sqrt(mrs_self * mrs_other)
(continues on next page)

2.4. Citing Mesa

133

Mesa Documentation, Release .1

(continued from previous page)

if mrs_self > mrs_other:
# self is a sugar buyer, spice seller
sold = self.maybe_sell_spice(other, price, welfare_self, welfare_other)
# no trade - criteria not met
if not sold:
return
else:
# self is a spice buyer, sugar seller
sold = other.maybe_sell_spice(self, price, welfare_other, welfare_self)
# no trade - criteria not met
if not sold:
return
# Capture data
self.prices.append(price)
self.trade_partners.append(other.unique_id)
# continue trading
self.trade(other)
######################################################################
#
#
#
MAIN TRADE FUNCTIONS
#
#
#
######################################################################
def move(self):
"""
Function for trader agent to identify optimal move for each step in 4 parts
1 - identify all possible moves
2 - determine which move maximizes welfare
3 - find closest best option
4 - move
"""
# 1. identify all possible moves
neighboring_cells = [
cell
for cell in self.cell.get_neighborhood(self.vision, include_center=True)
if cell.is_empty
]
# 2. determine which move maximizes welfare
welfares = [
self.calculate_welfare(
self.sugar + cell.sugar,
self.spice + cell.spice,
)
for cell in neighboring_cells
]
(continues on next page)

134

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

# 3. Find closest best option
# find the highest welfare in welfares
max_welfare = max(welfares)
# get the index of max welfare cells
# fixme: rewrite using enumerate and single loop
candidate_indices = [
i for i in range(len(welfares)) if math.isclose(welfares[i], max_welfare)
]
# convert index to positions of those cells
candidates = [neighboring_cells[i] for i in candidate_indices]
min_dist = min(get_distance(self.cell, cell) for cell in candidates)
final_candidates = [
cell
for cell in candidates
if math.isclose(get_distance(self.cell, cell), min_dist, rel_tol=1e-02)
]
# 4. Move Agent
self.cell = self.random.choice(final_candidates)
def eat(self):
self.sugar += self.cell.sugar
self.cell.sugar = 0
self.sugar -= self.metabolism_sugar
self.spice += self.cell.spice
self.cell.spice = 0
self.spice -= self.metabolism_spice
def maybe_die(self):
"""
Function to remove Traders who have consumed all their sugar or spice
"""
if self.is_starved():
self.remove()
def trade_with_neighbors(self):
"""
Function for trader agents to decide who to trade with in three parts
1- identify neighbors who can trade
2- trade (2 sessions)
3- collect data
"""
# iterate through traders in neighboring cells and trade
for a in self.cell.get_neighborhood(radius=self.vision).agents:
(continues on next page)

2.4. Citing Mesa

135

Mesa Documentation, Release .1

(continued from previous page)

self.trade(a)
return

2.4.2.3.4.84 Model
from pathlib import Path
import numpy as np
import mesa
from mesa.discrete_space import OrthogonalVonNeumannGrid
from mesa.discrete_space.property_layer import PropertyLayer
from mesa.examples.advanced.sugarscape_g1mt.agents import Trader

# Helper Functions
def flatten(list_of_lists):
"""
helper function for model datacollector for trade price
collapses agent price list into one list
"""
return [item for sublist in list_of_lists for item in sublist]

def geometric_mean(list_of_prices):
"""
find the geometric mean of a list of prices
"""
return np.exp(np.log(list_of_prices).mean())

def get_trade(agent):
"""
For agent reporters in data collector
return list of trade partners and None for other agents
"""
if isinstance(agent, Trader):
return agent.trade_partners
else:
return None

class SugarscapeG1mt(mesa.Model):
"""
Manager class to run Sugarscape with Traders
"""
def __init__(
(continues on next page)

136

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

self,
width=50,
height=50,
initial_population=200,
endowment_min=25,
endowment_max=50,
metabolism_min=1,
metabolism_max=5,
vision_min=1,
vision_max=5,
enable_trade=True,
seed=None,
):
super().__init__(seed=seed)
# Initiate width and height of sugarscape
self.width = width
self.height = height
# Initiate population attributes
self.enable_trade = enable_trade
self.running = True
# initiate mesa grid class
self.grid = OrthogonalVonNeumannGrid(
(self.width, self.height), torus=False, random=self.random
)
# initiate datacollector
self.datacollector = mesa.DataCollector(
model_reporters={
"#Traders": lambda m: len(m.agents),
"Trade Volume": lambda m: sum(len(a.trade_partners) for a in m.agents),
"Price": lambda m: geometric_mean(
flatten([a.prices for a in m.agents])
),
},
agent_reporters={"Trade Network": lambda a: get_trade(a)},
)
# read in landscape file from supplementary material
self.sugar_distribution = np.genfromtxt(Path(__file__).parent / "sugar-map.txt")
self.spice_distribution = np.flip(self.sugar_distribution, 1)
self.grid.add_property_layer(
PropertyLayer.from_data("sugar", self.sugar_distribution)
)
self.grid.add_property_layer(
PropertyLayer.from_data("spice", self.spice_distribution)
)
Trader.create_agents(
self,
initial_population,
(continues on next page)

2.4. Citing Mesa

137

Mesa Documentation, Release .1

(continued from previous page)

self.random.choices(self.grid.all_cells.cells, k=initial_population),
sugar=self.rng.integers(
endowment_min, endowment_max, (initial_population,), endpoint=True
),
spice=self.rng.integers(
endowment_min, endowment_max, (initial_population,), endpoint=True
),
metabolism_sugar=self.rng.integers(
metabolism_min, metabolism_max, (initial_population,), endpoint=True
),
metabolism_spice=self.rng.integers(
metabolism_min, metabolism_max, (initial_population,), endpoint=True
),
vision=self.rng.integers(
vision_min, vision_max, (initial_population,), endpoint=True
),
)
def step(self):
"""
Unique step function that does staged activation of sugar and spice
and then randomly activates traders
"""
# step Resource agents
self.grid.sugar.data = np.minimum(
self.grid.sugar.data + 1, self.sugar_distribution
)
self.grid.spice.data = np.minimum(
self.grid.spice.data + 1, self.spice_distribution
)
# step trader agents
# to account for agent death and removal we need a separate data structure to
# iterate
trader_shuffle = self.agents_by_type[Trader].shuffle()
for agent in trader_shuffle:
agent.prices = []
agent.trade_partners = []
agent.move()
agent.eat()
agent.maybe_die()
if not self.enable_trade:
# If trade is not enabled, return early
self.datacollector.collect(self)
return
trader_shuffle = self.agents_by_type[Trader].shuffle()
for agent in trader_shuffle:
agent.trade_with_neighbors()
(continues on next page)

138

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

# collect model level data
# fixme we can already collect agent class data
# fixme, we don't have resource agents anymore so this can be done simpler
self.datacollector.collect(self)
"""
Mesa is working on updating datacollector agent reporter
so it can collect information on specific agents from
mesa.time.RandomActivationByType.
Please see issue #1419 at
https://github.com/projectmesa/mesa/issues/1419
(contributions welcome)
Below is one way to update agent_records to get specific Trader agent data
"""
# Need to remove excess data
# Create local variable to store trade data
agent_trades = self.datacollector._agent_records[self.steps]
# Get rid of all None to reduce data storage needs
agent_trades = [agent for agent in agent_trades if agent[2] is not None]
# Reassign the dictionary value with lean trade data
self.datacollector._agent_records[self.steps] = agent_trades
def run_model(self, step_count=1000):
for _ in range(step_count):
self.step()

2.4.2.3.4.85 App
from mesa.examples.advanced.sugarscape_g1mt.model import SugarscapeG1mt
from mesa.visualization import Slider, SolaraViz, make_plot_component
from mesa.visualization.components.matplotlib_components import make_mpl_space_component

def agent_portrayal(agent):
return {"marker": "o", "color": "red", "size": 10}

propertylayer_portrayal = {
"sugar": {"color": "blue", "alpha": 0.8, "colorbar": True, "vmin": 0, "vmax": 10},
"spice": {"color": "red", "alpha": 0.8, "colorbar": True, "vmin": 0, "vmax": 10},
}

sugarscape_space = make_mpl_space_component(
agent_portrayal=agent_portrayal,
propertylayer_portrayal=propertylayer_portrayal,
post_process=None,
draw_grid=False,
(continues on next page)

2.4. Citing Mesa

139

Mesa Documentation, Release .1

(continued from previous page)

)
model_params = {
"seed": {
"type": "InputText",
"value": 42,
"label": "Random Seed",
},
"width": 50,
"height": 50,
# Population parameters
"initial_population": Slider(
"Initial Population", value=200, min=50, max=500, step=10
),
# Agent endowment parameters
"endowment_min": Slider("Min Initial Endowment", value=25, min=5, max=30, step=1),
"endowment_max": Slider("Max Initial Endowment", value=50, min=30, max=100, step=1),
# Metabolism parameters
"metabolism_min": Slider("Min Metabolism", value=1, min=1, max=3, step=1),
"metabolism_max": Slider("Max Metabolism", value=5, min=3, max=8, step=1),
# Vision parameters
"vision_min": Slider("Min Vision", value=1, min=1, max=3, step=1),
"vision_max": Slider("Max Vision", value=5, min=3, max=8, step=1),
# Trade parameter
"enable_trade": {"type": "Checkbox", "value": True, "label": "Enable Trading"},
}
model = SugarscapeG1mt()
page = SolaraViz(
model,
components=[
sugarscape_space,
make_plot_component("#Traders"),
make_plot_component("Price"),
],
model_params=model_params,
name="Sugarscape {G1, M, T}",
play_interval=150,
)
page # noqa

2.4.3 Mesa Migration guide
This guide contains breaking changes between major Mesa versions and how to resolve them.
Non-breaking changes aren’t included, for those see our Release history.

140

Chapter 2. Using Mesa

Mesa Documentation, Release .1

2.4.3.1 Mesa 3.0
Mesa 3.0 introduces significant changes to core functionalities, including agent and model initialization, scheduling,
and visualization. The guide below outlines these changes and provides instructions for migrating your existing Mesa
projects to version 3.0.
This guide is a work in progress. The development of it is tracked in Issue #2233.
2.4.3.1.1 Upgrade strategy
We recommend the following upgrade strategy:
• Update to the latest Mesa 2.x release (mesa<3).
• Update to the latest Mesa 3.0.x release (mesa<3.1).
• Update to the latest Mesa 3.x release (mesa<4).
With each update, resolve all errors and warnings, before updating to the next one.
2.4.3.1.2 Reserved and private variables
2.4.3.1.2.1 Reserved variables
Currently, we have reserved the following variables:
• Model: agents, current_id, random, running, steps, time.
• Agent: unique_id, model.
You can use (read) any reserved variable, but Mesa may update them automatically and rely on them, so modify/update
at your own risk.
2.4.3.1.2.2 Private variables
Any variables starting with an underscore (_) are considered private and for Mesa’s internal use. We might use any of
those. Modifying or overwriting any private variable is at your own risk.
• Ref: Discussion #2230, PR #2225
2.4.3.1.3 Removal of mesa.flat namespace
The mesa.flat namespace is removed. Use the full namespace for your imports.
• Ref: PR #2091
2.4.3.1.4 Mandatory Model initialization with super().__init__()
In Mesa 3.0, it is now mandatory to call super().__init__() when initializing your model class. This ensures that
all necessary Mesa model variables are correctly set up and agents are properly added to the model. If you want to
control the seed of the random number generator, you have to pass this as a keyword argument to super as shown below.
Make sure all your model classes explicitly call super().__init__() in their __init__ method:
class MyModel(mesa.Model):
def __init__(self, some_arg_I_need, seed=None, some_kwarg_I_need=True):
super().__init__(seed=seed) # Calling super is now required, passing seed is␣
˓→highly recommended
# Your model initialization code here
# this code uses some_arg_I_need and my_init_kwarg

2.4. Citing Mesa

141

Mesa Documentation, Release .1

This change ensures that all Mesa models are properly initialized, which is crucial for:
• Correctly adding agents to the model
• Setting up other essential Mesa model variables
• Maintaining consistency across all models
If you forget to call super().__init__(), you’ll now see this error:
RuntimeError: The Mesa Model class was not initialized. You must explicitly initialize␣
˓→the Model by calling super().__init__() on initialization.
• Ref: PR #2218, PR #1928, Mesa-examples PR #83
2.4.3.1.5 Automatic assignment of unique_id to Agents
In Mesa 3.0, unique_id for agents is now automatically assigned, simplifying agent creation and ensuring unique IDs
across all agents in a model.
1. Remove unique_id from agent initialization:
# Old
agent = MyAgent(unique_id=unique_id, model=self, ...)
agent = MyAgent(unique_id, self, ...)
agent = MyAgent(self.next_id(), self, ...)
# New
agent = MyAgent(model=self, ...)
agent = MyAgent(self, ...)
2. Remove unique_id from Agent super() call:
# Old
class MyAgent(Agent):
def __init__(self, unique_id, model, ...):
super().__init__(unique_id, model)
# New
class MyAgent(Agent):
def __init__(self, model, ...):
super().__init__(model)
3. Important notes:
• unique_id is now automatically assigned relative to a Model instance and starts from 1
• Model.next_id() is removed
• If you previously used custom unique_id values, store that information in a separate attribute
• Ref: PR #2226, PR #2260, Mesa-examples PR #194, Issue #2213
2.4.3.1.6 AgentSet and Model.agents
In Mesa 3.0, the Model class internally manages agents using several data structures:
• self._agents: A dictionary containing hard references to all agents, indexed by their unique_id.
• self._agents_by_type: A dictionary of AgentSets, organizing agents by their type.
142

Chapter 2. Using Mesa

Mesa Documentation, Release .1

• self._all_agents: An AgentSet containing all agents in the model.
These internal structures are used to efficiently manage and access agents. Users should interact with agents through
the public model.agents property, which returns the self._all_agents AgentSet.
2.4.3.1.6.1 Model.agents
• Attempting to set model.agents now raises an AttributeError instead of a warning. This attribute is reserved
for internal use by Mesa.
• If you were previously setting model.agents in your code, you must update it to use a different attribute name
for custom agent storage.
For example, replace:
model.agents = my_custom_agents
With:
model.custom_agents = my_custom_agents
2.4.3.1.7 Time and schedulers
2.4.3.1.7.1 Automatic increase of the steps counter
The steps counter is now automatically increased. With each call to Model.steps() it’s increased by 1, at the
beginning of the step.
You can access it by Model.steps, and it’s internally in the datacollector, batchrunner and the visualisation.
• Ref: PR #2223, Mesa-examples PR #161
2.4.3.1.7.2 Removal of Model._time and rename ._steps
• Model._time is removed. You can define your own time variable if needed.
• Model._steps steps is renamed to Model.steps.
2.4.3.1.7.3 Removal of Model._advance_time()
• The Model._advance_time() method is removed. This now happens automatically.
2.4.3.1.7.4 Replacing Schedulers with AgentSet functionality
The whole Time module in Mesa is deprecated and will be removed in Mesa 3.1. All schedulers should be replaced with
AgentSet functionality and the internal Model.steps counter. This allows much more flexibility in how to activate
Agents and makes it explicit what’s done exactly.
Here’s how to replace each scheduler:
2.4.3.1.7.5 BaseScheduler
Replace:
self.schedule = BaseScheduler(self)
self.schedule.step()
With:
2.4. Citing Mesa

143

Mesa Documentation, Release .1

self.agents.do("step")
2.4.3.1.7.6 RandomActivation
Replace:
self.schedule = RandomActivation(self)
self.schedule.step()
With:
self.agents.shuffle_do("step")
2.4.3.1.7.7 SimultaneousActivation
Replace:
self.schedule = SimultaneousActivation(self)
self.schedule.step()
With:
self.agents.do("step")
self.agents.do("advance")
2.4.3.1.7.8 StagedActivation
Replace:
self.schedule = StagedActivation(self, ["stage1", "stage2", "stage3"])
self.schedule.step()
With:
for stage in ["stage1", "stage2", "stage3"]:
self.agents.do(stage)
If you were using the shuffle and/or shuffle_between_stages options:
stages = ["stage1", "stage2", "stage3"]
if shuffle:
self.random.shuffle(stages)
for stage in stages:
if shuffle_between_stages:
self.agents.shuffle_do(stage)
else:
self.agents.do(stage)
2.4.3.1.7.9 RandomActivationByType
Replace:

144

Chapter 2. Using Mesa

Mesa Documentation, Release .1

self.schedule = RandomActivationByType(self)
self.schedule.step()
With:
for agent_class in self.agent_types:
self.agents_by_type[agent_class].shuffle_do("step")
2.4.3.1.7.10 Replacing step_type
The RandomActivationByType scheduler had a step_type method that allowed stepping only agents of a specific
type. To replicate this functionality using AgentSet:
Replace:
self.schedule.step_type(AgentType)
With:
self.agents_by_type[AgentType].shuffle_do("step")
2.4.3.1.7.11 General Notes
1. The Model.steps counter is now automatically incremented. You don’t need to manage it manually.
2. If you were using self.schedule.agents, replace it with self.agents.
3. If you were using self.schedule.get_agent_count(), replace it with len(self.agents).
4. If you were using self.schedule.agents_by_type, replace it with self.agents_by_type.
5. Agents are now automatically added to or removed from the model’s AgentSet (model.agents) when they
are created or deleted, eliminating the need to manually call self.schedule.add() or self.schedule.
remove().
• However, you still need to explicitly remove the Agent itself by using Agent.remove(). Typically, this
means:
– Replace self.schedule.remove(agent) with agent.remove() in the Model.
– Replace self.model.schedule.remove(self) with self.remove() within the Agent.
From now on you’re now not bound by 5 distinct schedulers, but can mix and match any combination of AgentSet
methods (do, shuffle, select, etc.) to get the desired Agent activation.
Ref: Original discussion #1912, decision discussion #2231, example updates #183 and #201, PR #2306
2.4.3.1.8 Visualisation
Mesa has adopted a new API for our frontend. If you already migrated to the experimental new SolaraViz you can still
use the import from mesa.experimental. Otherwise here is a list of things you need to change.
Note: SolaraViz is experimental and still in active development for Mesa 3.0. While we attempt to minimize them, there might be API breaking changes between Mesa 3.0 and 3.1. There won’t be breaking
changes between Mesa 3.0.x patch releases.

2.4. Citing Mesa

145

Mesa Documentation, Release .1

2.4.3.1.8.1 Model Initialization
Previously SolaraViz was initialized by providing a model_cls and a model_params. This has changed to expect a
model instance model. You can still provide (user-settable) model_params, but only if users should be able to change
them. It is now also possible to pass in a “reactive model” by first calling model = solara.reactive(model). This
is useful for notebook environments. It allows you to pass the model to the SolaraViz Module, but continue to use the
model. For example calling model.value.step() (notice the extra .value) will automatically update the plots. This
currently only automatically works for the step method, you can force visualization updates by calling model.value.
force_update().
2.4.3.1.9 Model Initialization with Keyword Arguments
With the introduction of SolaraViz in Mesa 3.0, models are now instantiated using **model_parameters.value.
This means all inputs for initializing a new model must be keyword arguments. Ensure your model’s __init__ method
accepts keyword arguments matching the keys in model_params.
class MyModel(mesa.Model):
def __init__(self, n_agents=10, seed=None):
super().__init__(seed=seed)
# Initialize the model with N agents
2.4.3.1.9.1 Default space visualization
Previously we included a default space drawer that you could configure with an agent_portrayal function. You now
have to explicitly create a space drawer with the agent_portrayal function
# old
from mesa.experimental import SolaraViz
SolaraViz(model_cls, model_params, agent_portrayal=agent_portrayal)
# new
from mesa.visualization import SolaraViz, make_space_component
SolaraViz(model, components=[make_space_component(agent_portrayal)])
2.4.3.1.9.2 Plotting “measures”
“Measure” plots also need to be made explicit here. Previously, measure could either be 1) A function that receives a
model and returns a solara component or 2) A string or list of string of variables that are collected by the datacollector
and are to be plotted as a line plot. 1) still works, but you can pass that function to “components” directly. 2) needs to
explicitly call the make_plot_measure()function.
# old
from mesa.experimental import SolaraViz

def make_plot(model):
...

SolaraViz(model_cls, model_params, measures=[make_plot, "foo", ["bar", "baz"]])
(continues on next page)

146

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

# new
from mesa.visualization import SolaraViz, make_plot_component
SolaraViz(model, components=[make_plot, make_plot_component("foo"), make_plot_component(
˓→"bar", "baz")])
2.4.3.1.9.3 Plotting text
To plot model-dependent text the experimental SolaraViz provided a make_text function that wraps another functions
that receives the model and turns its string return value into a solara text component. Again, this other function can
now be passed directly to the new SolaraViz components array. It is okay if your function just returns a string.
# old
from mesa.experimental import SolaraViz, make_text
def show_steps(model):
return f"Steps: {model.steps}"
SolaraViz(model_cls, model_params, measures=make_text(show_steps))
# new
from mesa.visualisation import SolaraViz
def show_steps(model):
return f"Steps: {model.steps}"
SolaraViz(model, components=[show_steps])
2.4.3.1.10 Other changes
2.4.3.1.10.1 Removal of Model.initialize_data_collector
The initialize_data_collector in the Model class is removed. In the Model class, replace:
Replace:
self.initialize_data_collector(...)
With:
self.datacollector = DataCollector(...)
• Ref: PR #2327, Mesa-examples PR #208)

2.4.4 APIs
2.4.4.1 Model
The model class for Mesa framework.
Core Objects: Model
class Model(*args: Any, seed: float | None = None, rng: Generator | BitGenerator | int | integer | Sequence[int] |
SeedSequence | None = None, **kwargs: Any)

2.4. Citing Mesa

147

Mesa Documentation, Release .1

Base class for models in the Mesa ABM library.
This class serves as a foundational structure for creating agent-based models. It includes the basic attributes and
methods necessary for initializing and running a simulation model.
running
A boolean indicating if the model should continue running.
steps
the number of times model.step() has been called.
random
a seeded python.random number generator.
rng
a seeded numpy.random.Generator
Notes
Model.agents returns the AgentSet containing all agents registered with the model. Changing the content of the
AgentSet directly can result in strange behavior. If you want change the composition of this AgentSet, ensure
you operate on a copy.
Create a new model.
Overload this method with the actual code to initialize the model. Always start with super().__init__() to initialize
the model object properly.
Parameters
• args – arguments to pass onto super
• seed – the seed for the random number generator
• rng – Pseudorandom number generator state.
When rng is None, a new
numpy.random.Generator is created using entropy from the operating system. Types
other than numpy.random.Generator are passed to numpy.random.default_rng to instantiate
a Generator.
• kwargs – keyword arguments to pass onto super
Notes
you have to pass either seed or rng, but not both.
property agents:

AgentSet

Provides an AgentSet of all agents in the model, combining agents from all types.
property agent_types:

list[type]

Return a list of all unique agent types registered with the model.
property agents_by_type:

dict[type[Agent], AgentSet]

A dictionary where the keys are agent types and the values are the corresponding AgentSets.
register_agent(agent)
Register the agent with the model.
Parameters
agent – The agent to register.

148

Chapter 2. Using Mesa

Mesa Documentation, Release .1

Notes
This method is called automatically by Agent.__init__, so there is no need to use this if you are subclassing Agent and calling its super in the __init__ method.
deregister_agent(agent)
Deregister the agent with the model.
Parameters
agent – The agent to deregister.
Notes
This method is called automatically by Agent.remove
run_model() → None
Run the model until the end condition is reached.
Overload as needed.
step() → None
A single step. Fill in here.
reset_randomizer(seed: int | None = None) → None
Reset the model random number generator.
Parameters
seed – A new seed for the RNG; if None, reset using the current seed
reset_rng(rng: Generator | BitGenerator | int | integer | Sequence[int] | SeedSequence | None = None) →
None
Reset the model random number generator.
Parameters
rng – A new seed for the RNG; if None, reset using the current seed
remove_all_agents()
Remove all agents from the model.
Notes
This method calls agent.remove for all agents in the model. If you need to remove agents from e.g., a
SingleGrid, you can either explicitly implement your own agent.remove method or clean this up near where
you are calling this method.
2.4.4.2 Agent
Agent related classes.
Core Objects: Agent and AgentSet.
class Agent(model: Model, *args, **kwargs)
Base class for a model agent in Mesa.
model
A reference to the model instance.
Type
Model

2.4. Citing Mesa

149

Mesa Documentation, Release .1

unique_id
A unique identifier for this agent.
Type
int
pos
A reference to the position where this agent is located.
Type
Position
Notes
unique_id is unique relative to a model instance and starts from 1
Create a new agent.
Parameters
• model (Model) – The model instance in which the agent exists.
• args – Passed on to super.
• kwargs – Passed on to super.
Notes
to make proper use of python’s super, in each class remove the arguments and keyword arguments you need and
pass on the rest to super
remove() → None
Remove and delete the agent from the model.
Notes
If you need to do additional cleanup when removing an agent by for example removing it from a space,
consider extending this method in your own agent class.
step() → None
A single step of the agent.
classmethod create_agents(model: Model, n: int, *args, **kwargs) → AgentSet[Agent]
Create N agents.
Parameters
• model – the model to which the agents belong
• args – arguments to pass onto agent instances each arg is either a single object or a sequence of length n
• n – the number of agents to create
• kwargs – keyword arguments to pass onto agent instances each keyword arg is either a
single object or a sequence of length n
Returns
AgentSet containing the agents created.
property random:

Random

Return a seeded stdlib rng.

150

Chapter 2. Using Mesa

Mesa Documentation, Release .1

property rng: Generator
Return a seeded np.random rng.
class AgentSet(agents: Iterable[Agent], random: Random | None = None)
A collection class that represents an ordered set of agents within an agent-based model (ABM).
This class extends both MutableSet and Sequence, providing set-like functionality with order preservation and
sequence operations.
model
The ABM model instance to which this AgentSet belongs.
Type
Model
Notes
The AgentSet maintains weak references to agents, allowing for efficient management of agent lifecycles without
preventing garbage collection. It is associated with a specific model instance, enabling interactions with the
model’s environment and other agents.The implementation uses a WeakKeyDictionary to store agents, which
means that agents not referenced elsewhere in the program may be automatically removed from the AgentSet.
Notes
A UserWarning is issued if random=None. You can resolve this warning by explicitly passing a random number
generator. In most cases, this will be the seeded random number generator in the model. So, you would do
random=self.random in a Model or Agent instance.
Initializes the AgentSet with a collection of agents and a reference to the model.
Parameters
• agents (Iterable[Agent]) – An iterable of Agent objects to be included in the set.
• random (Random) – the random number generator
select(filter_func: Callable[[Agent], bool] | None = None, at_most: int | float = inf , inplace: bool = False,
agent_type: type[Agent] | None = None) → AgentSet
Select a subset of agents from the AgentSet based on a filter function and/or quantity limit.
Parameters
• filter_func (Callable[[Agent], bool], optional) – A function that takes an
Agent and returns True if the agent should be included in the result. Defaults to None,
meaning no filtering is applied.
• at_most (int | float, optional) – The maximum amount of agents to select. Defaults to infinity. - If an integer, at most the first number of matching agents are selected. If a float between 0 and 1, at most that fraction of original the agents are selected.
• inplace (bool, optional) – If True, modifies the current AgentSet; otherwise, returns
a new AgentSet. Defaults to False.
• agent_type (type[Agent], optional) – The class type of the agents to select. Defaults to None, meaning no type filtering is applied.
Returns
A new AgentSet containing the selected agents, unless inplace is True, in which case the
current AgentSet is updated.
Return type
AgentSet
2.4. Citing Mesa

151

Mesa Documentation, Release .1

Notes
• at_most just return the first n or fraction of agents. To take a random sample, shuffle() beforehand.
• at_most is an upper limit. When specifying other criteria, the number of agents returned can be smaller.
shuffle(inplace: bool = False) → AgentSet
Randomly shuffle the order of agents in the AgentSet.
Parameters
inplace (bool, optional) – If True, shuffles the agents in the current AgentSet; otherwise, returns a new shuffled AgentSet. Defaults to False.
Returns
A shuffled AgentSet. Returns the current AgentSet if inplace is True.
Return type
AgentSet
ò Note
Using inplace = True is more performant
sort(key: Callable[[Agent], Any] | str, ascending: bool = False, inplace: bool = False) → AgentSet
Sort the agents in the AgentSet based on a specified attribute or custom function.
Parameters
• key (Callable[[Agent], Any] | str) – A function or attribute name based on which
the agents are sorted.
• ascending (bool, optional) – If True, the agents are sorted in ascending order. Defaults to False.
• inplace (bool, optional) – If True, sorts the agents in the current AgentSet; otherwise,
returns a new sorted AgentSet. Defaults to False.
Returns
A sorted AgentSet. Returns the current AgentSet if inplace is True.
Return type
AgentSet
do(method: str | Callable, *args, **kwargs) → AgentSet
Invoke a method or function on each agent in the AgentSet.
Parameters
• method (str, callable) – the callable to do on each agent
– in case of str, the name of the method to call on each agent.
– in case of callable, the function to be called with each agent as first argument
• *args – Variable length argument list passed to the callable being called.
• **kwargs – Arbitrary keyword arguments passed to the callable being called.
Returns
The results of the callable calls if return_results is True, otherwise the AgentSet itself.

152

Chapter 2. Using Mesa

Mesa Documentation, Release .1

Return type
AgentSet | list[Any]
shuffle_do(method: str | Callable, *args, **kwargs) → AgentSet
Shuffle the agents in the AgentSet and then invoke a method or function on each agent.
It’s a fast, optimized version of calling shuffle() followed by do().
map(method: str | Callable, *args, **kwargs) → list[Any]
Invoke a method or function on each agent in the AgentSet and return the results.
Parameters
• method (str, callable) – the callable to apply on each agent
– in case of str, the name of the method to call on each agent.
– in case of callable, the function to be called with each agent as first argument
• *args – Variable length argument list passed to the callable being called.
• **kwargs – Arbitrary keyword arguments passed to the callable being called.
Returns
The results of the callable calls
Return type
list[Any]
agg(attribute: str, func: Callable | Iterable[Callable]) → Any | list[Any]
Aggregate an attribute of all agents in the AgentSet using one or more functions.
Parameters
• attribute (str) – The name of the attribute to aggregate.
• func (Callable | Iterable[Callable]) –
– If Callable: A single function to apply to the attribute values (e.g., min, max, sum,
np.mean)
– If Iterable: Multiple functions to apply to the attribute values
Returns
Result of applying the function(s) to the attribute values.
Return type
Any | [Any, . . . ]
Examples
# Single function avg_energy = model.agents.agg(“energy”, np.mean)
# Multiple functions min_wealth, max_wealth, total_wealth = model.agents.agg(“wealth”, [min, max,
sum])
get(attr_names: str, handle_missing: Literal['error', 'default'] = 'error', default_value: Any = None) →
list[Any]
get(attr_names: list[str], handle_missing: Literal['error', 'default'] = 'error', default_value: Any = None) →
list[list[Any]]
Retrieve the specified attribute(s) from each agent in the AgentSet.
Parameters

2.4. Citing Mesa

153

Mesa Documentation, Release .1

• attr_names (str | list[str]) – The name(s) of the attribute(s) to retrieve from each
agent.
• handle_missing (str, optional) – How to handle missing attributes. Can be: - ‘error’
(default): raises an AttributeError if attribute is missing. - ‘default’: returns the specified
default_value.
• default_value (Any, optional) – The default value to return if ‘handle_missing’ is
set to ‘default’ and the agent does not have the attribute.
Returns
A list with the attribute value for each agent if attr_names is a str. list[list[Any]]: A list with
a lists of attribute values for each agent if attr_names is a list of str.
Return type
list[Any]
Raises
• AttributeError – If ‘handle_missing’ is ‘error’ and the agent does not have the specified
attribute(s).
• ValueError – If an unknown ‘handle_missing’ option is provided.
set(attr_name: str, value: Any) → AgentSet
Set a specified attribute to a given value for all agents in the AgentSet.
Parameters
• attr_name (str) – The name of the attribute to set.
• value (Any) – The value to set the attribute to.
Returns
The AgentSet instance itself, after setting the attribute.
Return type
AgentSet
add(agent: Agent)
Add an agent to the AgentSet.
Parameters
agent (Agent) – The agent to add to the set.
ò Note
This method is an implementation of the abstract method from MutableSet.
discard(agent: Agent)
Remove an agent from the AgentSet if it exists.
This method does not raise an error if the agent is not present.
Parameters
agent (Agent) – The agent to remove from the set.
ò Note
This method is an implementation of the abstract method from MutableSet.

154

Chapter 2. Using Mesa

Mesa Documentation, Release .1

remove(agent: Agent)
Remove an agent from the AgentSet.
This method raises an error if the agent is not present.
Parameters
agent (Agent) – The agent to remove from the set.
ò Note
This method is an implementation of the abstract method from MutableSet.
groupby(by: Callable | str, result_type: str = 'agentset') → GroupBy
Group agents by the specified attribute or return from the callable.
Parameters
• by (Callable, str) – used to determine what to group agents by
– if by is a callable, it will be called for each agent and the return is used for grouping
– if by is a str, it should refer to an attribute on the agent and the value of this attribute will
be used for grouping
• result_type (str, optional) – The datatype for the resulting groups {“agentset”,
“list”}
Returns
GroupBy
Notes: There might be performance benefits to using result_type=’list’ if you don’t need the advanced
functionality of an AgentSet.
clear()
This is slow (creates N new iterators!) but effective.
count(value) → integer -- return number of occurrences of value
index(value[, start [, stop ]]) → integer -- return first index of value.
Raises ValueError if the value is not present.
Supporting start and stop arguments is optional, but recommended.
isdisjoint(other)
Return True if two sets have a null intersection.
pop()
Return the popped value. Raise KeyError if empty.
class GroupBy(groups: dict[Any, list | AgentSet])
Helper class for AgentSet.groupby.
groups
A dictionary with the group_name as key and group as values
Type
dict
Initialize a GroupBy instance.

2.4. Citing Mesa

155

Mesa Documentation, Release .1

Parameters
groups (dict) – A dictionary with the group_name as key and group as values
map(method: Callable | str, *args, **kwargs) → dict[Any, Any]
Apply the specified callable to each group and return the results.
Parameters
• method (Callable, str) – The callable to apply to each group,
– if method is a callable, it will be called it will be called with the group as first argument
– if method is a str, it should refer to a method on the group
Additional arguments and keyword arguments will be passed on to the callable.
• args – arguments to pass to the callable
• kwargs – keyword arguments to pass to the callable
Returns
dict with group_name as key and the return of the method as value
Notes
this method is useful for methods or functions that do return something. It will break method chaining. For
that, use do instead.
do(method: Callable | str, *args, **kwargs) → GroupBy
Apply the specified callable to each group.
Parameters
• method (Callable, str) – The callable to apply to each group,
– if method is a callable, it will be called it will be called with the group as first argument
– if method is a str, it should refer to a method on the group
Additional arguments and keyword arguments will be passed on to the callable.
• args – arguments to pass to the callable
• kwargs – keyword arguments to pass to the callable
Returns
the original GroupBy instance
Notes
this method is useful for methods or functions that don’t return anything and/or if you want to chain multiple
do calls
count() → dict[Any, int]
Return the count of agents in each group.
Returns
A dictionary mapping group names to the number of agents in each group.
Return type
dict

156

Chapter 2. Using Mesa

Mesa Documentation, Release .1

agg(attr_name: str, func: Callable) → dict[Hashable, Any]
Aggregate the values of a specific attribute across each group using the provided function.
Parameters
• attr_name (str) – The name of the attribute to aggregate.
• func (Callable) – The function to apply (e.g., sum, min, max, mean).
Returns
A dictionary mapping group names to the result of applying the aggregation function.
Return type
dict[Hashable, Any]
2.4.4.3 Spaces
Mesa Space Module.
Objects used to add a spatial component to a model.
ò Note
All Grid classes (_Grid, SingleGrid, MultiGrid, HexGrid, etc.) are now in maintenance-only mode. While
these classes remain fully supported, new development occurs in the experimental cell space module (mesa.
discrete_space).
The PropertyLayer and ContinuousSpace classes remain fully supported and actively developed.
2.4.4.3.1 Classes
• PropertyLayer: A data layer that can be added to Grids to store cell properties
• SingleGrid: a Grid which strictly enforces one agent per cell.
• MultiGrid: a Grid where each cell can contain a set of agents.
• HexGrid: a Grid to handle hexagonal neighbors.
• ContinuousSpace: a two-dimensional space where each agent has an arbitrary position of float’s.
• NetworkGrid: a network where each node contains zero or more agents.
accept_tuple_argument(wrapped_function: F) → F
Decorator to allow grid methods that take a list of (x, y) coord tuples to also handle a single position.
Tuples are wrapped in a single-item list rather than forcing user to do it.
is_integer(x: Real) → bool
Check if x is either a CPython integer or Numpy integer.
warn_if_agent_has_position_already(placement_func)
Decorator to give warning if agent has position already set.
is_single_argument_function(function)
Check if a function is a single argument function.
class PropertyLayer(name: str, width: int, height: int, default_value, dtype=<class 'numpy.float64'>)
A class representing a layer of properties in a two-dimensional grid.
Each cell in the grid can store a value of a specified data type.

2.4. Citing Mesa

157

Mesa Documentation, Release .1

name
The name of the property layer.
Type
str
width
The width of the grid (number of columns).
Type
int
height
The height of the grid (number of rows).
Type
int
data
A NumPy array representing the grid data.
Type
numpy.ndarray
Initializes a new PropertyLayer instance.
Parameters
• name (str) – The name of the property layer.
• width (int) – The width of the grid (number of columns). Must be a positive integer.
• height (int) – The height of the grid (number of rows). Must be a positive integer.
• default_value – The default value to initialize each cell in the grid. Should ideally be of
the same type as specified by the dtype parameter.
• dtype (data-type, optional) – The desired data-type for the grid’s elements. Default
is np.float64.
Raises
ValueError – If width or height is not a positive integer.
Notes
A UserWarning is raised if the default_value is not of a type compatible with dtype. The dtype parameter can
accept both Python data types (like bool, int or float) and NumPy data types (like np.int64 or np.float64). Using
NumPy data types is recommended (except for bool) for better control over the precision and efficiency of data
storage and computations, especially in cases of large data volumes or specialized numerical operations.
set_cell(position: tuple[int, int], value)
Update a single cell’s value in-place.
set_cells(value, condition=None)
Perform a batch update either on the entire grid or conditionally, in-place.
Parameters
• value – The value to be used for the update.
• condition – (Optional) A callable (like a lambda function or a NumPy ufunc) that returns
a boolean array when applied to the data.

158

Chapter 2. Using Mesa

Mesa Documentation, Release .1

modify_cell(position: tuple[int, int], operation, value=None)
Modify a single cell using an operation, which can be a lambda function or a NumPy ufunc.
If a NumPy ufunc is used, an additional value should be provided.
Parameters
• position – The grid coordinates of the cell to modify.
• operation – A function to apply. Can be a lambda function or a NumPy ufunc.
• value – The value to be used if the operation is a NumPy ufunc. Ignored for lambda
functions.
modify_cells(operation, value=None, condition_function=None)
Modify cells using an operation, which can be a lambda function or a NumPy ufunc.
If a NumPy ufunc is used, an additional value should be provided.
Parameters
• operation – A function to apply. Can be a lambda function or a NumPy ufunc.
• value – The value to be used if the operation is a NumPy ufunc. Ignored for lambda
functions.
• condition_function – (Optional) A callable that returns a boolean array when applied
to the data.
select_cells(condition, return_list=True)
Find cells that meet a specified condition using NumPy’s boolean indexing, in-place.
Parameters
• condition – A callable that returns a boolean array when applied to the data.
• return_list – (Optional) If True, return a list of (x, y) tuples. Otherwise, return a boolean
array.
Returns
A list of (x, y) tuples or a boolean array.
aggregate_property(operation)
Perform an aggregate operation (e.g., sum, mean) on a property across all cells.
Parameters
operation – A function to apply. Can be a lambda function or a NumPy ufunc.
class SingleGrid(width: int, height: int, torus: bool, property_layers: None | PropertyLayer |
list[PropertyLayer] = None)
Rectangular grid where each cell contains exactly at most one agent.
Grid cells are indexed by [x, y], where [0, 0] is assumed to be the bottom-left and [width-1, height-1] is the
top-right. If a grid is toroidal, the top and bottom, and left and right, edges wrap to each other.
This class provides a property empties that returns a set of coordinates for all empty cells in the grid. It is
automatically updated whenever agents are added or removed from the grid. The empties property should be
used for efficient access to current empty cells rather than manually iterating over the grid to check for emptiness.
Properties:
width, height: The grid’s width and height. torus: Boolean which determines whether to treat the grid as a
torus. empties: Returns a set of (x, y) tuples for all empty cells. This set is
maintained internally and provides a performant way to query the grid for empty spaces.

2.4. Citing Mesa

159

Mesa Documentation, Release .1

Initializes a new _PropertyGrid instance with specified dimensions and optional property layers.
Parameters
• width (int) – The width of the grid (number of columns).
• height (int) – The height of the grid (number of rows).
• torus (bool) – A boolean indicating if the grid should behave like a torus.
• property_layers (None | PropertyLayer | list[PropertyLayer], optional)
– A single PropertyLayer instance, a list of PropertyLayer instances, or None to initialize
without any property layers.
Raises
ValueError – If a property layer’s dimensions do not match the grid dimensions.
remove_agent(agent: Agent) → None
Remove the agent from the grid and set its pos attribute to None.
add_property_layer(property_layer: PropertyLayer)
Adds a new property layer to the grid.
Parameters
property_layer (PropertyLayer) – The PropertyLayer instance to be added to the grid.
Raises
• ValueError – If a property layer with the same name already exists in the grid.
• ValueError – If the dimensions of the property layer do not match the grid’s dimensions.
property agents:

AgentSet

Return an AgentSet with the agents in the space.
coord_iter() → Iterator[tuple[Agent | None, tuple[int, int]]]
An iterator that returns positions as well as cell contents.
static default_val() → None
Default value for new cell elements.
property empty_mask:

ndarray

Returns a boolean mask indicating empty cells on the grid.
exists_empty_cells() → bool
Return True if any cells empty else False.
get_neighborhood(pos: tuple[int, int], moore: bool, include_center: bool = False, radius: int = 1) →
Sequence[tuple[int, int]]
Return a list of cells that are in the neighborhood of a certain point.
Parameters
• pos – Coordinate tuple for the neighborhood to get.
• moore – If True, return Moore neighborhood (including diagonals) If False, return Von
Neumann neighborhood (exclude diagonals)
• include_center – If True, return the (x, y) cell as well. Otherwise, return surrounding
cells only.
• radius – radius, in cells, of neighborhood to get.

160

Chapter 2. Using Mesa

Mesa Documentation, Release .1

Returns
A list of coordinate tuples representing the neighborhood; With radius 1, at most 9 if Moore,
5 if Von Neumann (8 and 4 if not including the center).
get_neighborhood_mask(pos: tuple[int, int], moore: bool, include_center: bool, radius: int) → ndarray
Generate a boolean mask representing the neighborhood.
Helper method for select_cells_multi_properties() and move_agent_to_random_cell()
Parameters
• pos (Coordinate) – Center of the neighborhood.
• moore (bool) – True for Moore neighborhood, False for Von Neumann.
• include_center (bool) – Include the central cell in the neighborhood.
• radius (int) – The radius of the neighborhood.
Returns
A boolean mask representing the neighborhood.
Return type
np.ndarray
get_neighbors(pos: tuple[int, int], moore: bool, include_center: bool = False, radius: int = 1) →
list[Agent]
Return a list of neighbors to a certain point.
Parameters
• pos – Coordinate tuple for the neighborhood to get.
• moore –
If True, return Moore neighborhood
(including diagonals)
If False, return Von Neumann neighborhood
(exclude diagonals)
• include_center – If True, return the (x, y) cell as well. Otherwise, return surrounding
cells only.
• radius – radius, in cells, of neighborhood to get.
Returns
A list of non-None objects in the given neighborhood; at most 9 if Moore, 5 if Von-Neumann
(8 and 4 if not including the center).
is_cell_empty(pos: tuple[int, int]) → bool
Returns a bool of the contents of a cell.
iter_neighborhood(pos: tuple[int, int], moore: bool, include_center: bool = False, radius: int = 1) →
Iterator[tuple[int, int]]
Return an iterator over cell coordinates that are in the neighborhood of a certain point.
Parameters
• pos – Coordinate tuple for the neighborhood to get.
• moore –
If True, return Moore neighborhood
(including diagonals)
2.4. Citing Mesa

161

Mesa Documentation, Release .1

If False, return Von Neumann neighborhood
(exclude diagonals)
• include_center – If True, return the (x, y) cell as well. Otherwise, return surrounding
cells only.
• radius – radius, in cells, of neighborhood to get.
Returns
An iterator of coordinate tuples representing the neighborhood. For example with radius 1, it
will return list with number of elements equals at most 9 (8) if Moore, 5 (4) if Von Neumann
(if not including the center).
iter_neighbors(pos: tuple[int, int], moore: bool, include_center: bool = False, radius: int = 1) →
Iterator[Agent]
Return an iterator over neighbors to a certain point.
Parameters
• pos – Coordinates for the neighborhood to get.
• moore –
If True, return Moore neighborhood
(including diagonals)
If False, return Von Neumann neighborhood
(exclude diagonals)
• include_center – If True, return the (x, y) cell as well. Otherwise, return surrounding
cells only.
• radius – radius, in cells, of neighborhood to get.
Returns
An iterator of non-None objects in the given neighborhood; at most 9 if Moore, 5 if VonNeumann (8 and 4 if not including the center).
move_agent(agent: Agent, pos: tuple[int, int]) → None
Move an agent from its current position to a new position.
Parameters
• agent – Agent object to move. Assumed to have its current location stored in a ‘pos’ tuple.
• pos – Tuple of new position to move the agent to.
move_agent_to_one_of(agent: Agent, pos: list[tuple[int, int]], selection: str = 'random', handle_empty: str
| None = None) → None
Move an agent to one of the given positions.
Parameters
• agent – Agent object to move. Assumed to have its current location stored in a ‘pos’ tuple.
• pos – List of possible positions.
• selection – String, either “random” (default) or “closest”. If “closest” is selected and
multiple cells are the same distance, one is chosen randomly.
• handle_empty – String, either “warning”, “error” or None (default). If “warning” or
“error” is selected and no positions are given (an empty list), a warning or error is raised
respectively.

162

Chapter 2. Using Mesa

Mesa Documentation, Release .1

move_to_empty(agent: Agent) → None
Moves agent to a random empty cell, vacating agent’s old cell.
out_of_bounds(pos: tuple[int, int]) → bool
Determines whether position is off the grid, returns the out of bounds coordinate.
remove_property_layer(property_name: str)
Removes a property layer from the grid by its name.
Parameters
property_name (str) – The name of the property layer to be removed.
Raises
ValueError – If a property layer with the given name does not exist in the grid.
select_cells(conditions: dict | None = None, extreme_values: dict | None = None, masks: ndarray |
list[ndarray] = None, only_empty: bool = False, return_list: bool = True) → list[tuple[int,
int]] | ndarray
Select cells based on property conditions, extreme values, and/or masks, with an option to only select empty
cells.
Parameters
• conditions (dict) – A dictionary where keys are property names and values are callables
that return a boolean when applied.
• extreme_values (dict) – A dictionary where keys are property names and values are
either ‘highest’ or ‘lowest’.
• masks (np.ndarray | list[np.ndarray], optional) – A mask or list of masks to
restrict the selection.
• only_empty (bool, optional) – If True, only select cells that are empty. Default is
False.
• return_list (bool, optional) – If True, return a list of coordinates, otherwise return
a mask.
Returns
Coordinates where conditions are satisfied or the combined mask.
Return type
Union[list[Coordinate], np.ndarray]
swap_pos(agent_a: Agent, agent_b: Agent) → None
Swap agents positions.
torus_adj(pos: tuple[int, int]) → tuple[int, int]
Convert coordinate, handling torus looping.
class MultiGrid(width: int, height: int, torus: bool, property_layers: None | PropertyLayer | list[PropertyLayer]
= None)
Rectangular grid where each cell can contain more than one agent.
Grid cells are indexed by [x, y], where [0, 0] is assumed to be at bottom-left and [width-1, height-1] is the
top-right. If a grid is toroidal, the top and bottom, and left and right, edges wrap to each other.
This class maintains an empties property, which is a set of coordinates for all cells that currently contain no
agents. This property is updated automatically as agents are added to or removed from the grid.

2.4. Citing Mesa

163

Mesa Documentation, Release .1

Properties:
width, height: The grid’s width and height. torus: Boolean which determines whether to treat the grid as a
torus. empties: Returns a set of (x, y) tuples for all empty cells.
Initializes a new _PropertyGrid instance with specified dimensions and optional property layers.
Parameters
• width (int) – The width of the grid (number of columns).
• height (int) – The height of the grid (number of rows).
• torus (bool) – A boolean indicating if the grid should behave like a torus.
• property_layers (None | PropertyLayer | list[PropertyLayer], optional)
– A single PropertyLayer instance, a list of PropertyLayer instances, or None to initialize
without any property layers.
Raises
ValueError – If a property layer’s dimensions do not match the grid dimensions.
static default_val() → list[Agent]
Default value for new cell elements.
remove_agent(agent: Agent) → None
Remove the agent from the given location and set its pos attribute to None.
iter_neighbors(pos: tuple[int, int], moore: bool, include_center: bool = False, radius: int = 1) →
Iterator[Agent]
Return an iterator over neighbors to a certain point.
Parameters
• pos – Coordinates for the neighborhood to get.
• moore –
If True, return Moore neighborhood
(including diagonals)
If False, return Von Neumann neighborhood
(exclude diagonals)
• include_center – If True, return the (x, y) cell as well. Otherwise, return surrounding
cells only.
• radius – radius, in cells, of neighborhood to get.
Returns
An iterator of non-None objects in the given neighborhood; at most 9 if Moore, 5 if VonNeumann (8 and 4 if not including the center).
add_property_layer(property_layer: PropertyLayer)
Adds a new property layer to the grid.
Parameters
property_layer (PropertyLayer) – The PropertyLayer instance to be added to the grid.
Raises
• ValueError – If a property layer with the same name already exists in the grid.
• ValueError – If the dimensions of the property layer do not match the grid’s dimensions.

164

Chapter 2. Using Mesa

Mesa Documentation, Release .1

property agents:

AgentSet

Return an AgentSet with the agents in the space.
coord_iter() → Iterator[tuple[Agent | None, tuple[int, int]]]
An iterator that returns positions as well as cell contents.
property empty_mask:

ndarray

Returns a boolean mask indicating empty cells on the grid.
exists_empty_cells() → bool
Return True if any cells empty else False.
get_neighborhood(pos: tuple[int, int], moore: bool, include_center: bool = False, radius: int = 1) →
Sequence[tuple[int, int]]
Return a list of cells that are in the neighborhood of a certain point.
Parameters
• pos – Coordinate tuple for the neighborhood to get.
• moore – If True, return Moore neighborhood (including diagonals) If False, return Von
Neumann neighborhood (exclude diagonals)
• include_center – If True, return the (x, y) cell as well. Otherwise, return surrounding
cells only.
• radius – radius, in cells, of neighborhood to get.
Returns
A list of coordinate tuples representing the neighborhood; With radius 1, at most 9 if Moore,
5 if Von Neumann (8 and 4 if not including the center).
get_neighborhood_mask(pos: tuple[int, int], moore: bool, include_center: bool, radius: int) → ndarray
Generate a boolean mask representing the neighborhood.
Helper method for select_cells_multi_properties() and move_agent_to_random_cell()
Parameters
• pos (Coordinate) – Center of the neighborhood.
• moore (bool) – True for Moore neighborhood, False for Von Neumann.
• include_center (bool) – Include the central cell in the neighborhood.
• radius (int) – The radius of the neighborhood.
Returns
A boolean mask representing the neighborhood.
Return type
np.ndarray
get_neighbors(pos: tuple[int, int], moore: bool, include_center: bool = False, radius: int = 1) →
list[Agent]
Return a list of neighbors to a certain point.
Parameters
• pos – Coordinate tuple for the neighborhood to get.
• moore –

2.4. Citing Mesa

165

Mesa Documentation, Release .1

If True, return Moore neighborhood
(including diagonals)
If False, return Von Neumann neighborhood
(exclude diagonals)
• include_center – If True, return the (x, y) cell as well. Otherwise, return surrounding
cells only.
• radius – radius, in cells, of neighborhood to get.
Returns
A list of non-None objects in the given neighborhood; at most 9 if Moore, 5 if Von-Neumann
(8 and 4 if not including the center).
is_cell_empty(pos: tuple[int, int]) → bool
Returns a bool of the contents of a cell.
iter_neighborhood(pos: tuple[int, int], moore: bool, include_center: bool = False, radius: int = 1) →
Iterator[tuple[int, int]]
Return an iterator over cell coordinates that are in the neighborhood of a certain point.
Parameters
• pos – Coordinate tuple for the neighborhood to get.
• moore –
If True, return Moore neighborhood
(including diagonals)
If False, return Von Neumann neighborhood
(exclude diagonals)
• include_center – If True, return the (x, y) cell as well. Otherwise, return surrounding
cells only.
• radius – radius, in cells, of neighborhood to get.
Returns
An iterator of coordinate tuples representing the neighborhood. For example with radius 1, it
will return list with number of elements equals at most 9 (8) if Moore, 5 (4) if Von Neumann
(if not including the center).
move_agent(agent: Agent, pos: tuple[int, int]) → None
Move an agent from its current position to a new position.
Parameters
• agent – Agent object to move. Assumed to have its current location stored in a ‘pos’ tuple.
• pos – Tuple of new position to move the agent to.
move_agent_to_one_of(agent: Agent, pos: list[tuple[int, int]], selection: str = 'random', handle_empty: str
| None = None) → None
Move an agent to one of the given positions.
Parameters
• agent – Agent object to move. Assumed to have its current location stored in a ‘pos’ tuple.
• pos – List of possible positions.

166

Chapter 2. Using Mesa

Mesa Documentation, Release .1

• selection – String, either “random” (default) or “closest”. If “closest” is selected and
multiple cells are the same distance, one is chosen randomly.
• handle_empty – String, either “warning”, “error” or None (default). If “warning” or
“error” is selected and no positions are given (an empty list), a warning or error is raised
respectively.
move_to_empty(agent: Agent) → None
Moves agent to a random empty cell, vacating agent’s old cell.
out_of_bounds(pos: tuple[int, int]) → bool
Determines whether position is off the grid, returns the out of bounds coordinate.
remove_property_layer(property_name: str)
Removes a property layer from the grid by its name.
Parameters
property_name (str) – The name of the property layer to be removed.
Raises
ValueError – If a property layer with the given name does not exist in the grid.
select_cells(conditions: dict | None = None, extreme_values: dict | None = None, masks: ndarray |
list[ndarray] = None, only_empty: bool = False, return_list: bool = True) → list[tuple[int,
int]] | ndarray
Select cells based on property conditions, extreme values, and/or masks, with an option to only select empty
cells.
Parameters
• conditions (dict) – A dictionary where keys are property names and values are callables
that return a boolean when applied.
• extreme_values (dict) – A dictionary where keys are property names and values are
either ‘highest’ or ‘lowest’.
• masks (np.ndarray | list[np.ndarray], optional) – A mask or list of masks to
restrict the selection.
• only_empty (bool, optional) – If True, only select cells that are empty. Default is
False.
• return_list (bool, optional) – If True, return a list of coordinates, otherwise return
a mask.
Returns
Coordinates where conditions are satisfied or the combined mask.
Return type
Union[list[Coordinate], np.ndarray]
swap_pos(agent_a: Agent, agent_b: Agent) → None
Swap agents positions.
torus_adj(pos: tuple[int, int]) → tuple[int, int]
Convert coordinate, handling torus looping.
class HexSingleGrid(width: int, height: int, torus: bool, property_layers: None | PropertyLayer |
list[PropertyLayer] = None)
Hexagonal SingleGrid: a SingleGrid where neighbors are computed according to a hexagonal tiling of the grid.
Functions according to odd-q rules. See http://www.redblobgames.com/grids/hexagons/#coordinates for more.
2.4. Citing Mesa

167

Mesa Documentation, Release .1

This class also maintains an empties property, similar to SingleGrid, which provides a set of coordinates for all
empty hexagonal cells.
Properties:
width, height: The grid’s width and height. torus: Boolean which determines whether to treat the grid as a
torus. empties: Returns a set of hexagonal coordinates for all empty cells.
Initializes a new _PropertyGrid instance with specified dimensions and optional property layers.
Parameters
• width (int) – The width of the grid (number of columns).
• height (int) – The height of the grid (number of rows).
• torus (bool) – A boolean indicating if the grid should behave like a torus.
• property_layers (None | PropertyLayer | list[PropertyLayer], optional)
– A single PropertyLayer instance, a list of PropertyLayer instances, or None to initialize
without any property layers.
Raises
ValueError – If a property layer’s dimensions do not match the grid dimensions.
add_property_layer(property_layer: PropertyLayer)
Adds a new property layer to the grid.
Parameters
property_layer (PropertyLayer) – The PropertyLayer instance to be added to the grid.
Raises
• ValueError – If a property layer with the same name already exists in the grid.
• ValueError – If the dimensions of the property layer do not match the grid’s dimensions.
property agents:

AgentSet

Return an AgentSet with the agents in the space.
coord_iter() → Iterator[tuple[Agent | None, tuple[int, int]]]
An iterator that returns positions as well as cell contents.
static default_val() → None
Default value for new cell elements.
property empty_mask: ndarray
Returns a boolean mask indicating empty cells on the grid.
exists_empty_cells() → bool
Return True if any cells empty else False.
get_neighborhood(pos: tuple[int, int], include_center: bool = False, radius: int = 1) → list[tuple[int, int]]
Return a list of coordinates that are in the neighborhood of a certain point.
To calculate the neighborhood for a HexGrid the parity of the x coordinate of the point is important, the
neighborhood can be sketched as:
Always: (0,-), (0,+) When x is even: (-,+), (-,0), (+,+), (+,0) When x is odd: (-,0), (-,-), (+,0), (+,-)
Parameters
• pos – Coordinate tuple for the neighborhood to get.

168

Chapter 2. Using Mesa

Mesa Documentation, Release .1

• include_center – If True, return the (x, y) cell as well. Otherwise, return surrounding
cells only.
• radius – radius, in cells, of neighborhood to get.
Returns
A list of coordinate tuples representing the neighborhood. For example with radius 1, it will
return list with number of elements equals at most 9 (8) if Moore, 5 (4) if Von Neumann (if
not including the center).
get_neighborhood_mask(pos: tuple[int, int], moore: bool, include_center: bool, radius: int) → ndarray
Generate a boolean mask representing the neighborhood.
Helper method for select_cells_multi_properties() and move_agent_to_random_cell()
Parameters
• pos (Coordinate) – Center of the neighborhood.
• moore (bool) – True for Moore neighborhood, False for Von Neumann.
• include_center (bool) – Include the central cell in the neighborhood.
• radius (int) – The radius of the neighborhood.
Returns
A boolean mask representing the neighborhood.
Return type
np.ndarray
get_neighbors(pos: tuple[int, int], include_center: bool = False, radius: int = 1) → list[Agent]
Return a list of neighbors to a certain point.
Parameters
• pos – Coordinate tuple for the neighborhood to get.
• include_center – If True, return the (x, y) cell as well. Otherwise, return surrounding
cells only.
• radius – radius, in cells, of neighborhood to get.
Returns
A list of non-None objects in the given neighborhood
is_cell_empty(pos: tuple[int, int]) → bool
Returns a bool of the contents of a cell.
iter_neighborhood(pos: tuple[int, int], include_center: bool = False, radius: int = 1) → Iterator[tuple[int,
int]]
Return an iterator over cell coordinates that are in the neighborhood of a certain point.
Parameters
• pos – Coordinate tuple for the neighborhood to get.
• include_center – If True, return the (x, y) cell as well. Otherwise, return surrounding
cells only.
• radius – radius, in cells, of neighborhood to get.
Returns
An iterator of coordinate tuples representing the neighborhood.

2.4. Citing Mesa

169

Mesa Documentation, Release .1

iter_neighbors(pos: tuple[int, int], include_center: bool = False, radius: int = 1) → Iterator[Agent]
Return an iterator over neighbors to a certain point.
Parameters
• pos – Coordinates for the neighborhood to get.
• include_center – If True, return the (x, y) cell as well. Otherwise, return surrounding
cells only.
• radius – radius, in cells, of neighborhood to get.
Returns
An iterator of non-None objects in the given neighborhood
move_agent(agent: Agent, pos: tuple[int, int]) → None
Move an agent from its current position to a new position.
Parameters
• agent – Agent object to move. Assumed to have its current location stored in a ‘pos’ tuple.
• pos – Tuple of new position to move the agent to.
move_agent_to_one_of(agent: Agent, pos: list[tuple[int, int]], selection: str = 'random', handle_empty: str
| None = None) → None
Move an agent to one of the given positions.
Parameters
• agent – Agent object to move. Assumed to have its current location stored in a ‘pos’ tuple.
• pos – List of possible positions.
• selection – String, either “random” (default) or “closest”. If “closest” is selected and
multiple cells are the same distance, one is chosen randomly.
• handle_empty – String, either “warning”, “error” or None (default). If “warning” or
“error” is selected and no positions are given (an empty list), a warning or error is raised
respectively.
move_to_empty(agent: Agent) → None
Moves agent to a random empty cell, vacating agent’s old cell.
out_of_bounds(pos: tuple[int, int]) → bool
Determines whether position is off the grid, returns the out of bounds coordinate.
remove_agent(agent: Agent) → None
Remove the agent from the grid and set its pos attribute to None.
remove_property_layer(property_name: str)
Removes a property layer from the grid by its name.
Parameters
property_name (str) – The name of the property layer to be removed.
Raises
ValueError – If a property layer with the given name does not exist in the grid.
select_cells(conditions: dict | None = None, extreme_values: dict | None = None, masks: ndarray |
list[ndarray] = None, only_empty: bool = False, return_list: bool = True) → list[tuple[int,
int]] | ndarray

170

Chapter 2. Using Mesa

Mesa Documentation, Release .1

Select cells based on property conditions, extreme values, and/or masks, with an option to only select empty
cells.
Parameters
• conditions (dict) – A dictionary where keys are property names and values are callables
that return a boolean when applied.
• extreme_values (dict) – A dictionary where keys are property names and values are
either ‘highest’ or ‘lowest’.
• masks (np.ndarray | list[np.ndarray], optional) – A mask or list of masks to
restrict the selection.
• only_empty (bool, optional) – If True, only select cells that are empty. Default is
False.
• return_list (bool, optional) – If True, return a list of coordinates, otherwise return
a mask.
Returns
Coordinates where conditions are satisfied or the combined mask.
Return type
Union[list[Coordinate], np.ndarray]
swap_pos(agent_a: Agent, agent_b: Agent) → None
Swap agents positions.
torus_adj(pos: tuple[int, int]) → tuple[int, int]
Convert coordinate, handling torus looping.
class HexMultiGrid(width: int, height: int, torus: bool, property_layers: None | PropertyLayer |
list[PropertyLayer] = None)
Hexagonal MultiGrid: a MultiGrid where neighbors are computed according to a hexagonal tiling of the grid.
Functions according to odd-q rules. See http://www.redblobgames.com/grids/hexagons/#coordinates for more.
Similar to the standard MultiGrid, this class maintains an empties property, which is a set of coordinates for all
hexagonal cells that currently contain no agents. This property is updated automatically as agents are added to
or removed from the grid.
Properties:
width, height: The grid’s width and height. torus: Boolean which determines whether to treat the grid as a
torus. empties: Returns a set of hexagonal coordinates for all empty cells.
Initializes a new _PropertyGrid instance with specified dimensions and optional property layers.
Parameters
• width (int) – The width of the grid (number of columns).
• height (int) – The height of the grid (number of rows).
• torus (bool) – A boolean indicating if the grid should behave like a torus.
• property_layers (None | PropertyLayer | list[PropertyLayer], optional)
– A single PropertyLayer instance, a list of PropertyLayer instances, or None to initialize
without any property layers.
Raises
ValueError – If a property layer’s dimensions do not match the grid dimensions.

2.4. Citing Mesa

171

Mesa Documentation, Release .1

add_property_layer(property_layer: PropertyLayer)
Adds a new property layer to the grid.
Parameters
property_layer (PropertyLayer) – The PropertyLayer instance to be added to the grid.
Raises
• ValueError – If a property layer with the same name already exists in the grid.
• ValueError – If the dimensions of the property layer do not match the grid’s dimensions.
property agents:

AgentSet

Return an AgentSet with the agents in the space.
coord_iter() → Iterator[tuple[Agent | None, tuple[int, int]]]
An iterator that returns positions as well as cell contents.
static default_val() → list[Agent]
Default value for new cell elements.
property empty_mask:

ndarray

Returns a boolean mask indicating empty cells on the grid.
exists_empty_cells() → bool
Return True if any cells empty else False.
get_neighborhood(pos: tuple[int, int], include_center: bool = False, radius: int = 1) → list[tuple[int, int]]
Return a list of coordinates that are in the neighborhood of a certain point.
To calculate the neighborhood for a HexGrid the parity of the x coordinate of the point is important, the
neighborhood can be sketched as:
Always: (0,-), (0,+) When x is even: (-,+), (-,0), (+,+), (+,0) When x is odd: (-,0), (-,-), (+,0), (+,-)
Parameters
• pos – Coordinate tuple for the neighborhood to get.
• include_center – If True, return the (x, y) cell as well. Otherwise, return surrounding
cells only.
• radius – radius, in cells, of neighborhood to get.
Returns
A list of coordinate tuples representing the neighborhood. For example with radius 1, it will
return list with number of elements equals at most 9 (8) if Moore, 5 (4) if Von Neumann (if
not including the center).
get_neighborhood_mask(pos: tuple[int, int], moore: bool, include_center: bool, radius: int) → ndarray
Generate a boolean mask representing the neighborhood.
Helper method for select_cells_multi_properties() and move_agent_to_random_cell()
Parameters
• pos (Coordinate) – Center of the neighborhood.
• moore (bool) – True for Moore neighborhood, False for Von Neumann.
• include_center (bool) – Include the central cell in the neighborhood.
• radius (int) – The radius of the neighborhood.
172

Chapter 2. Using Mesa

Mesa Documentation, Release .1

Returns
A boolean mask representing the neighborhood.
Return type
np.ndarray
get_neighbors(pos: tuple[int, int], include_center: bool = False, radius: int = 1) → list[Agent]
Return a list of neighbors to a certain point.
Parameters
• pos – Coordinate tuple for the neighborhood to get.
• include_center – If True, return the (x, y) cell as well. Otherwise, return surrounding
cells only.
• radius – radius, in cells, of neighborhood to get.
Returns
A list of non-None objects in the given neighborhood
is_cell_empty(pos: tuple[int, int]) → bool
Returns a bool of the contents of a cell.
iter_neighborhood(pos: tuple[int, int], include_center: bool = False, radius: int = 1) → Iterator[tuple[int,
int]]
Return an iterator over cell coordinates that are in the neighborhood of a certain point.
Parameters
• pos – Coordinate tuple for the neighborhood to get.
• include_center – If True, return the (x, y) cell as well. Otherwise, return surrounding
cells only.
• radius – radius, in cells, of neighborhood to get.
Returns
An iterator of coordinate tuples representing the neighborhood.
iter_neighbors(pos: tuple[int, int], include_center: bool = False, radius: int = 1) → Iterator[Agent]
Return an iterator over neighbors to a certain point.
Parameters
• pos – Coordinates for the neighborhood to get.
• include_center – If True, return the (x, y) cell as well. Otherwise, return surrounding
cells only.
• radius – radius, in cells, of neighborhood to get.
Returns
An iterator of non-None objects in the given neighborhood
move_agent(agent: Agent, pos: tuple[int, int]) → None
Move an agent from its current position to a new position.
Parameters
• agent – Agent object to move. Assumed to have its current location stored in a ‘pos’ tuple.
• pos – Tuple of new position to move the agent to.

2.4. Citing Mesa

173

Mesa Documentation, Release .1

move_agent_to_one_of(agent: Agent, pos: list[tuple[int, int]], selection: str = 'random', handle_empty: str
| None = None) → None
Move an agent to one of the given positions.
Parameters
• agent – Agent object to move. Assumed to have its current location stored in a ‘pos’ tuple.
• pos – List of possible positions.
• selection – String, either “random” (default) or “closest”. If “closest” is selected and
multiple cells are the same distance, one is chosen randomly.
• handle_empty – String, either “warning”, “error” or None (default). If “warning” or
“error” is selected and no positions are given (an empty list), a warning or error is raised
respectively.
move_to_empty(agent: Agent) → None
Moves agent to a random empty cell, vacating agent’s old cell.
out_of_bounds(pos: tuple[int, int]) → bool
Determines whether position is off the grid, returns the out of bounds coordinate.
remove_agent(agent: Agent) → None
Remove the agent from the given location and set its pos attribute to None.
remove_property_layer(property_name: str)
Removes a property layer from the grid by its name.
Parameters
property_name (str) – The name of the property layer to be removed.
Raises
ValueError – If a property layer with the given name does not exist in the grid.
select_cells(conditions: dict | None = None, extreme_values: dict | None = None, masks: ndarray |
list[ndarray] = None, only_empty: bool = False, return_list: bool = True) → list[tuple[int,
int]] | ndarray
Select cells based on property conditions, extreme values, and/or masks, with an option to only select empty
cells.
Parameters
• conditions (dict) – A dictionary where keys are property names and values are callables
that return a boolean when applied.
• extreme_values (dict) – A dictionary where keys are property names and values are
either ‘highest’ or ‘lowest’.
• masks (np.ndarray | list[np.ndarray], optional) – A mask or list of masks to
restrict the selection.
• only_empty (bool, optional) – If True, only select cells that are empty. Default is
False.
• return_list (bool, optional) – If True, return a list of coordinates, otherwise return
a mask.
Returns
Coordinates where conditions are satisfied or the combined mask.
Return type
Union[list[Coordinate], np.ndarray]
174

Chapter 2. Using Mesa

Mesa Documentation, Release .1

swap_pos(agent_a: Agent, agent_b: Agent) → None
Swap agents positions.
torus_adj(pos: tuple[int, int]) → tuple[int, int]
Convert coordinate, handling torus looping.
class ContinuousSpace(x_max: float, y_max: float, torus: bool, x_min: float = 0, y_min: float = 0)
Continuous space where each agent can have an arbitrary position.
Assumes that all agents have a pos property storing their position as an (x, y) tuple.
This class uses a numpy array internally to store agents in order to speed up neighborhood lookups. This array
is calculated on the first neighborhood lookup, and is updated if agents are added or removed.
The concept of ‘empty cells’ is not directly applicable in continuous space, as positions are not discretized.
Create a new continuous space.
Parameters
• x_max – the maximum x-coordinate
• y_max – the maximum y-coordinate.
• torus – Boolean for whether the edges loop around.
• x_min – (default 0) If provided, set the minimum x -coordinate for the space. Below them,
values loop to the other edge (if torus=True) or raise an exception.
• y_min – (default 0) If provided, set the minimum y -coordinate for the space. Below them,
values loop to the other edge (if torus=True) or raise an exception.
property agents:

AgentSet

Return an AgentSet with the agents in the space.
move_agent(agent: Agent, pos: tuple[float, float] | ndarray[tuple[int, ...], dtype[float]]) → None
Move an agent from its current position to a new position.
Parameters
• agent – The agent object to move.
• pos – Coordinate tuple to move the agent to.
remove_agent(agent: Agent) → None
Remove an agent from the space.
Parameters
agent – The agent object to remove
get_neighbors(pos: tuple[float, float] | ndarray[tuple[int, ...], dtype[float]], radius: float, include_center:
bool = True) → list[Agent]
Get all agents within a certain radius.
Parameters
• pos – (x,y) coordinate tuple to center the search at.
• radius – Get all the objects within this distance of the center.
• include_center – If True, include an object at the exact provided coordinates. i.e. if you
are searching for the neighbors of a given agent, True will include that agent in the results.

2.4. Citing Mesa

175

Mesa Documentation, Release .1

Notes
If 1 or more agents are located on pos, include_center=False will remove all these agents from the results.
So, if you really want to get the neighbors of a given agent, you should set include_center=True, and then
filter the list of agents to remove the given agent (i.e., self when calling it from an agent).
get_heading(pos_1: tuple[float, float] | ndarray[tuple[int, ...], dtype[float]], pos_2: tuple[float, float] |
ndarray[tuple[int, ...], dtype[float]]) → tuple[float, float] | ndarray[tuple[int, ...], dtype[float]]
Get the heading vector between two points, accounting for toroidal space.
It is possible to calculate the heading angle by applying the atan2 function to the result.
Parameters
• pos_1 – Coordinate tuples for both points.
• pos_2 – Coordinate tuples for both points.
get_distance(pos_1: tuple[float, float] | ndarray[tuple[int, ...], dtype[float]], pos_2: tuple[float, float] |
ndarray[tuple[int, ...], dtype[float]]) → float
Get the distance between two point, accounting for toroidal space.
Parameters
• pos_1 – Coordinate tuples for point1.
• pos_2 – Coordinate tuples for point2.
torus_adj(pos: tuple[float, float] | ndarray[tuple[int, ...], dtype[float]]) → tuple[float, float] |
ndarray[tuple[int, ...], dtype[float]]
Adjust coordinates to handle torus looping.
If the coordinate is out-of-bounds and the space is toroidal, return the corresponding point within the space.
If the space is not toroidal, raise an exception.
Parameters
pos – Coordinate tuple to convert.
out_of_bounds(pos: tuple[float, float] | ndarray[tuple[int, ...], dtype[float]]) → bool
Check if a point is out of bounds.
class NetworkGrid(g: Any)
Network Grid where each node contains zero or more agents.
Create a new network.
Parameters
g – a NetworkX graph instance.
property agents:

AgentSet

Return an AgentSet with the agents in the space.
static default_val() → list
Default value for a new node.
get_neighborhood(node_id: int, include_center: bool = False, radius: int = 1) → list[int]
Get all adjacent nodes within a certain radius.
Parameters
• node_id – node id for which to get neighborhood
• include_center – boolean to include node itself or not

176

Chapter 2. Using Mesa

Mesa Documentation, Release .1

• radius – size of neighborhood
Returns
a list
get_neighbors(node_id: int, include_center: bool = False, radius: int = 1) → list[Agent]
Get all agents in adjacent nodes (within a certain radius).
Parameters
• node_id – node id for which to get neighbors
• include_center – whether to include node itself or not
• radius – size of neighborhood in which to find neighbors
Returns
list of agents in neighborhood.
move_agent(agent: Agent, node_id: int) → None
Move an agent from its current node to a new node.
Parameters
• agent – agent instance
• node_id – id of node
remove_agent(agent: Agent) → None
Remove the agent from the network and set its pos attribute to None.
Parameters
agent – agent instance
is_cell_empty(node_id: int) → bool
Returns a bool of the contents of a cell.
Parameters
node_id – id of node
get_cell_list_contents(cell_list: list[int]) → list[Agent]
Returns a list of the agents contained in the nodes identified in cell_list.
Nodes with empty content are excluded.
Parameters
cell_list – list of cell ids.
Returns
list of the agents contained in the nodes identified in cell_list.
get_all_cell_contents() → list[Agent]
Returns a list of all the agents in the network.
iter_cell_list_contents(cell_list: list[int]) → Iterator[Agent]
Returns an iterator of the agents contained in the nodes identified in cell_list.
Nodes with empty content are excluded.
Parameters
cell_list – list of cell ids.
Returns
iterator of the agents contained in the nodes identified in cell_list.

2.4. Citing Mesa

177

Mesa Documentation, Release .1

2.4.4.4 Discrete Space
Cell spaces for active, property-rich spatial modeling in Mesa.
Cell spaces extend Mesa’s spatial modeling capabilities by making the space itself active - each position (cell) can have
properties and behaviors rather than just containing agents. This enables more sophisticated environmental modeling
and agent-environment interactions.
Key components: - Cells: Active positions that can have properties and contain agents - CellAgents: Agents that understand how to interact with cells - Spaces: Different cell organization patterns (grids, networks, etc.) - PropertyLayers:
Efficient property storage and manipulation
This is particularly useful for models where the environment plays an active role, like resource growth, pollution diffusion, or infrastructure networks. The cell space system is experimental and under active development.
class Cell(coordinate: tuple[int, ...], capacity: int | None = None, random: Random | None = None)
The cell represents a position in a discrete space.
coordinate
the position of the cell in the discrete space
Type
Tuple[int, int]
agents
the agents occupying the cell
Type
List[Agent]
capacity
the maximum number of agents that can simultaneously occupy the cell
Type
int
random
the random number generator
Type
Random
Initialise the cell.
Parameters
• coordinate – coordinates of the cell
• capacity (int) – the capacity of the cell. If None, the capacity is infinite
• random (Random) – the random number generator to use
add_agent(agent: CellAgent) → None
Adds an agent to the cell.
Parameters
agent (CellAgent) – agent to add to this Cell
property agents:

list[CellAgent]

Returns a list of the agents occupying the cell.

178

Chapter 2. Using Mesa

Mesa Documentation, Release .1

connect(other: Cell, key: tuple[int, ...] | None = None) → None
Connects this cell to another cell.
Parameters
• other (Cell) – other cell to connect to
• key (Tuple[int, ...]) – key for the connection. Should resemble a relative coordinate
disconnect(other: Cell) → None
Disconnects this cell from another cell.
Parameters
other (Cell) – other cell to remove from connections
get_neighborhood(radius: int = 1, include_center: bool = False) → CellCollection[Cell]
Returns a list of all neighboring cells for the given radius.
For getting the direct neighborhood (i.e., radius=1) you can also use the neighborhood property.
Parameters
• radius (int) – the radius of the neighborhood
• include_center (bool) – include the center of the neighborhood
Returns
a list of all neighboring cells
property is_empty:

bool

Returns a bool of the contents of a cell.
property is_full:

bool

Returns a bool of the contents of a cell.
property neighborhood:

CellCollection[Cell]

Returns the direct neighborhood of the cell.
This is equivalent to cell.get_neighborhood(radius=1)
remove_agent(agent: CellAgent) → None
Removes an agent from the cell.
Parameters
agent (CellAgent) – agent to remove from this cell
class CellAgent(model: Model, *args, **kwargs)
Cell Agent is an extension of the Agent class and adds behavior for moving in discrete spaces.
cell
The cell the agent is currently in.
Type
Cell
Create a new agent.
Parameters
• model (Model) – The model instance in which the agent exists.
• args – Passed on to super.
• kwargs – Passed on to super.

2.4. Citing Mesa

179

Mesa Documentation, Release .1

Notes
to make proper use of python’s super, in each class remove the arguments and keyword arguments you need and
pass on the rest to super
remove()
Remove the agent from the model.
class CellCollection(cells: Mapping[T, list[CellAgent]] | Iterable[T], random: Random | None = None)
An immutable collection of cells.
cells
The list of cells this collection represents
Type
List[Cell]
agents
List of agents occupying the cells in this collection
Type
List[CellAgent]
random
The random number generator
Type
Random
Notes
A UserWarning is issued if random=None. You can resolve this warning by explicitly passing a random number
generator. In most cases, this will be the seeded random number generator in the model. So, you would do
random=self.random in a Model or Agent instance.
Initialize a CellCollection.
Parameters
• cells – cells to add to the collection
• random – a seeded random number generator.
select(filter_func: Callable[[T], bool] | None = None, at_most: int | float = inf )
Select cells based on filter function.
Parameters
• filter_func – filter function
• at_most – The maximum amount of cells to select. Defaults to infinity. - If an integer, at
most the first number of matching cells is selected. - If a float between 0 and 1, at most that
fraction of original number of cells
Returns
CellCollection
select_random_agent() → CellAgent
Select a random agent.
Returns
CellAgent instance

180

Chapter 2. Using Mesa

Mesa Documentation, Release .1

select_random_cell() → T
Select a random cell.
class DiscreteSpace(capacity: int | None = None, cell_klass: type[~mesa.discrete_space.discrete_space.T] =
<class 'mesa.discrete_space.cell.Cell'>, random: ~random.Random | None = None)
Base class for all discrete spaces.
capacity
The capacity of the cells in the discrete space
Type
int
all_cells
The cells composing the discrete space
Type
CellCollection
random
The random number generator
Type
Random
cell_klass
the type of cell class
Type
Type
empties
collection of all cells that are empty
Type
CellCollection
property_layers
the property layers of the discrete space
Type
dict[str, PropertyLayer]
Notes
A UserWarning is issued if random=None. You can resolve this warning by explicitly passing a random number
generator. In most cases, this will be the seeded random number generator in the model. So, you would do
random=self.random in a Model or Agent instance.
Instantiate a DiscreteSpace.
Parameters
• capacity – capacity of cells
• cell_klass – base class for all cells
• random – random number generator

2.4. Citing Mesa

181

Mesa Documentation, Release .1

add_cell(cell: T )
Add a cell to the space.
Parameters
cell – cell to add
ò Note
Discrete spaces rely on caching neighborhood relations for speedups. Adding or removing cells and
connections at runtime is possible. However, only the caches of cells directly affected will be cleared.
So if you rely on getting neighborhoods of cells with a radius higher than 1, these might not be cleared
correctly if you are adding or removing cells and connections at runtime.
add_connection(cell1: T , cell2: T )
Add a connection between the two cells.
ò Note
Discrete spaces rely on caching neighborhood relations for speedups. Adding or removing cells and
connections at runtime is possible. However, only the caches of cells directly affected will be cleared.
So if you rely on getting neighborhoods of cells with a radius higher than 1, these might not be cleared
correctly if you are adding or removing cells and connections at runtime.
property agents: AgentSet
Return an AgentSet with the agents in the space.
property all_cells
Return all cells in space.
property empties: CellCollection[T]
Return all empty in spaces.
remove_cell(cell: T )
Remove a cell from the space.
ò Note
Discrete spaces rely on caching neighborhood relations for speedups. Adding or removing cells and
connections at runtime is possible. However, only the caches of cells directly affected will be cleared.
So if you rely on getting neighborhoods of cells with a radius higher than 1, these might not be cleared
correctly if you are adding or removing cells and connections at runtime.
remove_connection(cell1: T , cell2: T )
Remove a connection between the two cells.
ò Note
Discrete spaces rely on caching neighborhood relations for speedups. Adding or removing cells and
connections at runtime is possible. However, only the caches of cells directly affected will be cleared.
So if you rely on getting neighborhoods of cells with a radius higher than 1, these might not be cleared
correctly if you are adding or removing cells and connections at runtime.

182

Chapter 2. Using Mesa

Mesa Documentation, Release .1

select_random_empty_cell() → T
Select random empty cell.
class FixedAgent(model: Model, *args, **kwargs)
A patch in a 2D grid.
Create a new agent.
Parameters
• model (Model) – The model instance in which the agent exists.
• args – Passed on to super.
• kwargs – Passed on to super.
Notes
to make proper use of python’s super, in each class remove the arguments and keyword arguments you need and
pass on the rest to super
remove()
Remove the agent from the model.
class Grid(dimensions: ~collections.abc.Sequence[int], torus: bool = False, capacity: float | None = None,
random: ~random.Random | None = None, cell_klass: type[~mesa.discrete_space.grid.T] = <class
'mesa.discrete_space.cell.Cell'>)
Base class for all grid classes.
dimensions
the dimensions of the grid
Type
Sequence[int]
torus
whether the grid is a torus
Type
bool
capacity
the capacity of a grid cell
Type
int
random
the random number generator
Type
Random
_try_random
whether to get empty cell be repeatedly trying random cell
Type
bool

2.4. Citing Mesa

183

Mesa Documentation, Release .1

Notes
width and height are accessible via properties, higher dimensions can be retrieved via dimensions
Initialise the grid class.
Parameters
• dimensions – the dimensions of the space
• torus – whether the space wraps
• capacity – capacity of the grid cell
• random – a random number generator
• cell_klass – the base class to use for the cells
property height:

int

Convenience access to the height of the grid.
select_random_empty_cell() → T
Select random empty cell.
property width:

int

Convenience access to the width of the grid.
class Grid2DMovingAgent(model: Model, *args, **kwargs)
Mixin for moving agents in 2D grids.
Create a new agent.
Parameters
• model (Model) – The model instance in which the agent exists.
• args – Passed on to super.
• kwargs – Passed on to super.
Notes
to make proper use of python’s super, in each class remove the arguments and keyword arguments you need and
pass on the rest to super
move(direction: str, distance: int = 1)
Move the agent in a cardinal direction.
Parameters
• direction – The cardinal direction to move in.
• distance – The distance to move.
class HexGrid(dimensions: ~collections.abc.Sequence[int], torus: bool = False, capacity: float | None = None,
random: ~random.Random | None = None, cell_klass: type[~mesa.discrete_space.grid.T] =
<class 'mesa.discrete_space.cell.Cell'>)
A Grid with hexagonal tilling of the space.
Initialise the grid class.
Parameters
• dimensions – the dimensions of the space
• torus – whether the space wraps
184

Chapter 2. Using Mesa

Mesa Documentation, Release .1

• capacity – capacity of the grid cell
• random – a random number generator
• cell_klass – the base class to use for the cells
class Network(G: ~typing.Any, capacity: int | None = None, random: ~random.Random | None = None,
cell_klass: type[~mesa.discrete_space.cell.Cell] = <class 'mesa.discrete_space.cell.Cell'>)
A networked discrete space.
A Networked grid.
Parameters
• G – a NetworkX Graph instance.
• capacity (int) – the capacity of the cell
• random (Random) – a random number generator
• cell_klass (type[Cell]) – The base Cell class to use in the Network
add_cell(cell: Cell)
Add a cell to the space.
add_connection(cell1: Cell, cell2: Cell)
Add a connection between the two cells.
remove_cell(cell: Cell)
Remove a cell from the space.
remove_connection(cell1: Cell, cell2: Cell)
Remove a connection between the two cells.
class OrthogonalMooreGrid(dimensions: ~collections.abc.Sequence[int], torus: bool = False, capacity: float |
None = None, random: ~random.Random | None = None, cell_klass:
type[~mesa.discrete_space.grid.T] = <class 'mesa.discrete_space.cell.Cell'>)
Grid where cells are connected to their 8 neighbors.
Example for two dimensions: directions = [
(-1, -1), (-1, 0), (-1, 1), ( 0, -1), ( 0, 1), ( 1, -1), ( 1, 0), ( 1, 1),
]
Initialise the grid class.
Parameters
• dimensions – the dimensions of the space
• torus – whether the space wraps
• capacity – capacity of the grid cell
• random – a random number generator
• cell_klass – the base class to use for the cells
class OrthogonalVonNeumannGrid(dimensions: ~collections.abc.Sequence[int], torus: bool = False, capacity:
float | None = None, random: ~random.Random | None = None, cell_klass:
type[~mesa.discrete_space.grid.T] = <class
'mesa.discrete_space.cell.Cell'>)

2.4. Citing Mesa

185

Mesa Documentation, Release .1

Grid where cells are connected to their 4 neighbors.
Example for two dimensions: directions = [
(0, -1),
(-1, 0), ( 1, 0),
(0, 1),
]
Initialise the grid class.
Parameters
• dimensions – the dimensions of the space
• torus – whether the space wraps
• capacity – capacity of the grid cell
• random – a random number generator
• cell_klass – the base class to use for the cells
class PropertyLayer(name: str, dimensions: ~collections.abc.Sequence[int], default_value=0.0, dtype=<class
'float'>)
A class representing a layer of properties in a two-dimensional grid.
Each cell in the grid can store a value of a specified data type.
name
The name of the property layer.
dimensions
The width of the grid (number of columns).
data
A NumPy array representing the grid data.
Initializes a new PropertyLayer instance.
Parameters
• name – The name of the property layer.
• dimensions – the dimensions of the property layer.
• default_value – The default value to initialize each cell in the grid. Should ideally be of
the same type as specified by the dtype parameter.
• dtype (data-type, optional) – The desired data-type for the grid’s elements. Default
is float.
Notes
A UserWarning is raised if the default_value is not of a type compatible with dtype. The dtype parameter can
accept both Python data types (like bool, int or float) and NumPy data types (like np.int64 or np.float64).

186

Chapter 2. Using Mesa

Mesa Documentation, Release .1

aggregate(operation: Callable)
Perform an aggregate operation (e.g., sum, mean) on a property across all cells.
Parameters
operation – A function to apply. Can be a lambda function or a NumPy ufunc.
classmethod from_data(name: str, data: ndarray)
Create a property layer from a NumPy array.
Parameters
• name – The name of the property layer.
• data – A NumPy array representing the grid data.
modify_cells(operation: Callable, value=None, condition: Callable | None = None)
Modify cells using an operation, which can be a lambda function or a NumPy ufunc.
If a NumPy ufunc is used, an additional value should be provided.
Parameters
• operation – A function to apply. Can be a lambda function or a NumPy ufunc.
• value – The value to be used if the operation is a NumPy ufunc. Ignored for lambda
functions.
• condition – (Optional) A callable that returns a boolean array when applied to the data.
select_cells(condition: Callable, return_list=True)
Find cells that meet a specified condition using NumPy’s boolean indexing, in-place.
Parameters
• condition – A callable that returns a boolean array when applied to the data.
• return_list – (Optional) If True, return a list of (x, y) tuples. Otherwise, return a boolean
array.
Returns
A list of (x, y) tuples or a boolean array.
set_cells(value, condition: Callable | None = None)
Perform a batch update either on the entire grid or conditionally, in-place.
Parameters
• value – The value to be used for the update.
• condition – (Optional) A callable that returns a boolean array when applied to the data.
class VoronoiGrid(centroids_coordinates: ~collections.abc.Sequence[~collections.abc.Sequence[float]],
capacity: float | None = None, random: ~random.Random | None = None, cell_klass:
type[~mesa.discrete_space.cell.Cell] = <class 'mesa.discrete_space.cell.Cell'>,
capacity_function: callable = <function round_float>)
Voronoi meshed GridSpace.
A Voronoi Tessellation Grid.
Given a set of points, this class creates a grid where a cell is centered in each point, its neighbors are given by
Voronoi Tessellation cells neighbors and the capacity by the polygon area.
Parameters
• centroids_coordinates – coordinates of centroids to build the tessellation space
2.4. Citing Mesa

187

Mesa Documentation, Release .1

• capacity (int) – capacity of the cells in the discrete space
• random (Random) – random number generator
• cell_klass (type[Cell]) – type of cell class
• capacity_function (Callable) – function to compute (int) capacity according to (float)
area
Cells are positions in space that can have properties and contain agents.
A cell represents a location that can: - Have properties (like temperature or resources) - Track and limit the agents it
contains - Connect to neighboring cells - Provide neighborhood information
Cells form the foundation of the cell space system, enabling rich spatial environments where both location properties and agent behaviors matter. They’re useful for modeling things like varying terrain, infrastructure capacity, or
environmental conditions.
class Cell(coordinate: tuple[int, ...], capacity: int | None = None, random: Random | None = None)
The cell represents a position in a discrete space.
coordinate
the position of the cell in the discrete space
Type
Tuple[int, int]
agents
the agents occupying the cell
Type
List[Agent]
capacity
the maximum number of agents that can simultaneously occupy the cell
Type
int
random
the random number generator
Type
Random
Initialise the cell.
Parameters
• coordinate – coordinates of the cell
• capacity (int) – the capacity of the cell. If None, the capacity is infinite
• random (Random) – the random number generator to use
connect(other: Cell, key: tuple[int, ...] | None = None) → None
Connects this cell to another cell.
Parameters
• other (Cell) – other cell to connect to
• key (Tuple[int, ...]) – key for the connection. Should resemble a relative coordinate

188

Chapter 2. Using Mesa

Mesa Documentation, Release .1

disconnect(other: Cell) → None
Disconnects this cell from another cell.
Parameters
other (Cell) – other cell to remove from connections
add_agent(agent: CellAgent) → None
Adds an agent to the cell.
Parameters
agent (CellAgent) – agent to add to this Cell
remove_agent(agent: CellAgent) → None
Removes an agent from the cell.
Parameters
agent (CellAgent) – agent to remove from this cell
property is_empty:

bool

Returns a bool of the contents of a cell.
property is_full:

bool

Returns a bool of the contents of a cell.
property agents:

list[CellAgent]

Returns a list of the agents occupying the cell.
property neighborhood:

CellCollection[Cell]

Returns the direct neighborhood of the cell.
This is equivalent to cell.get_neighborhood(radius=1)
get_neighborhood(radius: int = 1, include_center: bool = False) → CellCollection[Cell]
Returns a list of all neighboring cells for the given radius.
For getting the direct neighborhood (i.e., radius=1) you can also use the neighborhood property.
Parameters
• radius (int) – the radius of the neighborhood
• include_center (bool) – include the center of the neighborhood
Returns
a list of all neighboring cells
Agents that understand how to exist in and move through cell spaces.
Provides specialized agent classes that handle cell occupation, movement, and proper registration: - CellAgent: Mobile
agents that can move between cells - FixedAgent: Immobile agents permanently fixed to cells - Grid2DMovingAgent:
Agents with grid-specific movement capabilities
These classes ensure consistent agent-cell relationships and proper state management as agents move through the space.
They can be used directly or as examples for creating custom cell-aware agents.
class HasCellProtocol(*args, **kwargs)
Protocol for discrete space cell holders.
class HasCell
Descriptor for cell movement behavior.

2.4. Citing Mesa

189

Mesa Documentation, Release .1

class BasicMovement
Mixin for moving agents in discrete space.
move_to(cell: Cell) → None
Move to a new cell.
move_relative(direction: tuple[int, ...])
Move to a cell relative to the current cell.
Parameters
direction – The direction to move in.
class FixedCell
Mixin for agents that are fixed to a cell.
class CellAgent(model: Model, *args, **kwargs)
Cell Agent is an extension of the Agent class and adds behavior for moving in discrete spaces.
cell
The cell the agent is currently in.
Type
Cell
Create a new agent.
Parameters
• model (Model) – The model instance in which the agent exists.
• args – Passed on to super.
• kwargs – Passed on to super.
Notes
to make proper use of python’s super, in each class remove the arguments and keyword arguments you need and
pass on the rest to super
remove()
Remove the agent from the model.
class FixedAgent(model: Model, *args, **kwargs)
A patch in a 2D grid.
Create a new agent.
Parameters
• model (Model) – The model instance in which the agent exists.
• args – Passed on to super.
• kwargs – Passed on to super.
Notes
to make proper use of python’s super, in each class remove the arguments and keyword arguments you need and
pass on the rest to super
remove()
Remove the agent from the model.

190

Chapter 2. Using Mesa

Mesa Documentation, Release .1

class Grid2DMovingAgent(model: Model, *args, **kwargs)
Mixin for moving agents in 2D grids.
Create a new agent.
Parameters
• model (Model) – The model instance in which the agent exists.
• args – Passed on to super.
• kwargs – Passed on to super.
Notes
to make proper use of python’s super, in each class remove the arguments and keyword arguments you need and
pass on the rest to super
move(direction: str, distance: int = 1)
Move the agent in a cardinal direction.
Parameters
• direction – The cardinal direction to move in.
• distance – The distance to move.
Collection class for managing and querying groups of cells.
The CellCollection class provides a consistent interface for operating on multiple cells, supporting: - Filtering and
selecting cells based on conditions - Random cell and agent selection - Access to contained agents - Group operations
This is useful for implementing area effects, zones, or any operation that needs to work with multiple cells as a unit.
The collection handles efficient iteration and agent access across cells. The class is used throughout the cell space
implementation to represent neighborhoods, selections, and other cell groupings.
class CellCollection(cells: Mapping[T, list[CellAgent]] | Iterable[T], random: Random | None = None)
An immutable collection of cells.
cells
The list of cells this collection represents
Type
List[Cell]
agents
List of agents occupying the cells in this collection
Type
List[CellAgent]
random
The random number generator
Type
Random
Notes
A UserWarning is issued if random=None. You can resolve this warning by explicitly passing a random number
generator. In most cases, this will be the seeded random number generator in the model. So, you would do
random=self.random in a Model or Agent instance.

2.4. Citing Mesa

191

Mesa Documentation, Release .1

Initialize a CellCollection.
Parameters
• cells – cells to add to the collection
• random – a seeded random number generator.
select_random_cell() → T
Select a random cell.
select_random_agent() → CellAgent
Select a random agent.
Returns
CellAgent instance
select(filter_func: Callable[[T], bool] | None = None, at_most: int | float = inf )
Select cells based on filter function.
Parameters
• filter_func – filter function
• at_most – The maximum amount of cells to select. Defaults to infinity. - If an integer, at
most the first number of matching cells is selected. - If a float between 0 and 1, at most that
fraction of original number of cells
Returns
CellCollection
Base class for building cell-based spatial environments.
DiscreteSpace provides the core functionality needed by all cell-based spaces: - Cell creation and tracking - Agent-cell
relationship management - Property layer support - Random selection capabilities - Capacity management
This serves as the foundation for specific space implementations like grids and networks, ensuring consistent behavior
and shared functionality across different space types. All concrete cell space implementations (grids, networks, etc.)
inherit from this class.
class DiscreteSpace(capacity: int | None = None, cell_klass: type[~mesa.discrete_space.discrete_space.T] =
<class 'mesa.discrete_space.cell.Cell'>, random: ~random.Random | None = None)
Base class for all discrete spaces.
capacity
The capacity of the cells in the discrete space
Type
int
all_cells
The cells composing the discrete space
Type
CellCollection
random
The random number generator
Type
Random

192

Chapter 2. Using Mesa

Mesa Documentation, Release .1

cell_klass
the type of cell class
Type
Type
empties
collection of all cells that are empty
Type
CellCollection
property_layers
the property layers of the discrete space
Type
dict[str, PropertyLayer]
Notes
A UserWarning is issued if random=None. You can resolve this warning by explicitly passing a random number
generator. In most cases, this will be the seeded random number generator in the model. So, you would do
random=self.random in a Model or Agent instance.
Instantiate a DiscreteSpace.
Parameters
• capacity – capacity of cells
• cell_klass – base class for all cells
• random – random number generator
property agents:

AgentSet

Return an AgentSet with the agents in the space.
add_cell(cell: T )
Add a cell to the space.
Parameters
cell – cell to add
ò Note
Discrete spaces rely on caching neighborhood relations for speedups. Adding or removing cells and
connections at runtime is possible. However, only the caches of cells directly affected will be cleared.
So if you rely on getting neighborhoods of cells with a radius higher than 1, these might not be cleared
correctly if you are adding or removing cells and connections at runtime.
remove_cell(cell: T )
Remove a cell from the space.
ò Note
Discrete spaces rely on caching neighborhood relations for speedups. Adding or removing cells and
connections at runtime is possible. However, only the caches of cells directly affected will be cleared.

2.4. Citing Mesa

193

Mesa Documentation, Release .1

So if you rely on getting neighborhoods of cells with a radius higher than 1, these might not be cleared
correctly if you are adding or removing cells and connections at runtime.
add_connection(cell1: T , cell2: T )
Add a connection between the two cells.
ò Note
Discrete spaces rely on caching neighborhood relations for speedups. Adding or removing cells and
connections at runtime is possible. However, only the caches of cells directly affected will be cleared.
So if you rely on getting neighborhoods of cells with a radius higher than 1, these might not be cleared
correctly if you are adding or removing cells and connections at runtime.
remove_connection(cell1: T , cell2: T )
Remove a connection between the two cells.
ò Note
Discrete spaces rely on caching neighborhood relations for speedups. Adding or removing cells and
connections at runtime is possible. However, only the caches of cells directly affected will be cleared.
So if you rely on getting neighborhoods of cells with a radius higher than 1, these might not be cleared
correctly if you are adding or removing cells and connections at runtime.
property all_cells
Return all cells in space.
property empties:

CellCollection[T]

Return all empty in spaces.
select_random_empty_cell() → T
Select random empty cell.
Grid-based cell space implementations with different connection patterns.
Provides several grid types for organizing cells: - OrthogonalMooreGrid: 8 neighbors in 2D, (3^n)-1 in nD - OrthogonalVonNeumannGrid: 4 neighbors in 2D, 2n in nD - HexGrid: 6 neighbors in hexagonal pattern (2D only)
Each grid type supports optional wrapping (torus) and cell capacity limits. Choose based on how movement and connectivity should work in your model - Moore for unrestricted movement, Von Neumann for orthogonal-only movement,
or Hex for more uniform distances.
pickle_gridcell(obj)
Helper function for pickling GridCell instances.
unpickle_gridcell(parent, fields)
Helper function for unpickling GridCell instances.
class Grid(dimensions: ~collections.abc.Sequence[int], torus: bool = False, capacity: float | None = None,
random: ~random.Random | None = None, cell_klass: type[~mesa.discrete_space.grid.T] = <class
'mesa.discrete_space.cell.Cell'>)
Base class for all grid classes.

194

Chapter 2. Using Mesa

Mesa Documentation, Release .1

dimensions
the dimensions of the grid
Type
Sequence[int]
torus
whether the grid is a torus
Type
bool
capacity
the capacity of a grid cell
Type
int
random
the random number generator
Type
Random
_try_random
whether to get empty cell be repeatedly trying random cell
Type
bool
Notes
width and height are accessible via properties, higher dimensions can be retrieved via dimensions
Initialise the grid class.
Parameters
• dimensions – the dimensions of the space
• torus – whether the space wraps
• capacity – capacity of the grid cell
• random – a random number generator
• cell_klass – the base class to use for the cells
property width: int
Convenience access to the width of the grid.
property height: int
Convenience access to the height of the grid.
select_random_empty_cell() → T
Select random empty cell.
class OrthogonalMooreGrid(dimensions: ~collections.abc.Sequence[int], torus: bool = False, capacity: float |
None = None, random: ~random.Random | None = None, cell_klass:
type[~mesa.discrete_space.grid.T] = <class 'mesa.discrete_space.cell.Cell'>)
Grid where cells are connected to their 8 neighbors.
Example for two dimensions: directions = [
2.4. Citing Mesa

195

Mesa Documentation, Release .1

(-1, -1), (-1, 0), (-1, 1), ( 0, -1), ( 0, 1), ( 1, -1), ( 1, 0), ( 1, 1),
]
Initialise the grid class.
Parameters
• dimensions – the dimensions of the space
• torus – whether the space wraps
• capacity – capacity of the grid cell
• random – a random number generator
• cell_klass – the base class to use for the cells
class OrthogonalVonNeumannGrid(dimensions: ~collections.abc.Sequence[int], torus: bool = False, capacity:
float | None = None, random: ~random.Random | None = None, cell_klass:
type[~mesa.discrete_space.grid.T] = <class
'mesa.discrete_space.cell.Cell'>)
Grid where cells are connected to their 4 neighbors.
Example for two dimensions: directions = [
(0, -1),
(-1, 0), ( 1, 0),
(0, 1),
]
Initialise the grid class.
Parameters
• dimensions – the dimensions of the space
• torus – whether the space wraps
• capacity – capacity of the grid cell
• random – a random number generator
• cell_klass – the base class to use for the cells
class HexGrid(dimensions: ~collections.abc.Sequence[int], torus: bool = False, capacity: float | None = None,
random: ~random.Random | None = None, cell_klass: type[~mesa.discrete_space.grid.T] =
<class 'mesa.discrete_space.cell.Cell'>)
A Grid with hexagonal tilling of the space.
Initialise the grid class.
Parameters
• dimensions – the dimensions of the space
• torus – whether the space wraps
• capacity – capacity of the grid cell
• random – a random number generator
• cell_klass – the base class to use for the cells

196

Chapter 2. Using Mesa

Mesa Documentation, Release .1

Network-based cell space using arbitrary connection patterns.
Creates spaces where cells connect based on network relationships rather than spatial proximity. Built on NetworkX
graphs, this enables: - Arbitrary connectivity patterns between cells - Graph-based neighborhood definitions - Logical
rather than physical distances - Dynamic connectivity changes - Integration with NetworkX’s graph algorithms
Useful for modeling systems like social networks, transportation systems, or any environment where connectivity matters more than physical location.
class Network(G: ~typing.Any, capacity: int | None = None, random: ~random.Random | None = None,
cell_klass: type[~mesa.discrete_space.cell.Cell] = <class 'mesa.discrete_space.cell.Cell'>)
A networked discrete space.
A Networked grid.
Parameters
• G – a NetworkX Graph instance.
• capacity (int) – the capacity of the cell
• random (Random) – a random number generator
• cell_klass (type[Cell]) – The base Cell class to use in the Network
add_cell(cell: Cell)
Add a cell to the space.
remove_cell(cell: Cell)
Remove a cell from the space.
add_connection(cell1: Cell, cell2: Cell)
Add a connection between the two cells.
remove_connection(cell1: Cell, cell2: Cell)
Remove a connection between the two cells.
Cell spaces based on Voronoi tessellation around seed points.
Creates irregular spatial divisions by building cells around seed points, where each cell contains the area closer to
its seed than any other. Features: - Organic-looking spaces from point sets - Automatic neighbor determination Area-based cell capacities - Natural regional divisions
Useful for models requiring irregular but mathematically meaningful spatial divisions, like territories, service areas,
or natural regions.
class Delaunay(center: tuple = (0, 0), radius: int = 9999)
Class to compute a Delaunay triangulation in 2D.
ref: http://github.com/jmespadero/pyDelaunay2D
Init and create a new frame to contain the triangulation.
Parameters
• center – Optional position for the center of the frame. Default (0,0)
• radius – Optional distance from corners to the center.
add_point(point: Sequence) → None
Add a point to the current DT, and refine it using Bowyer-Watson.

2.4. Citing Mesa

197

Mesa Documentation, Release .1

export_triangles() → list
Export the current list of Delaunay triangles.
export_voronoi_regions()
Export coordinates and regions of Voronoi diagram as indexed data.
class VoronoiGrid(centroids_coordinates: ~collections.abc.Sequence[~collections.abc.Sequence[float]],
capacity: float | None = None, random: ~random.Random | None = None, cell_klass:
type[~mesa.discrete_space.cell.Cell] = <class 'mesa.discrete_space.cell.Cell'>,
capacity_function: callable = <function round_float>)
Voronoi meshed GridSpace.
A Voronoi Tessellation Grid.
Given a set of points, this class creates a grid where a cell is centered in each point, its neighbors are given by
Voronoi Tessellation cells neighbors and the capacity by the polygon area.
Parameters
• centroids_coordinates – coordinates of centroids to build the tessellation space
• capacity (int) – capacity of the cells in the discrete space
• random (Random) – random number generator
• cell_klass (type[Cell]) – type of cell class
• capacity_function (Callable) – function to compute (int) capacity according to (float)
area
2.4.4.5 Data collection
Mesa Data Collection Module.
DataCollector is meant to provide a simple, standard way to collect data generated by a Mesa model. It collects four
types of data: model-level data, agent-level data, agent-type-level data, and tables.
A DataCollector is instantiated with three dictionaries of reporter names and associated variable names or functions for
each, one for model-level data, one for agent-level data, and one for agent-type-level data; a fourth dictionary provides
table names and columns. Variable names are converted into functions which retrieve attributes of that name.
When the collect() method is called, each model-level function is called, with the model as the argument, and the results
associated with the relevant variable. Then the agent-level functions are called on each agent, and the agent-type-level
functions are called on each agent of the specified type.
Additionally, other objects can write directly to tables by passing in an appropriate dictionary object for a table row.
The DataCollector then stores the data it collects in dictionaries:
• model_vars maps each reporter to a list of its values
• tables maps each table to a dictionary, with each column as a key with a list as its value.
• _agent_records maps each model step to a list of each agent’s id and its values.
• _agenttype_records maps each model step to a dictionary of agent types, each containing a list of each
agent’s id and its values.
Finally, DataCollector can create a pandas DataFrame from each collection.

198

Chapter 2. Using Mesa

Mesa Documentation, Release .1

class DataCollector(model_reporters=None, agent_reporters=None, agenttype_reporters=None, tables=None)
Class for collecting data generated by a Mesa model.
A DataCollector is instantiated with dictionaries of names of model-, agent-, and agent-type-level variables to
collect, associated with attribute names or functions which actually collect them. When the collect(. . . ) method
is called, it collects these attributes and executes these functions one by one and stores the results.
Instantiate a DataCollector with lists of model, agent, and agent-type reporters.
Both model_reporters, agent_reporters, and agenttype_reporters accept a dictionary mapping a variable name to
either an attribute name, a function, a method of a class/instance, or a function with parameters placed in a list.
Model reporters can take four types of arguments: 1. Lambda function:
{“agent_count”: lambda m: len(m.agents)}
2. Method of a class/instance: {“agent_count”: self.get_agent_count} # self here is a class instance
{“agent_count”: Model.get_agent_count} # Model here is a class
3. Class attributes of a model: {“model_attribute”: “model_attribute”}
4. Functions with parameters that have been placed in a list: {“Model_Function”: [function, [param_1,
param_2]]}
Agent reporters can similarly take: 1. Attribute name (string) referring to agent’s attribute:
{“energy”: “energy”}
2. Lambda function: {“energy”: lambda a: a.energy}
3. Method of an agent class/instance: {“agent_action”: self.do_action} # self here is an agent class instance
{“agent_action”: Agent.do_action} # Agent here is a class
4. Functions with parameters placed in a list: {“Agent_Function”: [function, [param_1, param_2]]}
Agenttype reporters take a dictionary mapping agent types to dictionaries of reporter names and attributes/funcs/methods, similar to agent_reporters:
{Wolf: {“energy”: lambda a: a.energy}}
The tables arg accepts a dictionary mapping names of tables to lists of columns. For example, if we want to allow
agents to write their age when they are destroyed (to keep track of lifespans), it might look like:
{“Lifespan”: [“unique_id”, “age”]}
Parameters
• model_reporters – Dictionary of reporter names and attributes/funcs/methods.
• agent_reporters – Dictionary of reporter names and attributes/funcs/methods.
• agenttype_reporters – Dictionary of agent types to dictionaries of reporter names and
attributes/funcs/methods.
• tables – Dictionary of table names to lists of column names.
Notes
• If you want to pickle your model you must not use lambda functions.
• If your model includes a large number of agents, it is recommended to use attribute names for the agent
reporter, as it will be faster.

2.4. Citing Mesa

199

Mesa Documentation, Release .1

collect(model)
Collect all the data for the given model object.
add_table_row(table_name, row, ignore_missing=False)
Add a row dictionary to a specific table.
Parameters
• table_name – Name of the table to append a row to.
• row – A dictionary of the form {column_name: value. . . }
• ignore_missing – If True, fill any missing columns with Nones; if False, throw an error
if any columns are missing
get_model_vars_dataframe()
Create a pandas DataFrame from the model variables.
The DataFrame has one column for each model variable, and the index is (implicitly) the model tick.
get_agent_vars_dataframe()
Create a pandas DataFrame from the agent variables.
The DataFrame has one column for each variable, with two additional columns for tick and agent_id.
get_agenttype_vars_dataframe(agent_type)
Create a pandas DataFrame from the agent-type variables for a specific agent type.
The DataFrame has one column for each variable, with two additional columns for tick and agent_id.
Parameters
agent_type – The type of agent to get the data for.
get_table_dataframe(table_name)
Create a pandas DataFrame from a particular table.
Parameters
table_name – The name of the table to convert.
2.4.4.6 Batchrunner
batchrunner for running a factorial experiment design over a model.
To take advantage of parallel execution of experiments, batch_run uses multiprocessing if number_processes is
larger than 1. It is strongly advised to only run in parallel using a normal python file (so don’t try to do it in a jupyter
notebook). This is because Jupyter notebooks have a different execution model that can cause issues with Python’s
multiprocessing module, especially on Windows. The main problems include the lack of a traditional __main__ entry
point, serialization issues, and potential deadlocks.
Moreover, best practice when using multiprocessing is to put the code inside an if __name__ == '__main__':
code black as shown below:
from mesa.batchrunner import batch_run
params = {"width": 10, "height": 10, "N": range(10, 500, 10)}
if __name__ == '__main__':
results = batch_run(
MoneyModel,
parameters=params,
(continues on next page)

200

Chapter 2. Using Mesa

Mesa Documentation, Release .1

(continued from previous page)

iterations=5,
max_steps=100,
number_processes=None,
data_collection_period=1,
display_progress=True,
)
batch_run(model_cls: type[Model], parameters: Mapping[str, Any | Iterable[Any]], number_processes: int | None
= 1, iterations: int = 1, data_collection_period: int = -1, max_steps: int = 1000, display_progress:
bool = True) → list[dict[str, Any]]
Batch run a mesa model with a set of parameter values.
Parameters
• model_cls (Type[Model]) – The model class to batch-run
• parameters (Mapping[str, Union[Any, Iterable[Any]]]) – Dictionary with
model parameters over which to run the model. You can either pass single values or
iterables.
• number_processes (int, optional) – Number of processes used, by default 1. Set this
to None if you want to use all CPUs.
• iterations (int, optional) – Number of iterations for each parameter combination, by
default 1
• data_collection_period (int, optional) – Number of steps after which data gets
collected, by default -1 (end of episode)
• max_steps (int, optional) – Maximum number of model steps after which the model
halts, by default 1000
• display_progress (bool, optional) – Display batch run process, by default True
Returns
List[Dict[str, Any]]
Notes
batch_run assumes the model has a datacollector attribute that has a DataCollector object initialized.
2.4.4.7 Visualization
For a detailed tutorial, please refer to our Visualization Tutorial.
2.4.4.7.1 Jupyter Visualization
Mesa visualization module for creating interactive model visualizations.
This module provides components to create browser- and Jupyter notebook-based visualizations of Mesa models, allowing users to watch models run step-by-step and interact with model parameters.
Key features:
• SolaraViz: Main component for creating visualizations, supporting grid displays and plots
• ModelController: Handles model execution controls (step, play, pause, reset)
• UserInputs: Generates UI elements for adjusting model parameters

2.4. Citing Mesa

201

Mesa Documentation, Release .1

The module uses Solara for rendering in Jupyter notebooks or as standalone web applications. It supports various types
of visualizations including matplotlib plots, agent grids, and custom visualization components.
Usage:
1. Define an agent_portrayal function to specify how agents should be displayed
2. Set up model_params to define adjustable parameters
3. Create a SolaraViz instance with your model, parameters, and desired measures
4. Display the visualization in a Jupyter notebook or run as a Solara app
See the Visualization Tutorial and example models for more details.
split_model_params(model_params)
Split model parameters into user-adjustable and fixed parameters.
Parameters
model_params – Dictionary of all model parameters
Returns
(user_adjustable_params, fixed_params)
Return type
tuple
check_param_is_fixed(param)
Check if a parameter is fixed (not user-adjustable).
Parameters
param – Parameter to check
Returns
True if parameter is fixed, False otherwise
Return type
bool
make_initial_grid_layout(num_components)
Create an initial grid layout for visualization components.
Parameters
num_components – Number of components to display
Returns
Initial grid layout configuration
Return type
list
custom solara components.
make_space_component(agent_portrayal: Callable | None = None, propertylayer_portrayal: dict | None = None,
post_process: Callable | None = None, backend: str = 'matplotlib',
**space_drawing_kwargs) → SpaceMatplotlib | SpaceAltair
Create a Matplotlib-based space visualization component.
Parameters
• agent_portrayal – Function to portray agents.
• propertylayer_portrayal – Dictionary of PropertyLayer portrayal specifications

202

Chapter 2. Using Mesa

Mesa Documentation, Release .1

• post_process – a callable that will be called with the Axes instance. Allows for fine-tuning
plots (e.g., control ticks)
• backend – the backend to use {“matplotlib”, “altair”}
• space_drawing_kwargs – additional keyword arguments to be passed on to the underlying
backend specific space drawer function. See the functions for drawing the various spaces for
the appropriate backend further details.
Returns
A function that creates a space component
Return type
function
make_plot_component(measure: str | dict[str, str] | list[str] | tuple[str], post_process: Callable | None = None,
backend: str = 'matplotlib', **plot_drawing_kwargs)
Create a plotting function for a specified measure using the specified backend.
Parameters
• measure (str | dict[str, str] | list[str] | tuple[str]) – Measure(s) to
plot.
• post_process – a user-specified callable to do post-processing called with the Axes instance.
• backend – the backend to use {“matplotlib”, “altair”}
• plot_drawing_kwargs – additional keyword arguments to pass onto the backend specific
function for making a plotting component
Notes
altair plotting backend is not yet implemented and planned for mesa 3.1.
Returns
A function that creates a plot component
Return type
function
2.4.4.7.2 User Parameters
Solara visualization related helper classes.
class UserParam
Bases: object
UserParam.
maybe_raise_error(param_type, valid)
class Slider(label='', value=None, min=None, max=None, step=1, dtype=None)
Bases: UserParam
A number-based slider input with settable increment.
Example: slider_option = Slider(“My Slider”, value=123, min=10, max=200, step=0.1)
Parameters
• label – The displayed label in the UI

2.4. Citing Mesa

203

Mesa Documentation, Release .1

• value – The initial value of the slider
• min – The minimum possible value of the slider
• max – The maximum possible value of the slider
• step – The step between min and max for a range of possible values
• dtype – either int or float
Initializes a slider.
Parameters
• label – The displayed label in the UI
• value – The initial value of the slider
• min – The minimum possible value of the slider
• max – The maximum possible value of the slider
• step – The step between min and max for a range of possible values
• dtype – either int or float
get(attr)
2.4.4.7.3 Matplotlib-based visualizations
Matplotlib based solara components for visualization MESA spaces and plots.
make_space_matplotlib(*args, **kwargs)
make_mpl_space_component(agent_portrayal: Callable | None = None, propertylayer_portrayal: dict | None =
None, post_process: Callable | None = None, **space_drawing_kwargs) →
SpaceMatplotlib
Create a Matplotlib-based space visualization component.
Parameters
• agent_portrayal – Function to portray agents.
• propertylayer_portrayal – Dictionary of PropertyLayer portrayal specifications
• post_process – a callable that will be called with the Axes instance. Allows for fine tuning
plots (e.g., control ticks)
• space_drawing_kwargs – additional keyword arguments to be passed on to the underlying
space drawer function. See the functions for drawing the various spaces for further details.
agent_portrayal is called with an agent and should return a dict. Valid fields in this dict are “color”, “size”,
“marker”, “zorder”, alpha, linewidths, and edgecolors. Other field are ignored and will result in a user warning.
Returns
A function that creates a SpaceMatplotlib component
Return type
function
make_plot_measure(*args, **kwargs)

204

Chapter 2. Using Mesa

Mesa Documentation, Release .1

make_mpl_plot_component(measure: str | dict[str, str] | list[str] | tuple[str], post_process: Callable | None =
None, save_format='png')
Create a plotting function for a specified measure.
Parameters
• measure (str | dict[str, str] | list[str] | tuple[str]) – Measure(s) to
plot.
• post_process – a user-specified callable to do post-processing called with the Axes instance.
• save_format – save format of figure in solara backend
Returns
A function that creates a PlotMatplotlib component.
Return type
function
Helper functions for drawing mesa spaces with matplotlib.
These functions are used by the provided matplotlib components, but can also be used to quickly visualize a space with
matplotlib for example when creating a mp4 of a movie run or when needing a figure for a paper.
collect_agent_data(space: SingleGrid | MultiGrid | OrthogonalMooreGrid | OrthogonalVonNeumannGrid |
HexSingleGrid | HexMultiGrid | HexGrid | NetworkGrid | Network | ContinuousSpace |
VoronoiGrid, agent_portrayal: Callable, color='tab:blue', size=25, marker='o', zorder: int
= 1)
Collect the plotting data for all agents in the space.
Parameters
• space – The space containing the Agents.
• agent_portrayal – A callable that is called with the agent and returns a dict
• color – default color
• size – default size
• marker – default marker
• zorder – default zorder
agent_portrayal should return a dict, limited to size (size of marker), color (color of marker), zorder (z-order),
marker (marker style), alpha, linewidths, and edgecolors
draw_space(space, agent_portrayal: Callable, propertylayer_portrayal: dict | None = None, ax: Axes | None =
None, **space_drawing_kwargs)
Draw a Matplotlib-based visualization of the space.
Parameters
• space – the space of the mesa model
• agent_portrayal – A callable that returns a dict specifying how to show the agent
• propertylayer_portrayal – a dict specifying how to show propertylayer(s)
• ax – the axes upon which to draw the plot
• space_drawing_kwargs – any additional keyword arguments to be passed on to the underlying function for drawing the space.

2.4. Citing Mesa

205

Mesa Documentation, Release .1

Returns
Returns the Axes object with the plot drawn onto it.
agent_portrayal is called with an agent and should return a dict. Valid fields in this dict are “color”, “size”,
“marker”, “zorder”, alpha, linewidths, and edgecolors. Other field are ignored and will result in a user warning.
draw_property_layers(space, propertylayer_portrayal: dict[str, dict[str, Any]], ax: Axes)
Draw PropertyLayers on the given axes.
Parameters
• space (mesa.space._Grid) – The space containing the PropertyLayers.
• propertylayer_portrayal (dict) – the key is the name of the layer, the value is a dict
with fields specifying how the layer is to be portrayed
• ax (matplotlib.axes.Axes) – The axes to draw on.
Notes
valid fields in in the inner dict of propertylayer_portrayal are “alpha”, “vmin”, “vmax”, “color” or “colormap”,
and “colorbar” so you can do {“some_layer”:{“colormap”:’viridis’, ‘alpha’:.25, “colorbar”:False}}
draw_orthogonal_grid(space: SingleGrid | MultiGrid | OrthogonalMooreGrid | OrthogonalVonNeumannGrid,
agent_portrayal: Callable, ax: Axes | None = None, draw_grid: bool = True, **kwargs)
Visualize a orthogonal grid.
Parameters
• space – the space to visualize
• agent_portrayal – a callable that is called with the agent and returns a dict
• ax – a Matplotlib Axes instance. If none is provided a new figure and ax will be created
using plt.subplots
• draw_grid – whether to draw the grid
• kwargs – additional keyword arguments passed to ax.scatter
Returns
Returns the Axes object with the plot drawn onto it.
agent_portrayal is called with an agent and should return a dict. Valid fields in this dict are “color”, “size”,
“marker”, and “zorder”. Other field are ignored and will result in a user warning.
draw_hex_grid(space: HexSingleGrid | HexMultiGrid | HexGrid, agent_portrayal: Callable, ax: Axes | None =
None, draw_grid: bool = True, **kwargs)
Visualize a hex grid.
Parameters
• space – the space to visualize
• agent_portrayal – a callable that is called with the agent and returns a dict
• ax – a Matplotlib Axes instance. If none is provided a new figure and ax will be created
using plt.subplots
• draw_grid – whether to draw the grid
• kwargs – additional keyword arguments passed to ax.scatter

206

Chapter 2. Using Mesa

Mesa Documentation, Release .1

draw_network(space: ~mesa.space.NetworkGrid | ~mesa.discrete_space.network.Network, agent_portrayal:
~collections.abc.Callable, ax: ~matplotlib.axes._axes.Axes | None = None, draw_grid: bool = True,
layout_alg=<function spring_layout>, layout_kwargs=None, **kwargs)
Visualize a network space.
Parameters
• space – the space to visualize
• agent_portrayal – a callable that is called with the agent and returns a dict
• ax – a Matplotlib Axes instance. If none is provided a new figure and ax will be created
using plt.subplots
• draw_grid – whether to draw the grid
• layout_alg – a networkx layout algorithm or other callable with the same behavior
• layout_kwargs – a dictionary of keyword arguments for the layout algorithm
• kwargs – additional keyword arguments passed to ax.scatter
Returns
Returns the Axes object with the plot drawn onto it.
agent_portrayal is called with an agent and should return a dict. Valid fields in this dict are “color”, “size”,
“marker”, and “zorder”. Other field are ignored and will result in a user warning.
draw_continuous_space(space: ContinuousSpace, agent_portrayal: Callable, ax: Axes | None = None,
**kwargs)
Visualize a continuous space.
Parameters
• space – the space to visualize
• agent_portrayal – a callable that is called with the agent and returns a dict
• ax – a Matplotlib Axes instance. If none is provided a new figure and ax will be created
using plt.subplots
• kwargs – additional keyword arguments passed to ax.scatter
Returns
Returns the Axes object with the plot drawn onto it.
agent_portrayal is called with an agent and should return a dict. Valid fields in this dict are “color”, “size”,
“marker”, and “zorder”. Other field are ignored and will result in a user warning.
draw_voronoi_grid(space: VoronoiGrid, agent_portrayal: Callable, ax: Axes | None = None, draw_grid: bool =
True, **kwargs)
Visualize a voronoi grid.
Parameters
• space – the space to visualize
• agent_portrayal – a callable that is called with the agent and returns a dict
• ax – a Matplotlib Axes instance. If none is provided a new figure and ax will be created
using plt.subplots
• draw_grid – whether to draw the grid or not
• kwargs – additional keyword arguments passed to ax.scatter

2.4. Citing Mesa

207

Mesa Documentation, Release .1

Returns
Returns the Axes object with the plot drawn onto it.
agent_portrayal is called with an agent and should return a dict. Valid fields in this dict are “color”, “size”,
“marker”, and “zorder”. Other field are ignored and will result in a user warning.
2.4.4.7.4 Altair-based visualizations
Altair based solara components for visualization mesa spaces.
make_space_altair(*args, **kwargs)
make_altair_space(agent_portrayal, propertylayer_portrayal=None, post_process=None,
**space_drawing_kwargs)
Create an Altair-based space visualization component.
Parameters
• agent_portrayal – Function to portray agents.
• propertylayer_portrayal – Dictionary of PropertyLayer portrayal specifications
• post_process – A user specified callable that will be called with the Chart instance from
Altair. Allows for fine tuning plots (e.g., control ticks)
• space_drawing_kwargs – not yet implemented
agent_portrayal is called with an agent and should return a dict. Valid fields in this dict are “color”, “size”,
“marker”, and “zorder”. Other field are ignored and will result in a user warning.
Returns
A function that creates a SpaceMatplotlib component
Return type
function
chart_property_layers(space, propertylayer_portrayal, chart_width, chart_height)
Creates Property Layers in the Altair Components.
Parameters
• space – the ContinuousSpace instance
• propertylayer_portrayal – Dictionary of PropertyLayer portrayal specifications
• chart_width – width of the agent chart to maintain consistency with the property charts
• chart_height – height of the agent chart to maintain consistency with the property charts
• agent_chart – the agent chart to layer with the property layers on the grid
Returns
Altair Chart
2.4.4.7.5 Command Console
A command console interface for interactive Python code execution in the browser.
This module provides a set of classes and functions to create an interactive Python console that can be embedded in a
web browser. It supports command history, multi-line code blocks, and special commands for console management.

208

Chapter 2. Using Mesa

Mesa Documentation, Release .1

Notes
• The console supports multi-line code blocks with proper indentation
• Output is captured and displayed with appropriate formatting
• Error messages are displayed in red with distinct styling
• The console maintains a history of commands and their outputs
class ConsoleEntry(command: str, output: str = '', is_error: bool = False, is_continuation: bool = False)
Bases: object
A class to store command console entries.
command
The command entered
Type
str
output
The output of the command
Type
str
is_error
Whether the entry represents an error
Type
bool
is_continuation
Whether the entry is a continuation of previous command
Type
bool
command:

str

output:

str = ''

is_error:

bool = False

is_continuation:

bool = False

class CaptureOutput
Bases: object
A context manager for capturing stdout and stderr output.
This class provides a way to capture output that would normally be printed to stdout and stderr during the execution of code within its context.
Initialize the CaptureOutput context manager with empty string buffers.
get_output()
Retrieve and clear the captured output.
Returns
A pair of strings (stdout_output, stderr_output)

2.4. Citing Mesa

209

Mesa Documentation, Release .1

Return type
tuple
class InteractiveConsole(locals_dict=None)
Bases: InteractiveConsole
A custom interactive Python console with output capturing capabilities.
This class extends code.InteractiveConsole to provide output capturing functionality when executing Python code
interactively.
Parameters
locals_dict (dict, optional) – Dictionary of local variables. Defaults to None.
Initialize the InteractiveConsole with the provided locals dictionary.
push(line)
Push a line to the command interpreter and execute it.
This method captures the output of the executed command and returns both the ‘more’ flag and the captured
output.
Parameters
line (str) – The line of code to be executed.
Returns
A tuple containing:
• more (bool): Flag indicating if more input is needed
• str: The captured output from executing the command
Return type
tuple
class ConsoleManager(model=None, additional_imports=None)
Bases: object
A console manager for executing Python code interactively.
This class provides functionality to execute Python code in an interactive console environment, maintain command history, and handle multi-line code blocks.
locals_dict
Dictionary containing local variables available to the console
Type
dict
console
Python’s interactive console instance
Type
InteractiveConsole
buffer
Buffer for storing multi-line code blocks
Type
list

210

Chapter 2. Using Mesa

Mesa Documentation, Release .1

history
List of console entries containing commands and their outputs
Type
list[ConsoleEntry]
Special Commands:
1. history : Shows the command history
2. cls : Clears the console screen
3. tips : Shows available console commands and usage tips
Example
>>> console = ConsoleManager(model=my_model)
>>> console.execute_code("print('hello world')", set_input_callback)
Initialize the console manager with the provided model and imports.
execute_code(code_line: str, set_input_text: Callable[[str], None]) → None
Execute the provided code line and update the console history.
clear_console() → None
Clear the console history and reset the console state.
get_entries() → list[ConsoleEntry]
Get the list of console entries.
prev_command(current_text: str, set_input_text: Callable[[str], None]) → None
Navigate to previous command in history.
next_command(set_input_text: Callable[[str], None]) → None
Navigate to next command in history.
format_command_html(entry)
Format the command part of a console entry as HTML.
format_output_html(entry)
Format the output part of a console entry as HTML.
2.4.4.8 Experimental
This namespace contains experimental features. These are under development, and their API is not necessarily stable.
2.4.4.8.1 Devs
Core event management functionality for Mesa’s discrete event simulation system.
This module provides the foundational data structures and classes needed for event-based simulation in Mesa. The
EventList class is a priority queue implementation that maintains simulation events in chronological order while respecting event priorities. Key features:
• Priority-based event ordering
• Weak references to prevent memory leaks from canceled events
• Efficient event insertion and removal using a heap queue

2.4. Citing Mesa

211

Mesa Documentation, Release .1

• Support for event cancellation without breaking the heap structure
The module contains three main components: - Priority: An enumeration defining event priority levels (HIGH, DEFAULT, LOW) - SimulationEvent: A class representing individual events with timing and execution details - EventList:
A heap-based priority queue managing the chronological ordering of events
The implementation supports both pure discrete event simulation and hybrid approaches combining agent-based modeling with event scheduling.
class Priority(*values)
Enumeration of priority levels.
class SimulationEvent(time: int | float, function: Callable, priority: Priority = Priority.DEFAULT ,
function_args: list[Any] | None = None, function_kwargs: dict[str, Any] | None = None)
A simulation event.
The callable is wrapped using weakref, so there is no need to explicitly cancel event if e.g., an agent is removed
from the simulation.
time
The simulation time of the event
Type
float
fn
The function to execute for this event
Type
Callable
priority
The priority of the event
Type
Priority
unique_id
Type
int
function_args
Argument for the function
Type
list[Any]
function_kwargs
Keyword arguments for the function
Type
Dict[str, Any]
Notes
simulation events use a weak reference to the callable. Therefore, you cannot pass a lambda function in fn. A
simulation event where the callable no longer exists (e.g., because the agent has been removed from the model)
will fail silently.
Initialize a simulation event.

212

Chapter 2. Using Mesa

Mesa Documentation, Release .1

Parameters
• time – the instant of time of the simulation event
• function – the callable to invoke
• priority – the priority of the event
• function_args – arguments for callable
• function_kwargs – keyword arguments for the callable
execute()
Execute this event.
cancel() → None
Cancel this event.
class EventList
An event list.
This is a heap queue sorted list of events. Events are always removed from the left, so heapq is a performant and
appropriate data structure. Events are sorted based on their time stamp, their priority, and their unique_id as a
tie-breaker, guaranteeing a complete ordering.
Initialize an event list.
add_event(event: SimulationEvent)
Add the event to the event list.
Parameters
event (SimulationEvent) – The event to be added
peak_ahead(n: int = 1) → list[SimulationEvent]
Look at the first n non-canceled event in the event list.
Parameters
n (int) – The number of events to look ahead
Returns
list[SimulationEvent]
Raises
IndexError – If the eventlist is empty
Notes
this method can return a list shorted then n if the number of non-canceled events on the event list is less
than n.
pop_event() → SimulationEvent
Pop the first element from the event list.
is_empty() → bool
Return whether the event list is empty.
remove(event: SimulationEvent) → None
Remove an event from the event list.
Parameters
event (SimulationEvent) – The event to be removed

2.4. Citing Mesa

213

Mesa Documentation, Release .1

clear()
Clear the event list.
Simulator implementations for different time advancement approaches in Mesa.
This module provides simulator classes that control how simulation time advances and how events are executed. It
supports both discrete-time and continuous-time simulations through three main classes:
• Simulator: Base class defining the core simulation control interface
• ABMSimulator: A simulator for agent-based models that combines fixed time steps with event scheduling. Uses
integer time units and automatically schedules model.step()
• DEVSimulator: A pure discrete event simulator using floating-point time units for continuous time simulation
Key features: - Flexible time units (integer or float) - Event scheduling using absolute or relative times - Priority-based
event execution - Support for running simulations for specific durations or until specific end times
The simulators enable Mesa models to use traditional time-step based approaches, pure event-driven approaches, or
hybrid combinations of both.
class Simulator(time_unit: type, start_time: int | float)
The Simulator controls the time advancement of the model.
The simulator uses next event time progression to advance the simulation time, and execute the next event
event_list
The list of events to execute
Type
EventList
time
The current simulation time
Type
float | int
time_unit
The unit of the simulation time
Type
type
model
The model to simulate
Type
Model
Initialize a Simulator instance.
Parameters
• time_unit – type of the smulaiton time
• start_time – the starttime of the simulator
setup(model: Model) → None
Set up the simulator with the model to simulate.
Parameters
model (Model) – The model to simulate

214

Chapter 2. Using Mesa

Mesa Documentation, Release .1

Raises
• Exception if simulator.time is not equal to simulator.starttime –
• Exception if event list is not empty –
reset()
Reset the simulator by clearing the event list and removing the model to simulate.
run_until(end_time: int | float) → None
Run the simulator until the end time.
Parameters
end_time (int | float) – The end time for stopping the simulator
Raises
Exception if simulator.setup() has not yet been called –
run_next_event()
Execute the next event.
Raises
Exception if simulator.setup() has not yet been called –
run_for(time_delta: int | float)
Run the simulator for the specified time delta.
Parameters
time_delta (float| int) – The time delta. The simulator is run from the current time to
the current time plus the time delta
schedule_event_now(function: Callable, priority: Priority = Priority.DEFAULT , function_args: list[Any] |
None = None, function_kwargs: dict[str, Any] | None = None) → SimulationEvent
Schedule event for the current time instant.
Parameters
• function (Callable) – The callable to execute for this event
• priority (Priority) – the priority of the event, optional
• function_args (List[Any]) – list of arguments for function
• function_kwargs (Dict[str, Any]) – dict of keyword arguments for function
Returns
the simulation event that is scheduled
Return type
SimulationEvent
schedule_event_absolute(function: Callable, time: int | float, priority: Priority = Priority.DEFAULT ,
function_args: list[Any] | None = None, function_kwargs: dict[str, Any] | None
= None) → SimulationEvent
Schedule event for the specified time instant.
Parameters
• function (Callable) – The callable to execute for this event
• time (int | float) – the time for which to schedule the event
• priority (Priority) – the priority of the event, optional

2.4. Citing Mesa

215

Mesa Documentation, Release .1

• function_args (List[Any]) – list of arguments for function
• function_kwargs (Dict[str, Any]) – dict of keyword arguments for function
Returns
the simulation event that is scheduled
Return type
SimulationEvent
schedule_event_relative(function: Callable, time_delta: int | float, priority: Priority =
Priority.DEFAULT , function_args: list[Any] | None = None, function_kwargs:
dict[str, Any] | None = None) → SimulationEvent
Schedule event for the current time plus the time delta.
Parameters
• function (Callable) – The callable to execute for this event
• time_delta (int | float) – the time delta
• priority (Priority) – the priority of the event, optional
• function_args (List[Any]) – list of arguments for function
• function_kwargs (Dict[str, Any]) – dict of keyword arguments for function
Returns
the simulation event that is scheduled
Return type
SimulationEvent
cancel_event(event: SimulationEvent) → None
Remove the event from the event list.
Parameters
event (SimulationEvent) – The simulation event to remove
class ABMSimulator
This simulator uses incremental time progression, while allowing for additional event scheduling.
The basic time unit of this simulator is an integer. It schedules model.step for each tick with the highest priority.
This implies that by default, model.step is the first event executed at a specific tick. In addition, discrete event
scheduling, using integer as the time unit is fully supported, paving the way for hybrid ABM-DEVS simulations.
Initialize a ABM simulator.
setup(model)
Set up the simulator with the model to simulate.
Parameters
model (Model) – The model to simulate
check_time_unit(time) → bool
Check whether the time is of the correct unit.
Parameters
time (int | float) – the time
Returns
whether the time is of the correct unit

216

Chapter 2. Using Mesa

Mesa Documentation, Release .1

Return type
bool
schedule_event_next_tick(function: Callable, priority: Priority = Priority.DEFAULT , function_args:
list[Any] | None = None, function_kwargs: dict[str, Any] | None = None) →
SimulationEvent
Schedule a SimulationEvent for the next tick.
Parameters
• function (Callable) – the callable to execute
• priority (Priority) – the priority of the event
• function_args (List[Any]) – List of arguments to pass to the callable
• function_kwargs (Dict[str, Any]) – List of keyword arguments to pass to the
callable
run_until(end_time: int) → None
Run the simulator up to and included the specified end time.
Parameters
end_time (float| int) – The end_time delta. The simulator is until the specified end time
Raises
Exception if simulator.setup() has not yet been called –
class DEVSimulator
A simulator where the unit of time is a float.
Can be used for full-blown discrete event simulating using event scheduling.
Initialize a DEVS simulator.
check_time_unit(time) → bool
Check whether the time is of the correct unit.
Parameters
time (float) – the time
Returns: bool: whether the time is of the correct unit
2.4.4.8.2 Continuous Space
A Continuous Space class.
class ContinuousSpace(dimensions: Buffer | _SupportsArray[dtype[Any]] |
_NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes |
_NestedSequence[bool | int | float | complex | str | bytes], torus: bool = False, random:
Random | None = None, n_agents: int = 100)
Continuous space where each agent can have an arbitrary position.
Create a new continuous space.
Parameters
• dimensions – a numpy array like object where each row specifies the minimum and maximum value of that dimension.
• torus – boolean for whether the space wraps around or not
• random – a seeded stdlib random.Random instance
2.4. Citing Mesa

217

Mesa Documentation, Release .1

• n_agents – the expected number of agents in the space
Internally, a numpy array is used to store the positions of all agents. This is resized if needed, but you can control
the initial size explicitly by passing n_agents.
property agents: AgentSet
Return an AgentSet with the agents in the space.
calculate_difference_vector(point: ndarray, agents=None) → ndarray
Calculate the difference vector between the point and all agenents.
Parameters
• point – the point to calculate the difference vector for
• agents – the agents to calculate the difference vector of point with. By default, all agents
are considered.
calculate_distances(point: Buffer | _SupportsArray[dtype[Any]] |
_NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str |
bytes | _NestedSequence[bool | int | float | complex | str | bytes], agents:
Iterable[Agent] | None = None, **kwargs) → tuple[ndarray, list]
Calculate the distance between the point and all agents.
Parameters
• point – the point to calculate the difference vector for
• agents – the agents to calculate the difference vector of point with. By default, all agents
are considered.
• kwargs – any additional keyword arguments are passed to scipy’s cdist, which is used only
if torus is False. This allows for non-Euclidian distance measures.
get_agents_in_radius(point: Buffer | _SupportsArray[dtype[Any]] |
_NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str |
bytes | _NestedSequence[bool | int | float | complex | str | bytes], radius: float | int
= 1) → tuple[list, ndarray]
Return the agents and their distances within a radius for the point.
get_k_nearest_agents(point: Buffer | _SupportsArray[dtype[Any]] |
_NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str |
bytes | _NestedSequence[bool | int | float | complex | str | bytes], k: int = 1) →
tuple[list, ndarray]
Return the k nearest agents and their distances to the point.
Notes
This method returns exactly k agents, ignoring ties. In case of ties, the earlier an agent is inserted the higher
it will rank.
in_bounds(point: Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] |
bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes])
→ bool
Check if point is inside the bounds of the space.
torus_correct(point: Buffer | _SupportsArray[dtype[Any]] |
_NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes |
_NestedSequence[bool | int | float | complex | str | bytes]) → ndarray
Apply a torus correction to the point.
218

Chapter 2. Using Mesa

Mesa Documentation, Release .1

Continuous space agents.
class HasPositionProtocol(*args, **kwargs)
Protocol for continuous space position holders.
class ContinuousSpaceAgent(space: ContinuousSpace, model)
A continuous space agent.
space
the continuous space in which the agent is located
Type
ContinuousSpace
position
the position of the agent
Type
np.ndarray
Initialize a continuous space agent.
Parameters
• space – the continuous space in which the agent is located
• model – the model to which the agent belongs
property position:

ndarray

Position of the agent.
remove() → None
Remove and delete the agent from the model and continuous space.
get_neighbors_in_radius(radius: float | int = 1) → tuple[list, ndarray]
Get neighbors within radius.
Parameters
radius – radius within which to look for neighbors
get_nearest_neighbors(k: int = 1) → tuple[list, ndarray]
Get neighbors within radius.
Parameters
k – the number of nearest neighbors to return
2.4.4.8.3 Continuous Space
A Continuous Space class.
class ContinuousSpace(dimensions: Buffer | _SupportsArray[dtype[Any]] |
_NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes |
_NestedSequence[bool | int | float | complex | str | bytes], torus: bool = False, random:
Random | None = None, n_agents: int = 100)
Continuous space where each agent can have an arbitrary position.
Create a new continuous space.
Parameters
• dimensions – a numpy array like object where each row specifies the minimum and maximum value of that dimension.
2.4. Citing Mesa

219

Mesa Documentation, Release .1

• torus – boolean for whether the space wraps around or not
• random – a seeded stdlib random.Random instance
• n_agents – the expected number of agents in the space
Internally, a numpy array is used to store the positions of all agents. This is resized if needed, but you can control
the initial size explicitly by passing n_agents.
property agents:

AgentSet

Return an AgentSet with the agents in the space.
calculate_difference_vector(point: ndarray, agents=None) → ndarray
Calculate the difference vector between the point and all agenents.
Parameters
• point – the point to calculate the difference vector for
• agents – the agents to calculate the difference vector of point with. By default, all agents
are considered.
calculate_distances(point: Buffer | _SupportsArray[dtype[Any]] |
_NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str |
bytes | _NestedSequence[bool | int | float | complex | str | bytes], agents:
Iterable[Agent] | None = None, **kwargs) → tuple[ndarray, list]
Calculate the distance between the point and all agents.
Parameters
• point – the point to calculate the difference vector for
• agents – the agents to calculate the difference vector of point with. By default, all agents
are considered.
• kwargs – any additional keyword arguments are passed to scipy’s cdist, which is used only
if torus is False. This allows for non-Euclidian distance measures.
get_agents_in_radius(point: Buffer | _SupportsArray[dtype[Any]] |
_NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str |
bytes | _NestedSequence[bool | int | float | complex | str | bytes], radius: float | int
= 1) → tuple[list, ndarray]
Return the agents and their distances within a radius for the point.
get_k_nearest_agents(point: Buffer | _SupportsArray[dtype[Any]] |
_NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str |
bytes | _NestedSequence[bool | int | float | complex | str | bytes], k: int = 1) →
tuple[list, ndarray]
Return the k nearest agents and their distances to the point.
Notes
This method returns exactly k agents, ignoring ties. In case of ties, the earlier an agent is inserted the higher
it will rank.
in_bounds(point: Buffer | _SupportsArray[dtype[Any]] | _NestedSequence[_SupportsArray[dtype[Any]]] |
bool | int | float | complex | str | bytes | _NestedSequence[bool | int | float | complex | str | bytes])
→ bool
Check if point is inside the bounds of the space.

220

Chapter 2. Using Mesa

Mesa Documentation, Release .1

torus_correct(point: Buffer | _SupportsArray[dtype[Any]] |
_NestedSequence[_SupportsArray[dtype[Any]]] | bool | int | float | complex | str | bytes |
_NestedSequence[bool | int | float | complex | str | bytes]) → ndarray
Apply a torus correction to the point.
Continuous space agents.
class HasPositionProtocol(*args, **kwargs)
Protocol for continuous space position holders.
class ContinuousSpaceAgent(space: ContinuousSpace, model)
A continuous space agent.
space
the continuous space in which the agent is located
Type
ContinuousSpace
position
the position of the agent
Type
np.ndarray
Initialize a continuous space agent.
Parameters
• space – the continuous space in which the agent is located
• model – the model to which the agent belongs
property position:

ndarray

Position of the agent.
remove() → None
Remove and delete the agent from the model and continuous space.
get_neighbors_in_radius(radius: float | int = 1) → tuple[list, ndarray]
Get neighbors within radius.
Parameters
radius – radius within which to look for neighbors
get_nearest_neighbors(k: int = 1) → tuple[list, ndarray]
Get neighbors within radius.
Parameters
k – the number of nearest neighbors to return

2.4. Citing Mesa

221

Mesa Documentation, Release .1

222

Chapter 2. Using Mesa

CHAPTER

THREE

INDICES AND TABLES

• genindex
• modindex
• search

223

Mesa Documentation, Release .1

224

Chapter 3. Indices and tables

PYTHON MODULE INDEX

b
batchrunner, 200

d
datacollection, 198

e
experimental.continuous_space.continuous_space,
219
experimental.continuous_space.continuous_space_agents,
221
experimental.devs.eventlist, 211
experimental.devs.simulator, 214

m
mesa.discrete_space.__init__, 178
mesa.discrete_space.cell, 188
mesa.discrete_space.cell_agent, 189
mesa.discrete_space.cell_collection, 191
mesa.discrete_space.discrete_space, 192
mesa.discrete_space.grid, 194
mesa.discrete_space.network, 197
mesa.discrete_space.voronoi, 197
mesa.visualization.command_console, 208
mesa.visualization.components.__init__, 202
mesa.visualization.components.altair_components,
208
mesa.visualization.components.matplotlib_components,
204
mesa.visualization.mpl_space_drawing, 205
mesa.visualization.solara_viz, 201
mesa.visualization.user_param, 203

225

Mesa Documentation, Release .1

226

Python Module Index

INDEX

Symbols

B

_try_random (Grid attribute), 183, 195

BasicMovement
(class
mesa.discrete_space.cell_agent), 189
batch_run() (in module batchrunner), 201
batchrunner
module, 200
buffer (ConsoleManager attribute), 210

A
ABMSimulator (class in experimental.devs.simulator),
216
accept_tuple_argument() (in module mesa.space),
157
add() (AgentSet method), 154
add_agent() (Cell method), 178, 189
add_cell() (DiscreteSpace method), 181, 193
add_cell() (Network method), 185, 197
add_connection() (DiscreteSpace method), 182, 194
add_connection() (Network method), 185, 197
add_event() (EventList method), 213
add_point() (Delaunay method), 197
add_property_layer() (HexMultiGrid method), 171
add_property_layer() (HexSingleGrid method), 168
add_property_layer() (MultiGrid method), 164
add_property_layer() (SingleGrid method), 160
add_table_row() (DataCollector method), 200
Agent (class in mesa.agent), 149
agent_types (Model property), 148
agents (Cell attribute), 178, 188
agents (Cell property), 178, 189
agents (CellCollection attribute), 180, 191
agents (ContinuousSpace property), 175, 218, 220
agents (DiscreteSpace property), 182, 193
agents (HexMultiGrid property), 172
agents (HexSingleGrid property), 168
agents (Model property), 148
agents (MultiGrid property), 164
agents (NetworkGrid property), 176
agents (SingleGrid property), 160
agents_by_type (Model property), 148
AgentSet (class in mesa.agent), 151
agg() (AgentSet method), 153
agg() (GroupBy method), 156
aggregate() (PropertyLayer method), 186
aggregate_property() (PropertyLayer method), 159
all_cells (DiscreteSpace attribute), 181, 192
all_cells (DiscreteSpace property), 182, 194

in

C
calculate_difference_vector() (ContinuousSpace
method), 218, 220
calculate_distances() (ContinuousSpace method),
218, 220
cancel() (SimulationEvent method), 213
cancel_event() (Simulator method), 216
capacity (Cell attribute), 178, 188
capacity (DiscreteSpace attribute), 181, 192
capacity (Grid attribute), 183, 195
CaptureOutput
(class
in
mesa.visualization.command_console), 209
cell (CellAgent attribute), 179, 190
Cell (class in mesa.discrete_space.__init__), 178
Cell (class in mesa.discrete_space.cell), 188
cell_klass (DiscreteSpace attribute), 181, 192
CellAgent (class in mesa.discrete_space.__init__), 179
CellAgent (class in mesa.discrete_space.cell_agent),
190
CellCollection
(class
in
mesa.discrete_space.__init__), 180
CellCollection
(class
in
mesa.discrete_space.cell_collection), 191
cells (CellCollection attribute), 180, 191
chart_property_layers()
(in
module
mesa.visualization.components.altair_components),
208
check_param_is_fixed()
(in
module
mesa.visualization.solara_viz), 202
check_time_unit() (ABMSimulator method), 216
check_time_unit() (DEVSimulator method), 217
clear() (AgentSet method), 155
clear() (EventList method), 213
clear_console() (ConsoleManager method), 211
227

Mesa Documentation, Release .1

collect() (DataCollector method), 199
draw_hex_grid()
(in
module
collect_agent_data()
(in
module
mesa.visualization.mpl_space_drawing),
mesa.visualization.mpl_space_drawing),
206
205
draw_network()
(in
module
command (ConsoleEntry attribute), 209
mesa.visualization.mpl_space_drawing),
connect() (Cell method), 178, 188
206
console (ConsoleManager attribute), 210
draw_orthogonal_grid()
(in
module
ConsoleEntry
(class
in
mesa.visualization.mpl_space_drawing),
mesa.visualization.command_console), 209
206
ConsoleManager
(class
in draw_property_layers()
(in
module
mesa.visualization.command_console), 210
mesa.visualization.mpl_space_drawing),
ContinuousSpace
(class
in
experimen206
tal.continuous_space.continuous_space),
draw_space()
(in
module
217, 219
mesa.visualization.mpl_space_drawing),
ContinuousSpace (class in mesa.space), 175
205
ContinuousSpaceAgent
(class
in
experimen- draw_voronoi_grid()
(in
module
tal.continuous_space.continuous_space_agents),
mesa.visualization.mpl_space_drawing),
219, 221
207
coord_iter() (HexMultiGrid method), 172
E
coord_iter() (HexSingleGrid method), 168
coord_iter() (MultiGrid method), 165
empties (DiscreteSpace attribute), 181, 193
coord_iter() (SingleGrid method), 160
empties (DiscreteSpace property), 182, 194
coordinate (Cell attribute), 178, 188
empty_mask (HexMultiGrid property), 172
count() (AgentSet method), 155
empty_mask (HexSingleGrid property), 168
count() (GroupBy method), 156
empty_mask (MultiGrid property), 165
create_agents() (Agent class method), 150
empty_mask (SingleGrid property), 160
event_list (Simulator attribute), 214
D
EventList (class in experimental.devs.eventlist), 213
execute() (SimulationEvent method), 213
data (PropertyLayer attribute), 158, 186
execute_code() (ConsoleManager method), 211
datacollection
exists_empty_cells() (HexMultiGrid method), 172
module, 198
exists_empty_cells() (HexSingleGrid method), 168
DataCollector (class in datacollection), 198
exists_empty_cells() (MultiGrid method), 165
default_val() (HexMultiGrid static method), 172
exists_empty_cells() (SingleGrid method), 160
default_val() (HexSingleGrid static method), 168
experimental.continuous_space.continuous_space
default_val() (MultiGrid static method), 164
module, 217, 219
default_val() (NetworkGrid static method), 176
experimental.continuous_space.continuous_space_agents
default_val() (SingleGrid static method), 160
module, 219, 221
Delaunay (class in mesa.discrete_space.voronoi), 197
experimental.devs.eventlist
deregister_agent() (Model method), 149
module, 211
DEVSimulator (class in experimental.devs.simulator),
experimental.devs.simulator
217
module, 214
dimensions (Grid attribute), 183, 194
export_triangles() (Delaunay method), 197
dimensions (PropertyLayer attribute), 186
export_voronoi_regions() (Delaunay method), 198
discard() (AgentSet method), 154
disconnect() (Cell method), 179, 188
DiscreteSpace (class in mesa.discrete_space.__init__), F
181
FixedAgent (class in mesa.discrete_space.__init__), 183
DiscreteSpace
(class
in FixedAgent (class in mesa.discrete_space.cell_agent),
mesa.discrete_space.discrete_space), 192
190
do() (AgentSet method), 152
FixedCell (class in mesa.discrete_space.cell_agent),
do() (GroupBy method), 156
190
draw_continuous_space()
(in
module fn (SimulationEvent attribute), 212
mesa.visualization.mpl_space_drawing),
format_command_html()
(in
module
207
mesa.visualization.command_console), 211
228

Index

Mesa Documentation, Release .1

format_output_html()
(in
module
mesa.visualization.command_console), 211
from_data() (PropertyLayer class method), 187
function_args (SimulationEvent attribute), 212
function_kwargs (SimulationEvent attribute), 212

Grid2DMovingAgent
(class
mesa.discrete_space.cell_agent), 190
GroupBy (class in mesa.agent), 155
groupby() (AgentSet method), 155
groups (GroupBy attribute), 155

G

H

get() (AgentSet method), 153
get() (Slider method), 204
get_agent_vars_dataframe()
(DataCollector
method), 200
get_agents_in_radius() (ContinuousSpace method),
218, 220
get_agenttype_vars_dataframe() (DataCollector
method), 200
get_all_cell_contents() (NetworkGrid method),
177
get_cell_list_contents() (NetworkGrid method),
177
get_distance() (ContinuousSpace method), 176
get_entries() (ConsoleManager method), 211
get_heading() (ContinuousSpace method), 176
get_k_nearest_agents() (ContinuousSpace method),
218, 220
get_model_vars_dataframe()
(DataCollector
method), 200
get_nearest_neighbors() (ContinuousSpaceAgent
method), 219, 221
get_neighborhood() (Cell method), 179, 189
get_neighborhood() (HexMultiGrid method), 172
get_neighborhood() (HexSingleGrid method), 168
get_neighborhood() (MultiGrid method), 165
get_neighborhood() (NetworkGrid method), 176
get_neighborhood() (SingleGrid method), 160
get_neighborhood_mask() (HexMultiGrid method),
172
get_neighborhood_mask() (HexSingleGrid method),
169
get_neighborhood_mask() (MultiGrid method), 165
get_neighborhood_mask() (SingleGrid method), 161
get_neighbors() (ContinuousSpace method), 175
get_neighbors() (HexMultiGrid method), 173
get_neighbors() (HexSingleGrid method), 169
get_neighbors() (MultiGrid method), 165
get_neighbors() (NetworkGrid method), 177
get_neighbors() (SingleGrid method), 161
get_neighbors_in_radius() (ContinuousSpaceAgent
method), 219, 221
get_output() (CaptureOutput method), 209
get_table_dataframe() (DataCollector method), 200
Grid (class in mesa.discrete_space.__init__), 183
Grid (class in mesa.discrete_space.grid), 194
Grid2DMovingAgent
(class
in
mesa.discrete_space.__init__), 184

HasCell (class in mesa.discrete_space.cell_agent), 189
HasCellProtocol
(class
in
mesa.discrete_space.cell_agent), 189
HasPositionProtocol
(class
in
experimental.continuous_space.continuous_space_agents),
219, 221
height (Grid property), 184, 195
height (PropertyLayer attribute), 158
HexGrid (class in mesa.discrete_space.__init__), 184
HexGrid (class in mesa.discrete_space.grid), 196
HexMultiGrid (class in mesa.space), 171
HexSingleGrid (class in mesa.space), 167
history (ConsoleManager attribute), 210

Index

in

I
in_bounds() (ContinuousSpace method), 218, 220
index() (AgentSet method), 155
InteractiveConsole
(class
in
mesa.visualization.command_console), 210
is_cell_empty() (HexMultiGrid method), 173
is_cell_empty() (HexSingleGrid method), 169
is_cell_empty() (MultiGrid method), 166
is_cell_empty() (NetworkGrid method), 177
is_cell_empty() (SingleGrid method), 161
is_continuation (ConsoleEntry attribute), 209
is_empty (Cell property), 179, 189
is_empty() (EventList method), 213
is_error (ConsoleEntry attribute), 209
is_full (Cell property), 179, 189
is_integer() (in module mesa.space), 157
is_single_argument_function()
(in
module
mesa.space), 157
isdisjoint() (AgentSet method), 155
iter_cell_list_contents() (NetworkGrid method),
177
iter_neighborhood() (HexMultiGrid method), 173
iter_neighborhood() (HexSingleGrid method), 169
iter_neighborhood() (MultiGrid method), 166
iter_neighborhood() (SingleGrid method), 161
iter_neighbors() (HexMultiGrid method), 173
iter_neighbors() (HexSingleGrid method), 169
iter_neighbors() (MultiGrid method), 164
iter_neighbors() (SingleGrid method), 162

L
locals_dict (ConsoleManager attribute), 210

229

Mesa Documentation, Release .1

M

mesa.visualization.components.__init__
module, 202
make_altair_space()
(in
module
mesa.visualization.components.altair_components
mesa.visualization.components.altair_components),
module, 208
208
mesa.visualization.components.matplotlib_components
make_initial_grid_layout()
(in
module
module, 204
mesa.visualization.solara_viz), 202
mesa.visualization.mpl_space_drawing
make_mpl_plot_component()
(in
module
module, 205
mesa.visualization.components.matplotlib_components),
mesa.visualization.solara_viz
204
module, 201
make_mpl_space_component()
(in
module
mesa.visualization.user_param
mesa.visualization.components.matplotlib_components),
module, 203
204
model
(Agent attribute), 149
make_plot_component()
(in
module
model
(AgentSet attribute), 151
mesa.visualization.components.__init__),
Model
(class in mesa.model), 147
203
model
(Simulator attribute), 214
make_plot_measure()
(in
module
modify_cell()
(PropertyLayer method), 158
mesa.visualization.components.matplotlib_components),
modify_cells()
(PropertyLayer method), 159, 187
204
module
make_space_altair()
(in
module
mesa.visualization.components.altair_components), batchrunner, 200
datacollection, 198
208
experimental.continuous_space.continuous_space,
make_space_component()
(in
module
217, 219
mesa.visualization.components.__init__),
experimental.continuous_space.continuous_space_agents,
202
219, 221
make_space_matplotlib()
(in
module
experimental.devs.eventlist,
211
mesa.visualization.components.matplotlib_components),
experimental.devs.simulator,
214
204
mesa.agent,
149
map() (AgentSet method), 153
mesa.discrete_space.__init__, 178
map() (GroupBy method), 156
mesa.discrete_space.cell, 188
maybe_raise_error() (UserParam method), 203
mesa.discrete_space.cell_agent, 189
mesa.agent
mesa.discrete_space.cell_collection, 191
module, 149
mesa.discrete_space.discrete_space, 192
mesa.discrete_space.__init__
mesa.discrete_space.grid, 194
module, 178
mesa.discrete_space.network, 197
mesa.discrete_space.cell
mesa.discrete_space.voronoi, 197
module, 188
mesa.model, 147
mesa.discrete_space.cell_agent
mesa.space, 157
module, 189
mesa.visualization.command_console, 208
mesa.discrete_space.cell_collection
mesa.visualization.components.__init__,
module, 191
202
mesa.discrete_space.discrete_space
mesa.visualization.components.altair_components,
module, 192
208
mesa.discrete_space.grid
mesa.visualization.components.matplotlib_components,
module, 194
204
mesa.discrete_space.network
mesa.visualization.mpl_space_drawing,
205
module, 197
mesa.visualization.solara_viz,
201
mesa.discrete_space.voronoi
mesa.visualization.user_param, 203
module, 197
move()
(Grid2DMovingAgent method), 184, 191
mesa.model
move_agent()
(ContinuousSpace method), 175
module, 147
move_agent()
(HexMultiGrid method), 173
mesa.space
move_agent()
(HexSingleGrid method), 170
module, 157
move_agent()
(MultiGrid method), 166
mesa.visualization.command_console
move_agent()
(NetworkGrid method), 177
module, 208
230

Index

Mesa Documentation, Release .1

move_agent() (SingleGrid method), 162
move_agent_to_one_of() (HexMultiGrid method),
173
move_agent_to_one_of() (HexSingleGrid method),
170
move_agent_to_one_of() (MultiGrid method), 166
move_agent_to_one_of() (SingleGrid method), 162
move_relative() (BasicMovement method), 190
move_to() (BasicMovement method), 190
move_to_empty() (HexMultiGrid method), 174
move_to_empty() (HexSingleGrid method), 170
move_to_empty() (MultiGrid method), 167
move_to_empty() (SingleGrid method), 162
MultiGrid (class in mesa.space), 163

PropertyLayer (class in mesa.space), 157
push() (InteractiveConsole method), 210

R

random (Agent property), 150
random (Cell attribute), 178, 188
random (CellCollection attribute), 180, 191
random (DiscreteSpace attribute), 181, 192
random (Grid attribute), 183, 195
random (Model attribute), 148
register_agent() (Model method), 148
remove() (Agent method), 150
remove() (AgentSet method), 155
remove() (CellAgent method), 180, 190
remove() (ContinuousSpaceAgent method), 219, 221
N
remove() (EventList method), 213
name (PropertyLayer attribute), 157, 186
remove() (FixedAgent method), 183, 190
neighborhood (Cell property), 179, 189
remove_agent() (Cell method), 179, 189
Network (class in mesa.discrete_space.__init__), 185
remove_agent() (ContinuousSpace method), 175
Network (class in mesa.discrete_space.network), 197
remove_agent() (HexMultiGrid method), 174
NetworkGrid (class in mesa.space), 176
remove_agent() (HexSingleGrid method), 170
next_command() (ConsoleManager method), 211
remove_agent() (MultiGrid method), 164
remove_agent() (NetworkGrid method), 177
O
remove_agent() (SingleGrid method), 160
OrthogonalMooreGrid
(class
in remove_all_agents() (Model method), 149
remove_cell() (DiscreteSpace method), 182, 193
mesa.discrete_space.__init__), 185
OrthogonalMooreGrid
(class
in remove_cell() (Network method), 185, 197
remove_connection() (DiscreteSpace method), 182,
mesa.discrete_space.grid), 195
194
OrthogonalVonNeumannGrid
(class
in
remove_connection() (Network method), 185, 197
mesa.discrete_space.__init__), 185
OrthogonalVonNeumannGrid
(class
in remove_property_layer() (HexMultiGrid method),
174
mesa.discrete_space.grid), 196
remove_property_layer() (HexSingleGrid method),
out_of_bounds() (ContinuousSpace method), 176
170
out_of_bounds() (HexMultiGrid method), 174
remove_property_layer() (MultiGrid method), 167
out_of_bounds() (HexSingleGrid method), 170
remove_property_layer() (SingleGrid method), 163
out_of_bounds() (MultiGrid method), 167
reset() (Simulator method), 215
out_of_bounds() (SingleGrid method), 163
reset_randomizer() (Model method), 149
output (ConsoleEntry attribute), 209
reset_rng() (Model method), 149
P
rng (Agent property), 150
rng (Model attribute), 148
peak_ahead() (EventList method), 213
pickle_gridcell()
(in
module run_for() (Simulator method), 215
run_model() (Model method), 149
mesa.discrete_space.grid), 194
run_next_event() (Simulator method), 215
pop() (AgentSet method), 155
run_until() (ABMSimulator method), 217
pop_event() (EventList method), 213
run_until() (Simulator method), 215
pos (Agent attribute), 150
running (Model attribute), 148
position (ContinuousSpaceAgent attribute), 219, 221
position (ContinuousSpaceAgent property), 219, 221
S
prev_command() (ConsoleManager method), 211
Priority (class in experimental.devs.eventlist), 212
schedule_event_absolute() (Simulator method), 215
priority (SimulationEvent attribute), 212
schedule_event_next_tick()
(ABMSimulator
property_layers (DiscreteSpace attribute), 181, 193
method), 217
PropertyLayer (class in mesa.discrete_space.__init__), schedule_event_now() (Simulator method), 215
186
schedule_event_relative() (Simulator method), 216

Index

231

Mesa Documentation, Release .1

select() (AgentSet method), 151
select() (CellCollection method), 180, 192
select_cells() (HexMultiGrid method), 174
select_cells() (HexSingleGrid method), 170
select_cells() (MultiGrid method), 167
select_cells() (PropertyLayer method), 159, 187
select_cells() (SingleGrid method), 163
select_random_agent() (CellCollection method),
180, 192
select_random_cell() (CellCollection method), 180,
192
select_random_empty_cell()
(DiscreteSpace
method), 183, 194
select_random_empty_cell() (Grid method), 184,
195
set() (AgentSet method), 154
set_cell() (PropertyLayer method), 158
set_cells() (PropertyLayer method), 158, 187
setup() (ABMSimulator method), 216
setup() (Simulator method), 214
shuffle() (AgentSet method), 152
shuffle_do() (AgentSet method), 153
SimulationEvent (class in experimental.devs.eventlist),
212
Simulator (class in experimental.devs.simulator), 214
SingleGrid (class in mesa.space), 159
Slider (class in mesa.visualization.user_param), 203
sort() (AgentSet method), 152
space (ContinuousSpaceAgent attribute), 219, 221
split_model_params()
(in
module
mesa.visualization.solara_viz), 202
step() (Agent method), 150
step() (Model method), 149
steps (Model attribute), 148
swap_pos() (HexMultiGrid method), 175
swap_pos() (HexSingleGrid method), 171
swap_pos() (MultiGrid method), 167
swap_pos() (SingleGrid method), 163

unpickle_gridcell()
(in
module
mesa.discrete_space.grid), 194
UserParam (class in mesa.visualization.user_param),
203

V
VoronoiGrid (class in mesa.discrete_space.__init__),
187
VoronoiGrid (class in mesa.discrete_space.voronoi),
198

W
warn_if_agent_has_position_already() (in module mesa.space), 157
width (Grid property), 184, 195
width (PropertyLayer attribute), 158

T
time (SimulationEvent attribute), 212
time (Simulator attribute), 214
time_unit (Simulator attribute), 214
torus (Grid attribute), 183, 195
torus_adj() (ContinuousSpace method), 176
torus_adj() (HexMultiGrid method), 175
torus_adj() (HexSingleGrid method), 171
torus_adj() (MultiGrid method), 167
torus_adj() (SingleGrid method), 163
torus_correct() (ContinuousSpace method), 218, 220

U
unique_id (Agent attribute), 149
unique_id (SimulationEvent attribute), 212
232

Index

